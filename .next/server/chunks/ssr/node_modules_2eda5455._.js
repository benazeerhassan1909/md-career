module.exports = {

"[project]/node_modules/@portabletext/toolkit/dist/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "LIST_NEST_MODE_DIRECT": (()=>LIST_NEST_MODE_DIRECT),
    "LIST_NEST_MODE_HTML": (()=>LIST_NEST_MODE_HTML),
    "buildMarksTree": (()=>buildMarksTree),
    "isPortableTextBlock": (()=>isPortableTextBlock),
    "isPortableTextListItemBlock": (()=>isPortableTextListItemBlock),
    "isPortableTextSpan": (()=>isPortableTextSpan),
    "isPortableTextToolkitList": (()=>isPortableTextToolkitList),
    "isPortableTextToolkitSpan": (()=>isPortableTextToolkitSpan),
    "isPortableTextToolkitTextNode": (()=>isPortableTextToolkitTextNode),
    "nestLists": (()=>nestLists),
    "sortMarksByOccurences": (()=>sortMarksByOccurences),
    "spanToPlainText": (()=>spanToPlainText),
    "toPlainText": (()=>toPlainText)
});
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
function isPortableTextSpan(node) {
    return node._type === "span" && "text" in node && typeof node.text == "string" && (typeof node.marks > "u" || Array.isArray(node.marks) && node.marks.every((mark)=>typeof mark == "string"));
}
function isPortableTextBlock(node) {
    return(// A block doesn't _have_ to be named 'block' - to differentiate between
    // allowed child types and marks, one might name them differently
    typeof node._type == "string" && // Toolkit-types like nested spans are @-prefixed
    node._type[0] !== "@" && (// `markDefs` isn't _required_ per say, but if it's there, it needs to be an array
    !("markDefs" in node) || !node.markDefs || Array.isArray(node.markDefs) && // Every mark definition needs to have an `_key` to be mappable in child spans
    node.markDefs.every((def)=>typeof def._key == "string")) && // `children` is required and needs to be an array
    "children" in node && Array.isArray(node.children) && // All children are objects with `_type` (usually spans, but can contain other stuff)
    node.children.every((child)=>typeof child == "object" && "_type" in child));
}
function isPortableTextListItemBlock(block) {
    return isPortableTextBlock(block) && "listItem" in block && typeof block.listItem == "string" && (typeof block.level > "u" || typeof block.level == "number");
}
function isPortableTextToolkitList(block) {
    return block._type === "@list";
}
function isPortableTextToolkitSpan(span) {
    return span._type === "@span";
}
function isPortableTextToolkitTextNode(node) {
    return node._type === "@text";
}
const knownDecorators = [
    "strong",
    "em",
    "code",
    "underline",
    "strike-through"
];
function sortMarksByOccurences(span, index, blockChildren) {
    if (!isPortableTextSpan(span) || !span.marks) return [];
    if (!span.marks.length) return [];
    const marks = span.marks.slice(), occurences = {};
    return marks.forEach((mark)=>{
        occurences[mark] = 1;
        for(let siblingIndex = index + 1; siblingIndex < blockChildren.length; siblingIndex++){
            const sibling = blockChildren[siblingIndex];
            if (sibling && isPortableTextSpan(sibling) && Array.isArray(sibling.marks) && sibling.marks.indexOf(mark) !== -1) occurences[mark]++;
            else break;
        }
    }), marks.sort((markA, markB)=>sortMarks(occurences, markA, markB));
}
function sortMarks(occurences, markA, markB) {
    const aOccurences = occurences[markA], bOccurences = occurences[markB];
    if (aOccurences !== bOccurences) return bOccurences - aOccurences;
    const aKnownPos = knownDecorators.indexOf(markA), bKnownPos = knownDecorators.indexOf(markB);
    return aKnownPos !== bKnownPos ? aKnownPos - bKnownPos : markA.localeCompare(markB);
}
function buildMarksTree(block) {
    var _a, _b;
    const { children } = block, markDefs = (_a = block.markDefs) != null ? _a : [];
    if (!children || !children.length) return [];
    const sortedMarks = children.map(sortMarksByOccurences), rootNode = {
        _type: "@span",
        children: [],
        markType: "<unknown>"
    };
    let nodeStack = [
        rootNode
    ];
    for(let i = 0; i < children.length; i++){
        const span = children[i];
        if (!span) continue;
        const marksNeeded = sortedMarks[i] || [];
        let pos = 1;
        if (nodeStack.length > 1) for(pos; pos < nodeStack.length; pos++){
            const mark = ((_b = nodeStack[pos]) == null ? void 0 : _b.markKey) || "", index = marksNeeded.indexOf(mark);
            if (index === -1) break;
            marksNeeded.splice(index, 1);
        }
        nodeStack = nodeStack.slice(0, pos);
        let currentNode = nodeStack[nodeStack.length - 1];
        if (currentNode) {
            for (const markKey of marksNeeded){
                const markDef = markDefs == null ? void 0 : markDefs.find((def)=>def._key === markKey), markType = markDef ? markDef._type : markKey, node = {
                    _type: "@span",
                    _key: span._key,
                    children: [],
                    markDef,
                    markType,
                    markKey
                };
                currentNode.children.push(node), nodeStack.push(node), currentNode = node;
            }
            if (isPortableTextSpan(span)) {
                const lines = span.text.split(`
`);
                for(let line = lines.length; line-- > 1;)lines.splice(line, 0, `
`);
                currentNode.children = currentNode.children.concat(lines.map((text)=>({
                        _type: "@text",
                        text
                    })));
            } else currentNode.children = currentNode.children.concat(span);
        }
    }
    return rootNode.children;
}
function nestLists(blocks, mode) {
    const tree = [];
    let currentList;
    for(let i = 0; i < blocks.length; i++){
        const block = blocks[i];
        if (block) {
            if (!isPortableTextListItemBlock(block)) {
                tree.push(block), currentList = void 0;
                continue;
            }
            if (!currentList) {
                currentList = listFromBlock(block, i, mode), tree.push(currentList);
                continue;
            }
            if (blockMatchesList(block, currentList)) {
                currentList.children.push(block);
                continue;
            }
            if ((block.level || 1) > currentList.level) {
                const newList = listFromBlock(block, i, mode);
                if (mode === "html") {
                    const lastListItem = currentList.children[currentList.children.length - 1], newLastChild = _objectSpread(_objectSpread({}, lastListItem), {}, {
                        children: [
                            ...lastListItem.children,
                            newList
                        ]
                    });
                    currentList.children[currentList.children.length - 1] = newLastChild;
                } else currentList.children.push(newList);
                currentList = newList;
                continue;
            }
            if ((block.level || 1) < currentList.level) {
                const matchingBranch = tree[tree.length - 1], match = matchingBranch && findListMatching(matchingBranch, block);
                if (match) {
                    currentList = match, currentList.children.push(block);
                    continue;
                }
                currentList = listFromBlock(block, i, mode), tree.push(currentList);
                continue;
            }
            if (block.listItem !== currentList.listItem) {
                const matchingBranch = tree[tree.length - 1], match = matchingBranch && findListMatching(matchingBranch, {
                    level: block.level || 1
                });
                if (match && match.listItem === block.listItem) {
                    currentList = match, currentList.children.push(block);
                    continue;
                } else {
                    currentList = listFromBlock(block, i, mode), tree.push(currentList);
                    continue;
                }
            }
            console.warn("Unknown state encountered for block", block), tree.push(block);
        }
    }
    return tree;
}
function blockMatchesList(block, list) {
    return (block.level || 1) === list.level && block.listItem === list.listItem;
}
function listFromBlock(block, index, mode) {
    return {
        _type: "@list",
        _key: `${block._key || `${index}`}-parent`,
        mode,
        level: block.level || 1,
        listItem: block.listItem,
        children: [
            block
        ]
    };
}
function findListMatching(rootNode, matching) {
    const level = matching.level || 1, style = matching.listItem || "normal", filterOnType = typeof matching.listItem == "string";
    if (isPortableTextToolkitList(rootNode) && (rootNode.level || 1) === level && filterOnType && (rootNode.listItem || "normal") === style) return rootNode;
    if (!("children" in rootNode)) return;
    const node = rootNode.children[rootNode.children.length - 1];
    return node && !isPortableTextSpan(node) ? findListMatching(node, matching) : void 0;
}
function spanToPlainText(span) {
    let text = "";
    return span.children.forEach((current)=>{
        isPortableTextToolkitTextNode(current) ? text += current.text : isPortableTextToolkitSpan(current) && (text += spanToPlainText(current));
    }), text;
}
const leadingSpace = /^\s/, trailingSpace = /\s$/;
function toPlainText(block) {
    const blocks = Array.isArray(block) ? block : [
        block
    ];
    let text = "";
    return blocks.forEach((current, index)=>{
        if (!isPortableTextBlock(current)) return;
        let pad = !1;
        current.children.forEach((span)=>{
            isPortableTextSpan(span) ? (text += pad && text && !trailingSpace.test(text) && !leadingSpace.test(span.text) ? " " : "", text += span.text, pad = !1) : pad = !0;
        }), index !== blocks.length - 1 && (text += `

`);
    }), text;
}
const LIST_NEST_MODE_HTML = "html", LIST_NEST_MODE_DIRECT = "direct";
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@portabletext/react/dist/index.js [app-ssr] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "PortableText": (()=>PortableText),
    "defaultComponents": (()=>defaultComponents),
    "mergeComponents": (()=>mergeComponents)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/toolkit/dist/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
const _excluded = [
    "block",
    "list",
    "listItem",
    "marks",
    "types"
], _excluded2 = [
    "listItem"
], _excluded3 = [
    "_key"
];
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
function _objectWithoutProperties(e, t) {
    if (null == e) return {};
    var o, r, i = _objectWithoutPropertiesLoose(e, t);
    if (Object.getOwnPropertySymbols) {
        var s = Object.getOwnPropertySymbols(e);
        for(r = 0; r < s.length; r++)o = s[r], t.includes(o) || ({}).propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
}
function _objectWithoutPropertiesLoose(r, e) {
    if (null == r) return {};
    var t = {};
    for(var n in r)if (({}).hasOwnProperty.call(r, n)) {
        if (e.includes(n)) continue;
        t[n] = r[n];
    }
    return t;
}
;
;
;
;
const defaultLists = {
    number: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("ol", {
            children
        }),
    bullet: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("ul", {
            children
        })
}, DefaultListItem = ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("li", {
        children
    }), link = ({ children, value })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("a", {
        href: value?.href,
        children
    }), underlineStyle = {
    textDecoration: "underline"
}, defaultMarks = {
    em: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("em", {
            children
        }),
    strong: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("strong", {
            children
        }),
    code: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("code", {
            children
        }),
    underline: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("span", {
            style: underlineStyle,
            children
        }),
    "strike-through": ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("del", {
            children
        }),
    link
}, getTemplate = (type, prop)=>`[@portabletext/react] Unknown ${type}, specify a component for it in the \`components.${prop}\` prop`, unknownTypeWarning = (typeName)=>getTemplate(`block type "${typeName}"`, "types"), unknownMarkWarning = (markType)=>getTemplate(`mark type "${markType}"`, "marks"), unknownBlockStyleWarning = (blockStyle)=>getTemplate(`block style "${blockStyle}"`, "block"), unknownListStyleWarning = (listStyle)=>getTemplate(`list style "${listStyle}"`, "list"), unknownListItemStyleWarning = (listStyle)=>getTemplate(`list item style "${listStyle}"`, "listItem");
function printWarning(message) {
    console.warn(message);
}
const hidden = {
    display: "none"
}, DefaultUnknownType = ({ value, isInline })=>{
    const warning = unknownTypeWarning(value._type);
    return isInline ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("span", {
        style: hidden,
        children: warning
    }) : /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("div", {
        style: hidden,
        children: warning
    });
}, DefaultUnknownMark = ({ markType, children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("span", {
        className: `unknown__pt__mark__${markType}`,
        children
    }), DefaultUnknownBlockStyle = ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("p", {
        children
    }), DefaultUnknownList = ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("ul", {
        children
    }), DefaultUnknownListItem = ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("li", {
        children
    }), DefaultHardBreak = ()=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("br", {}), defaultBlockStyles = {
    normal: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("p", {
            children
        }),
    blockquote: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("blockquote", {
            children
        }),
    h1: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("h1", {
            children
        }),
    h2: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("h2", {
            children
        }),
    h3: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("h3", {
            children
        }),
    h4: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("h4", {
            children
        }),
    h5: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("h5", {
            children
        }),
    h6: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("h6", {
            children
        })
}, defaultComponents = {
    types: {},
    block: defaultBlockStyles,
    marks: defaultMarks,
    list: defaultLists,
    listItem: DefaultListItem,
    hardBreak: DefaultHardBreak,
    unknownType: DefaultUnknownType,
    unknownMark: DefaultUnknownMark,
    unknownList: DefaultUnknownList,
    unknownListItem: DefaultUnknownListItem,
    unknownBlockStyle: DefaultUnknownBlockStyle
};
function mergeComponents(parent, overrides) {
    const { block, list, listItem, marks, types } = overrides, rest = _objectWithoutProperties(overrides, _excluded);
    return _objectSpread(_objectSpread({}, parent), {}, {
        block: mergeDeeply(parent, overrides, "block"),
        list: mergeDeeply(parent, overrides, "list"),
        listItem: mergeDeeply(parent, overrides, "listItem"),
        marks: mergeDeeply(parent, overrides, "marks"),
        types: mergeDeeply(parent, overrides, "types")
    }, rest);
}
function mergeDeeply(parent, overrides, key) {
    const override = overrides[key], parentVal = parent[key];
    return typeof override == "function" || override && typeof parentVal == "function" ? override : override ? _objectSpread(_objectSpread({}, parentVal), override) : parentVal;
}
function PortableText({ value: input, components: componentOverrides, listNestingMode, onMissingComponent: missingComponentHandler = printWarning }) {
    const handleMissingComponent = missingComponentHandler || noop, blocks = Array.isArray(input) ? input : [
        input
    ], nested = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nestLists"])(blocks, listNestingMode || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LIST_NEST_MODE_HTML"]), components = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useMemo"])(()=>componentOverrides ? mergeComponents(defaultComponents, componentOverrides) : defaultComponents, [
        componentOverrides
    ]), renderNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useMemo"])(()=>getNodeRenderer(components, handleMissingComponent), [
        components,
        handleMissingComponent
    ]), rendered = nested.map((node, index)=>renderNode({
            node,
            index,
            isInline: !1,
            renderNode
        }));
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Fragment"], {
        children: rendered
    });
}
const getNodeRenderer = (components, handleMissingComponent)=>{
    function renderNode(options) {
        const { node, index, isInline } = options, key = node._key || `node-${index}`;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isPortableTextToolkitList"])(node) ? renderList(node, index, key) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isPortableTextListItemBlock"])(node) ? renderListItem(node, index, key) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isPortableTextToolkitSpan"])(node) ? renderSpan(node, index, key) : hasCustomComponentForNode(node) ? renderCustomBlock(node, index, key, isInline) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isPortableTextBlock"])(node) ? renderBlock(node, index, key, isInline) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isPortableTextToolkitTextNode"])(node) ? renderText(node, key) : renderUnknownType(node, index, key, isInline);
    }
    function hasCustomComponentForNode(node) {
        return node._type in components.types;
    }
    function renderListItem(node, index, key) {
        const tree = serializeBlock({
            node,
            index,
            isInline: !1,
            renderNode
        }), renderer = components.listItem, Li = (typeof renderer == "function" ? renderer : renderer[node.listItem]) || components.unknownListItem;
        if (Li === components.unknownListItem) {
            const style = node.listItem || "bullet";
            handleMissingComponent(unknownListItemStyleWarning(style), {
                type: style,
                nodeType: "listItemStyle"
            });
        }
        let children = tree.children;
        if (node.style && node.style !== "normal") {
            const { listItem } = node, blockNode = _objectWithoutProperties(node, _excluded2);
            children = renderNode({
                node: blockNode,
                index,
                isInline: !1,
                renderNode
            });
        }
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])(Li, {
            value: node,
            index,
            isInline: !1,
            renderNode,
            children
        }, key);
    }
    function renderList(node, index, key) {
        const children = node.children.map((child, childIndex)=>renderNode({
                node: child._key ? child : _objectSpread(_objectSpread({}, child), {}, {
                    _key: `li-${index}-${childIndex}`
                }),
                index: childIndex,
                isInline: !1,
                renderNode
            })), component = components.list, List = (typeof component == "function" ? component : component[node.listItem]) || components.unknownList;
        if (List === components.unknownList) {
            const style = node.listItem || "bullet";
            handleMissingComponent(unknownListStyleWarning(style), {
                nodeType: "listStyle",
                type: style
            });
        }
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])(List, {
            value: node,
            index,
            isInline: !1,
            renderNode,
            children
        }, key);
    }
    function renderSpan(node, _index, key) {
        const { markDef, markType, markKey } = node, Span = components.marks[markType] || components.unknownMark, children = node.children.map((child, childIndex)=>renderNode({
                node: child,
                index: childIndex,
                isInline: !0,
                renderNode
            }));
        return Span === components.unknownMark && handleMissingComponent(unknownMarkWarning(markType), {
            nodeType: "mark",
            type: markType
        }), /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])(Span, {
            text: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["spanToPlainText"])(node),
            value: markDef,
            markType,
            markKey,
            renderNode,
            children
        }, key);
    }
    function renderBlock(node, index, key, isInline) {
        const _serializeBlock = serializeBlock({
            node,
            index,
            isInline,
            renderNode
        }), { _key } = _serializeBlock, props = _objectWithoutProperties(_serializeBlock, _excluded3), style = props.node.style || "normal", Block = (typeof components.block == "function" ? components.block : components.block[style]) || components.unknownBlockStyle;
        return Block === components.unknownBlockStyle && handleMissingComponent(unknownBlockStyleWarning(style), {
            nodeType: "blockStyle",
            type: style
        }), /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])(Block, _objectSpread(_objectSpread({}, props), {}, {
            value: props.node,
            renderNode
        }), key);
    }
    function renderText(node, key) {
        if (node.text === `
`) {
            const HardBreak = components.hardBreak;
            return HardBreak ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])(HardBreak, {}, key) : `
`;
        }
        return node.text;
    }
    function renderUnknownType(node, index, key, isInline) {
        const nodeOptions = {
            value: node,
            isInline,
            index,
            renderNode
        };
        handleMissingComponent(unknownTypeWarning(node._type), {
            nodeType: "block",
            type: node._type
        });
        const UnknownType = components.unknownType;
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])(UnknownType, _objectSpread({}, nodeOptions), key);
    }
    function renderCustomBlock(node, index, key, isInline) {
        const nodeOptions = {
            value: node,
            isInline,
            index,
            renderNode
        }, Node = components.types[node._type];
        return Node ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])(Node, _objectSpread({}, nodeOptions), key) : null;
    }
    return renderNode;
};
function serializeBlock(options) {
    const { node, index, isInline, renderNode } = options, children = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["buildMarksTree"])(node).map((child, i)=>renderNode({
            node: child,
            isInline: !0,
            index: i,
            renderNode
        }));
    return {
        _key: node._key || `block-${index}`,
        children,
        index,
        isInline,
        node
    };
}
function noop() {}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/image-external.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    default: null,
    getImageProps: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    default: function() {
        return _default;
    },
    getImageProps: function() {
        return getImageProps;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-ssr] (ecmascript)");
const _getimgprops = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/get-img-props.js [app-ssr] (ecmascript)");
const _imagecomponent = __turbopack_context__.r("[project]/node_modules/next/dist/client/image-component.js [app-ssr] (ecmascript)");
const _imageloader = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/image-loader.js [app-ssr] (ecmascript)"));
function getImageProps(imgProps) {
    const { props } = (0, _getimgprops.getImgProps)(imgProps, {
        defaultLoader: _imageloader.default,
        // This is replaced by webpack define plugin
        imgConf: ("TURBOPACK compile-time value", JSON.parse('{"deviceSizes":[640,750,828,1080,1200,1920,2048,3840],"imageSizes":[16,32,48,64,96,128,256,384],"path":"/_next/image","loader":"default","dangerouslyAllowSVG":false,"unoptimized":false,"domains":[],"remotePatterns":[{"protocol":"https","hostname":"cdn.sanity.io"},{"protocol":"https","hostname":"placehold.co"}]}'))
    });
    // Normally we don't care about undefined props because we pass to JSX,
    // but this exported function could be used by the end user for anything
    // so we delete undefined props to clean it up a little.
    for (const [key, value] of Object.entries(props)){
        if (value === undefined) {
            delete props[key];
        }
    }
    return {
        props
    };
}
const _default = _imagecomponent.Image; //# sourceMappingURL=image-external.js.map
}}),
"[project]/node_modules/next/image.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/image-external.js [app-ssr] (ecmascript)");
}}),
"[project]/node_modules/@sanity/image-url/lib/node/parseAssetId.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
var example = 'image-Tb9Ew8CXIwaY6R1kjMvI0uRR-2000x3000-jpg';
function parseAssetId(ref) {
    var _a = ref.split('-'), id = _a[1], dimensionString = _a[2], format = _a[3];
    if (!id || !dimensionString || !format) {
        throw new Error("Malformed asset _ref '".concat(ref, "'. Expected an id like \"").concat(example, "\"."));
    }
    var _b = dimensionString.split('x'), imgWidthStr = _b[0], imgHeightStr = _b[1];
    var width = +imgWidthStr;
    var height = +imgHeightStr;
    var isValidAssetId = isFinite(width) && isFinite(height);
    if (!isValidAssetId) {
        throw new Error("Malformed asset _ref '".concat(ref, "'. Expected an id like \"").concat(example, "\"."));
    }
    return {
        id: id,
        width: width,
        height: height,
        format: format
    };
}
exports.default = parseAssetId; //# sourceMappingURL=parseAssetId.js.map
}}),
"[project]/node_modules/@sanity/image-url/lib/node/parseSource.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __assign = this && this.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
var isRef = function(src) {
    var source = src;
    return source ? typeof source._ref === 'string' : false;
};
var isAsset = function(src) {
    var source = src;
    return source ? typeof source._id === 'string' : false;
};
var isAssetStub = function(src) {
    var source = src;
    return source && source.asset ? typeof source.asset.url === 'string' : false;
};
// Convert an asset-id, asset or image to an image record suitable for processing
// eslint-disable-next-line complexity
function parseSource(source) {
    if (!source) {
        return null;
    }
    var image;
    if (typeof source === 'string' && isUrl(source)) {
        // Someone passed an existing image url?
        image = {
            asset: {
                _ref: urlToId(source)
            }
        };
    } else if (typeof source === 'string') {
        // Just an asset id
        image = {
            asset: {
                _ref: source
            }
        };
    } else if (isRef(source)) {
        // We just got passed an asset directly
        image = {
            asset: source
        };
    } else if (isAsset(source)) {
        // If we were passed an image asset document
        image = {
            asset: {
                _ref: source._id || ''
            }
        };
    } else if (isAssetStub(source)) {
        // If we were passed a partial asset (`url`, but no `_id`)
        image = {
            asset: {
                _ref: urlToId(source.asset.url)
            }
        };
    } else if (typeof source.asset === 'object') {
        // Probably an actual image with materialized asset
        image = __assign({}, source);
    } else {
        // We got something that does not look like an image, or it is an image
        // that currently isn't sporting an asset.
        return null;
    }
    var img = source;
    if (img.crop) {
        image.crop = img.crop;
    }
    if (img.hotspot) {
        image.hotspot = img.hotspot;
    }
    return applyDefaults(image);
}
exports.default = parseSource;
function isUrl(url) {
    return /^https?:\/\//.test("".concat(url));
}
function urlToId(url) {
    var parts = url.split('/').slice(-1);
    return "image-".concat(parts[0]).replace(/\.([a-z]+)$/, '-$1');
}
// Mock crop and hotspot if image lacks it
function applyDefaults(image) {
    if (image.crop && image.hotspot) {
        return image;
    }
    // We need to pad in default values for crop or hotspot
    var result = __assign({}, image);
    if (!result.crop) {
        result.crop = {
            left: 0,
            top: 0,
            bottom: 0,
            right: 0
        };
    }
    if (!result.hotspot) {
        result.hotspot = {
            x: 0.5,
            y: 0.5,
            height: 1.0,
            width: 1.0
        };
    }
    return result;
} //# sourceMappingURL=parseSource.js.map
}}),
"[project]/node_modules/@sanity/image-url/lib/node/urlForImage.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __assign = this && this.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parseSource = exports.SPEC_NAME_TO_URL_NAME_MAPPINGS = void 0;
var parseAssetId_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/@sanity/image-url/lib/node/parseAssetId.js [app-ssr] (ecmascript)"));
var parseSource_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/@sanity/image-url/lib/node/parseSource.js [app-ssr] (ecmascript)"));
exports.parseSource = parseSource_1.default;
exports.SPEC_NAME_TO_URL_NAME_MAPPINGS = [
    [
        'width',
        'w'
    ],
    [
        'height',
        'h'
    ],
    [
        'format',
        'fm'
    ],
    [
        'download',
        'dl'
    ],
    [
        'blur',
        'blur'
    ],
    [
        'sharpen',
        'sharp'
    ],
    [
        'invert',
        'invert'
    ],
    [
        'orientation',
        'or'
    ],
    [
        'minHeight',
        'min-h'
    ],
    [
        'maxHeight',
        'max-h'
    ],
    [
        'minWidth',
        'min-w'
    ],
    [
        'maxWidth',
        'max-w'
    ],
    [
        'quality',
        'q'
    ],
    [
        'fit',
        'fit'
    ],
    [
        'crop',
        'crop'
    ],
    [
        'saturation',
        'sat'
    ],
    [
        'auto',
        'auto'
    ],
    [
        'dpr',
        'dpr'
    ],
    [
        'pad',
        'pad'
    ],
    [
        'frame',
        'frame'
    ]
];
function urlForImage(options) {
    var spec = __assign({}, options || {});
    var source = spec.source;
    delete spec.source;
    var image = (0, parseSource_1.default)(source);
    if (!image) {
        throw new Error("Unable to resolve image URL from source (".concat(JSON.stringify(source), ")"));
    }
    var id = image.asset._ref || image.asset._id || '';
    var asset = (0, parseAssetId_1.default)(id);
    // Compute crop rect in terms of pixel coordinates in the raw source image
    var cropLeft = Math.round(image.crop.left * asset.width);
    var cropTop = Math.round(image.crop.top * asset.height);
    var crop = {
        left: cropLeft,
        top: cropTop,
        width: Math.round(asset.width - image.crop.right * asset.width - cropLeft),
        height: Math.round(asset.height - image.crop.bottom * asset.height - cropTop)
    };
    // Compute hot spot rect in terms of pixel coordinates
    var hotSpotVerticalRadius = image.hotspot.height * asset.height / 2;
    var hotSpotHorizontalRadius = image.hotspot.width * asset.width / 2;
    var hotSpotCenterX = image.hotspot.x * asset.width;
    var hotSpotCenterY = image.hotspot.y * asset.height;
    var hotspot = {
        left: hotSpotCenterX - hotSpotHorizontalRadius,
        top: hotSpotCenterY - hotSpotVerticalRadius,
        right: hotSpotCenterX + hotSpotHorizontalRadius,
        bottom: hotSpotCenterY + hotSpotVerticalRadius
    };
    // If irrelevant, or if we are requested to: don't perform crop/fit based on
    // the crop/hotspot.
    if (!(spec.rect || spec.focalPoint || spec.ignoreImageParams || spec.crop)) {
        spec = __assign(__assign({}, spec), fit({
            crop: crop,
            hotspot: hotspot
        }, spec));
    }
    return specToImageUrl(__assign(__assign({}, spec), {
        asset: asset
    }));
}
exports.default = urlForImage;
// eslint-disable-next-line complexity
function specToImageUrl(spec) {
    var cdnUrl = (spec.baseUrl || 'https://cdn.sanity.io').replace(/\/+$/, '');
    var vanityStub = spec.vanityName ? "/".concat(spec.vanityName) : '';
    var filename = "".concat(spec.asset.id, "-").concat(spec.asset.width, "x").concat(spec.asset.height, ".").concat(spec.asset.format).concat(vanityStub);
    var baseUrl = "".concat(cdnUrl, "/images/").concat(spec.projectId, "/").concat(spec.dataset, "/").concat(filename);
    var params = [];
    if (spec.rect) {
        // Only bother url with a crop if it actually crops anything
        var _a = spec.rect, left = _a.left, top_1 = _a.top, width = _a.width, height = _a.height;
        var isEffectiveCrop = left !== 0 || top_1 !== 0 || height !== spec.asset.height || width !== spec.asset.width;
        if (isEffectiveCrop) {
            params.push("rect=".concat(left, ",").concat(top_1, ",").concat(width, ",").concat(height));
        }
    }
    if (spec.bg) {
        params.push("bg=".concat(spec.bg));
    }
    if (spec.focalPoint) {
        params.push("fp-x=".concat(spec.focalPoint.x));
        params.push("fp-y=".concat(spec.focalPoint.y));
    }
    var flip = [
        spec.flipHorizontal && 'h',
        spec.flipVertical && 'v'
    ].filter(Boolean).join('');
    if (flip) {
        params.push("flip=".concat(flip));
    }
    // Map from spec name to url param name, and allow using the actual param name as an alternative
    exports.SPEC_NAME_TO_URL_NAME_MAPPINGS.forEach(function(mapping) {
        var specName = mapping[0], param = mapping[1];
        if (typeof spec[specName] !== 'undefined') {
            params.push("".concat(param, "=").concat(encodeURIComponent(spec[specName])));
        } else if (typeof spec[param] !== 'undefined') {
            params.push("".concat(param, "=").concat(encodeURIComponent(spec[param])));
        }
    });
    if (params.length === 0) {
        return baseUrl;
    }
    return "".concat(baseUrl, "?").concat(params.join('&'));
}
function fit(source, spec) {
    var cropRect;
    var imgWidth = spec.width;
    var imgHeight = spec.height;
    // If we are not constraining the aspect ratio, we'll just use the whole crop
    if (!(imgWidth && imgHeight)) {
        return {
            width: imgWidth,
            height: imgHeight,
            rect: source.crop
        };
    }
    var crop = source.crop;
    var hotspot = source.hotspot;
    // If we are here, that means aspect ratio is locked and fitting will be a bit harder
    var desiredAspectRatio = imgWidth / imgHeight;
    var cropAspectRatio = crop.width / crop.height;
    if (cropAspectRatio > desiredAspectRatio) {
        // The crop is wider than the desired aspect ratio. That means we are cutting from the sides
        var height = Math.round(crop.height);
        var width = Math.round(height * desiredAspectRatio);
        var top_2 = Math.max(0, Math.round(crop.top));
        // Center output horizontally over hotspot
        var hotspotXCenter = Math.round((hotspot.right - hotspot.left) / 2 + hotspot.left);
        var left = Math.max(0, Math.round(hotspotXCenter - width / 2));
        // Keep output within crop
        if (left < crop.left) {
            left = crop.left;
        } else if (left + width > crop.left + crop.width) {
            left = crop.left + crop.width - width;
        }
        cropRect = {
            left: left,
            top: top_2,
            width: width,
            height: height
        };
    } else {
        // The crop is taller than the desired ratio, we are cutting from top and bottom
        var width = crop.width;
        var height = Math.round(width / desiredAspectRatio);
        var left = Math.max(0, Math.round(crop.left));
        // Center output vertically over hotspot
        var hotspotYCenter = Math.round((hotspot.bottom - hotspot.top) / 2 + hotspot.top);
        var top_3 = Math.max(0, Math.round(hotspotYCenter - height / 2));
        // Keep output rect within crop
        if (top_3 < crop.top) {
            top_3 = crop.top;
        } else if (top_3 + height > crop.top + crop.height) {
            top_3 = crop.top + crop.height - height;
        }
        cropRect = {
            left: left,
            top: top_3,
            width: width,
            height: height
        };
    }
    return {
        width: imgWidth,
        height: imgHeight,
        rect: cropRect
    };
} //# sourceMappingURL=urlForImage.js.map
}}),
"[project]/node_modules/@sanity/image-url/lib/node/builder.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __assign = this && this.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ImageUrlBuilder = void 0;
var urlForImage_1 = __importStar(__turbopack_context__.r("[project]/node_modules/@sanity/image-url/lib/node/urlForImage.js [app-ssr] (ecmascript)"));
var validFits = [
    'clip',
    'crop',
    'fill',
    'fillmax',
    'max',
    'scale',
    'min'
];
var validCrops = [
    'top',
    'bottom',
    'left',
    'right',
    'center',
    'focalpoint',
    'entropy'
];
var validAutoModes = [
    'format'
];
function isSanityModernClientLike(client) {
    return client && 'config' in client ? typeof client.config === 'function' : false;
}
function isSanityClientLike(client) {
    return client && 'clientConfig' in client ? typeof client.clientConfig === 'object' : false;
}
function rewriteSpecName(key) {
    var specs = urlForImage_1.SPEC_NAME_TO_URL_NAME_MAPPINGS;
    for(var _i = 0, specs_1 = specs; _i < specs_1.length; _i++){
        var entry = specs_1[_i];
        var specName = entry[0], param = entry[1];
        if (key === specName || key === param) {
            return specName;
        }
    }
    return key;
}
function urlBuilder(options) {
    // Did we get a modernish client?
    if (isSanityModernClientLike(options)) {
        // Inherit config from client
        var _a = options.config(), apiUrl = _a.apiHost, projectId = _a.projectId, dataset = _a.dataset;
        var apiHost = apiUrl || 'https://api.sanity.io';
        return new ImageUrlBuilder(null, {
            baseUrl: apiHost.replace(/^https:\/\/api\./, 'https://cdn.'),
            projectId: projectId,
            dataset: dataset
        });
    }
    // Did we get a SanityClient?
    if (isSanityClientLike(options)) {
        // Inherit config from client
        var _b = options.clientConfig, apiUrl = _b.apiHost, projectId = _b.projectId, dataset = _b.dataset;
        var apiHost = apiUrl || 'https://api.sanity.io';
        return new ImageUrlBuilder(null, {
            baseUrl: apiHost.replace(/^https:\/\/api\./, 'https://cdn.'),
            projectId: projectId,
            dataset: dataset
        });
    }
    // Or just accept the options as given
    return new ImageUrlBuilder(null, options || {});
}
exports.default = urlBuilder;
var ImageUrlBuilder = function() {
    function ImageUrlBuilder(parent, options) {
        this.options = parent ? __assign(__assign({}, parent.options || {}), options || {}) : __assign({}, options || {}); // Copy options
    }
    ImageUrlBuilder.prototype.withOptions = function(options) {
        var baseUrl = options.baseUrl || this.options.baseUrl;
        var newOptions = {
            baseUrl: baseUrl
        };
        for(var key in options){
            if (options.hasOwnProperty(key)) {
                var specKey = rewriteSpecName(key);
                newOptions[specKey] = options[key];
            }
        }
        return new ImageUrlBuilder(this, __assign({
            baseUrl: baseUrl
        }, newOptions));
    };
    // The image to be represented. Accepts a Sanity 'image'-document, 'asset'-document or
    // _id of asset. To get the benefit of automatic hot-spot/crop integration with the content
    // studio, the 'image'-document must be provided.
    ImageUrlBuilder.prototype.image = function(source) {
        return this.withOptions({
            source: source
        });
    };
    // Specify the dataset
    ImageUrlBuilder.prototype.dataset = function(dataset) {
        return this.withOptions({
            dataset: dataset
        });
    };
    // Specify the projectId
    ImageUrlBuilder.prototype.projectId = function(projectId) {
        return this.withOptions({
            projectId: projectId
        });
    };
    // Specify background color
    ImageUrlBuilder.prototype.bg = function(bg) {
        return this.withOptions({
            bg: bg
        });
    };
    // Set DPR scaling factor
    ImageUrlBuilder.prototype.dpr = function(dpr) {
        // A DPR of 1 is the default - so only include it if we have a different value
        return this.withOptions(dpr && dpr !== 1 ? {
            dpr: dpr
        } : {});
    };
    // Specify the width of the image in pixels
    ImageUrlBuilder.prototype.width = function(width) {
        return this.withOptions({
            width: width
        });
    };
    // Specify the height of the image in pixels
    ImageUrlBuilder.prototype.height = function(height) {
        return this.withOptions({
            height: height
        });
    };
    // Specify focal point in fraction of image dimensions. Each component 0.0-1.0
    ImageUrlBuilder.prototype.focalPoint = function(x, y) {
        return this.withOptions({
            focalPoint: {
                x: x,
                y: y
            }
        });
    };
    ImageUrlBuilder.prototype.maxWidth = function(maxWidth) {
        return this.withOptions({
            maxWidth: maxWidth
        });
    };
    ImageUrlBuilder.prototype.minWidth = function(minWidth) {
        return this.withOptions({
            minWidth: minWidth
        });
    };
    ImageUrlBuilder.prototype.maxHeight = function(maxHeight) {
        return this.withOptions({
            maxHeight: maxHeight
        });
    };
    ImageUrlBuilder.prototype.minHeight = function(minHeight) {
        return this.withOptions({
            minHeight: minHeight
        });
    };
    // Specify width and height in pixels
    ImageUrlBuilder.prototype.size = function(width, height) {
        return this.withOptions({
            width: width,
            height: height
        });
    };
    // Specify blur between 0 and 100
    ImageUrlBuilder.prototype.blur = function(blur) {
        return this.withOptions({
            blur: blur
        });
    };
    ImageUrlBuilder.prototype.sharpen = function(sharpen) {
        return this.withOptions({
            sharpen: sharpen
        });
    };
    // Specify the desired rectangle of the image
    ImageUrlBuilder.prototype.rect = function(left, top, width, height) {
        return this.withOptions({
            rect: {
                left: left,
                top: top,
                width: width,
                height: height
            }
        });
    };
    // Specify the image format of the image. 'jpg', 'pjpg', 'png', 'webp'
    ImageUrlBuilder.prototype.format = function(format) {
        return this.withOptions({
            format: format
        });
    };
    ImageUrlBuilder.prototype.invert = function(invert) {
        return this.withOptions({
            invert: invert
        });
    };
    // Rotation in degrees 0, 90, 180, 270
    ImageUrlBuilder.prototype.orientation = function(orientation) {
        return this.withOptions({
            orientation: orientation
        });
    };
    // Compression quality 0-100
    ImageUrlBuilder.prototype.quality = function(quality) {
        return this.withOptions({
            quality: quality
        });
    };
    // Make it a download link. Parameter is default filename.
    ImageUrlBuilder.prototype.forceDownload = function(download) {
        return this.withOptions({
            download: download
        });
    };
    // Flip image horizontally
    ImageUrlBuilder.prototype.flipHorizontal = function() {
        return this.withOptions({
            flipHorizontal: true
        });
    };
    // Flip image vertically
    ImageUrlBuilder.prototype.flipVertical = function() {
        return this.withOptions({
            flipVertical: true
        });
    };
    // Ignore crop/hotspot from image record, even when present
    ImageUrlBuilder.prototype.ignoreImageParams = function() {
        return this.withOptions({
            ignoreImageParams: true
        });
    };
    ImageUrlBuilder.prototype.fit = function(value) {
        if (validFits.indexOf(value) === -1) {
            throw new Error("Invalid fit mode \"".concat(value, "\""));
        }
        return this.withOptions({
            fit: value
        });
    };
    ImageUrlBuilder.prototype.crop = function(value) {
        if (validCrops.indexOf(value) === -1) {
            throw new Error("Invalid crop mode \"".concat(value, "\""));
        }
        return this.withOptions({
            crop: value
        });
    };
    // Saturation
    ImageUrlBuilder.prototype.saturation = function(saturation) {
        return this.withOptions({
            saturation: saturation
        });
    };
    ImageUrlBuilder.prototype.auto = function(value) {
        if (validAutoModes.indexOf(value) === -1) {
            throw new Error("Invalid auto mode \"".concat(value, "\""));
        }
        return this.withOptions({
            auto: value
        });
    };
    // Specify the number of pixels to pad the image
    ImageUrlBuilder.prototype.pad = function(pad) {
        return this.withOptions({
            pad: pad
        });
    };
    // Vanity URL for more SEO friendly URLs
    ImageUrlBuilder.prototype.vanityName = function(value) {
        return this.withOptions({
            vanityName: value
        });
    };
    ImageUrlBuilder.prototype.frame = function(frame) {
        if (frame !== 1) {
            throw new Error("Invalid frame value \"".concat(frame, "\""));
        }
        return this.withOptions({
            frame: frame
        });
    };
    // Gets the url based on the submitted parameters
    ImageUrlBuilder.prototype.url = function() {
        return (0, urlForImage_1.default)(this.options);
    };
    // Alias for url()
    ImageUrlBuilder.prototype.toString = function() {
        return this.url();
    };
    return ImageUrlBuilder;
}();
exports.ImageUrlBuilder = ImageUrlBuilder; //# sourceMappingURL=builder.js.map
}}),
"[project]/node_modules/@sanity/image-url/lib/node/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
var builder_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/@sanity/image-url/lib/node/builder.js [app-ssr] (ecmascript)"));
module.exports = builder_1.default; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@sanity/client/dist/_chunks-es/resolveEditInfo.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "DRAFTS_FOLDER": (()=>DRAFTS_FOLDER),
    "VERSION_FOLDER": (()=>VERSION_FOLDER),
    "createEditUrl": (()=>createEditUrl),
    "get": (()=>get),
    "getDraftId": (()=>getDraftId),
    "getPublishedId": (()=>getPublishedId),
    "getVersionFromId": (()=>getVersionFromId),
    "getVersionId": (()=>getVersionId),
    "isDraftId": (()=>isDraftId),
    "isPublishedId": (()=>isPublishedId),
    "isVersionId": (()=>isVersionId),
    "jsonPath": (()=>jsonPath),
    "jsonPathToStudioPath": (()=>jsonPathToStudioPath),
    "parseJsonPath": (()=>parseJsonPath),
    "reKeySegment": (()=>reKeySegment),
    "resolveEditInfo": (()=>resolveEditInfo),
    "resolveMapping": (()=>resolveMapping),
    "resolveStudioBaseRoute": (()=>resolveStudioBaseRoute),
    "studioPath": (()=>studioPath),
    "studioPathToJsonPath": (()=>studioPathToJsonPath),
    "toString": (()=>toString),
    "walkMap": (()=>walkMap)
});
const rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, reKeySegment = /_key\s*==\s*['"](.*)['"]/, reIndexTuple = /^\d*:\d*$/;
function isIndexSegment(segment) {
    return typeof segment == "number" || typeof segment == "string" && /^\[\d+\]$/.test(segment);
}
function isKeySegment(segment) {
    return typeof segment == "string" ? reKeySegment.test(segment.trim()) : typeof segment == "object" && "_key" in segment;
}
function isIndexTuple(segment) {
    if (typeof segment == "string" && reIndexTuple.test(segment)) return !0;
    if (!Array.isArray(segment) || segment.length !== 2) return !1;
    const [from, to] = segment;
    return (typeof from == "number" || from === "") && (typeof to == "number" || to === "");
}
function get(obj, path, defaultVal) {
    const select = typeof path == "string" ? fromString(path) : path;
    if (!Array.isArray(select)) throw new Error("Path must be an array or a string");
    let acc = obj;
    for(let i = 0; i < select.length; i++){
        const segment = select[i];
        if (isIndexSegment(segment)) {
            if (!Array.isArray(acc)) return defaultVal;
            acc = acc[segment];
        }
        if (isKeySegment(segment)) {
            if (!Array.isArray(acc)) return defaultVal;
            acc = acc.find((item)=>item._key === segment._key);
        }
        if (typeof segment == "string" && (acc = typeof acc == "object" && acc !== null ? acc[segment] : void 0), typeof acc > "u") return defaultVal;
    }
    return acc;
}
function toString(path) {
    if (!Array.isArray(path)) throw new Error("Path is not an array");
    return path.reduce((target, segment, i)=>{
        const segmentType = typeof segment;
        if (segmentType === "number") return `${target}[${segment}]`;
        if (segmentType === "string") return `${target}${i === 0 ? "" : "."}${segment}`;
        if (isKeySegment(segment) && segment._key) return `${target}[_key=="${segment._key}"]`;
        if (Array.isArray(segment)) {
            const [from, to] = segment;
            return `${target}[${from}:${to}]`;
        }
        throw new Error(`Unsupported path segment \`${JSON.stringify(segment)}\``);
    }, "");
}
function fromString(path) {
    if (typeof path != "string") throw new Error("Path is not a string");
    const segments = path.match(rePropName);
    if (!segments) throw new Error("Invalid path string");
    return segments.map(parsePathSegment);
}
function parsePathSegment(segment) {
    return isIndexSegment(segment) ? parseIndexSegment(segment) : isKeySegment(segment) ? parseKeySegment(segment) : isIndexTuple(segment) ? parseIndexTupleSegment(segment) : segment;
}
function parseIndexSegment(segment) {
    return Number(segment.replace(/[^\d]/g, ""));
}
function parseKeySegment(segment) {
    return {
        _key: segment.match(reKeySegment)[1]
    };
}
function parseIndexTupleSegment(segment) {
    const [from, to] = segment.split(":").map((seg)=>seg === "" ? seg : Number(seg));
    return [
        from,
        to
    ];
}
var studioPath = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    fromString,
    get,
    isIndexSegment,
    isIndexTuple,
    isKeySegment,
    reKeySegment,
    toString
});
const DRAFTS_FOLDER = "drafts", VERSION_FOLDER = "versions", PATH_SEPARATOR = ".", DRAFTS_PREFIX = `${DRAFTS_FOLDER}${PATH_SEPARATOR}`, VERSION_PREFIX = `${VERSION_FOLDER}${PATH_SEPARATOR}`;
function isDraftId(id) {
    return id.startsWith(DRAFTS_PREFIX);
}
function isVersionId(id) {
    return id.startsWith(VERSION_PREFIX);
}
function isPublishedId(id) {
    return !isDraftId(id) && !isVersionId(id);
}
function getDraftId(id) {
    if (isVersionId(id)) {
        const publishedId = getPublishedId(id);
        return DRAFTS_PREFIX + publishedId;
    }
    return isDraftId(id) ? id : DRAFTS_PREFIX + id;
}
function getVersionId(id, version) {
    if (version === "drafts" || version === "published") throw new Error('Version can not be "published" or "drafts"');
    return `${VERSION_PREFIX}${version}${PATH_SEPARATOR}${getPublishedId(id)}`;
}
function getVersionFromId(id) {
    if (!isVersionId(id)) return;
    const [_versionPrefix, versionId, ..._publishedId] = id.split(PATH_SEPARATOR);
    return versionId;
}
function getPublishedId(id) {
    return isVersionId(id) ? id.split(PATH_SEPARATOR).slice(2).join(PATH_SEPARATOR) : isDraftId(id) ? id.slice(DRAFTS_PREFIX.length) : id;
}
const ESCAPE = {
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t",
    "'": "\\'",
    "\\": "\\\\"
}, UNESCAPE = {
    "\\f": "\f",
    "\\n": `
`,
    "\\r": "\r",
    "\\t": "	",
    "\\'": "'",
    "\\\\": "\\"
};
function jsonPath(path) {
    return `$${path.map((segment)=>typeof segment == "string" ? `['${segment.replace(/[\f\n\r\t'\\]/g, (match)=>ESCAPE[match])}']` : typeof segment == "number" ? `[${segment}]` : segment._key !== "" ? `[?(@._key=='${segment._key.replace(/['\\]/g, (match)=>ESCAPE[match])}')]` : `[${segment._index}]`).join("")}`;
}
function parseJsonPath(path) {
    const parsed = [], parseRe = /\['(.*?)'\]|\[(\d+)\]|\[\?\(@\._key=='(.*?)'\)\]/g;
    let match;
    for(; (match = parseRe.exec(path)) !== null;){
        if (match[1] !== void 0) {
            const key = match[1].replace(/\\(\\|f|n|r|t|')/g, (m)=>UNESCAPE[m]);
            parsed.push(key);
            continue;
        }
        if (match[2] !== void 0) {
            parsed.push(parseInt(match[2], 10));
            continue;
        }
        if (match[3] !== void 0) {
            const _key = match[3].replace(/\\(\\')/g, (m)=>UNESCAPE[m]);
            parsed.push({
                _key,
                _index: -1
            });
            continue;
        }
    }
    return parsed;
}
function jsonPathToStudioPath(path) {
    return path.map((segment)=>{
        if (typeof segment == "string" || typeof segment == "number") return segment;
        if (segment._key !== "") return {
            _key: segment._key
        };
        if (segment._index !== -1) return segment._index;
        throw new Error(`invalid segment:${JSON.stringify(segment)}`);
    });
}
function studioPathToJsonPath(path) {
    return (typeof path == "string" ? fromString(path) : path).map((segment)=>{
        if (typeof segment == "string" || typeof segment == "number") return segment;
        if (Array.isArray(segment)) throw new Error(`IndexTuple segments aren't supported:${JSON.stringify(segment)}`);
        if (isContentSourceMapParsedPathKeyedSegment(segment)) return segment;
        if (segment._key) return {
            _key: segment._key,
            _index: -1
        };
        throw new Error(`invalid segment:${JSON.stringify(segment)}`);
    });
}
function isContentSourceMapParsedPathKeyedSegment(segment) {
    return typeof segment == "object" && "_key" in segment && "_index" in segment;
}
function jsonPathToMappingPath(path) {
    return path.map((segment)=>{
        if (typeof segment == "string" || typeof segment == "number") return segment;
        if (segment._index !== -1) return segment._index;
        throw new Error(`invalid segment:${JSON.stringify(segment)}`);
    });
}
function resolveMapping(resultPath, csm) {
    if (!csm?.mappings) return;
    const resultMappingPath = jsonPath(jsonPathToMappingPath(resultPath));
    if (csm.mappings[resultMappingPath] !== void 0) return {
        mapping: csm.mappings[resultMappingPath],
        matchedPath: resultMappingPath,
        pathSuffix: ""
    };
    const mappings = Object.entries(csm.mappings).filter(([key])=>resultMappingPath.startsWith(key)).sort(([key1], [key2])=>key2.length - key1.length);
    if (mappings.length == 0) return;
    const [matchedPath, mapping] = mappings[0], pathSuffix = resultMappingPath.substring(matchedPath.length);
    return {
        mapping,
        matchedPath,
        pathSuffix
    };
}
function isArray(value) {
    return value !== null && Array.isArray(value);
}
function isRecord(value) {
    return typeof value == "object" && value !== null;
}
function walkMap(value, mappingFn, path = []) {
    if (isArray(value)) return value.map((v, idx)=>{
        if (isRecord(v)) {
            const _key = v._key;
            if (typeof _key == "string") return walkMap(v, mappingFn, path.concat({
                _key,
                _index: idx
            }));
        }
        return walkMap(v, mappingFn, path.concat(idx));
    });
    if (isRecord(value)) {
        if (value._type === "block" || value._type === "span") {
            const result = {
                ...value
            };
            return value._type === "block" ? result.children = walkMap(value.children, mappingFn, path.concat("children")) : value._type === "span" && (result.text = walkMap(value.text, mappingFn, path.concat("text"))), result;
        }
        return Object.fromEntries(Object.entries(value).map(([k, v])=>[
                k,
                walkMap(v, mappingFn, path.concat(k))
            ]));
    }
    return mappingFn(value, path);
}
function createEditUrl(options) {
    const { baseUrl, workspace: _workspace = "default", tool: _tool = "default", id: _id, type, path, projectId, dataset } = options;
    if (!baseUrl) throw new Error("baseUrl is required");
    if (!path) throw new Error("path is required");
    if (!_id) throw new Error("id is required");
    if (baseUrl !== "/" && baseUrl.endsWith("/")) throw new Error("baseUrl must not end with a slash");
    const workspace = _workspace === "default" ? void 0 : _workspace, tool = _tool === "default" ? void 0 : _tool, id = getPublishedId(_id), stringifiedPath = Array.isArray(path) ? toString(jsonPathToStudioPath(path)) : path, searchParams = new URLSearchParams({
        baseUrl,
        id,
        type,
        path: stringifiedPath
    });
    if (workspace && searchParams.set("workspace", workspace), tool && searchParams.set("tool", tool), projectId && searchParams.set("projectId", projectId), dataset && searchParams.set("dataset", dataset), isPublishedId(_id)) searchParams.set("perspective", "published");
    else if (isVersionId(_id)) {
        const versionId = getVersionFromId(_id);
        searchParams.set("perspective", versionId);
    }
    const segments = [
        baseUrl === "/" ? "" : baseUrl
    ];
    workspace && segments.push(workspace);
    const routerParams = [
        "mode=presentation",
        `id=${id}`,
        `type=${type}`,
        `path=${encodeURIComponent(stringifiedPath)}`
    ];
    return tool && routerParams.push(`tool=${tool}`), segments.push("intent", "edit", `${routerParams.join(";")}?${searchParams}`), segments.join("/");
}
function resolveEditInfo(options) {
    const { resultSourceMap: csm, resultPath } = options, { mapping, pathSuffix } = resolveMapping(resultPath, csm) || {};
    if (!mapping || mapping.source.type === "literal" || mapping.source.type === "unknown") return;
    const sourceDoc = csm.documents[mapping.source.document], sourcePath = csm.paths[mapping.source.path];
    if (sourceDoc && sourcePath) {
        const { baseUrl, workspace, tool } = resolveStudioBaseRoute(typeof options.studioUrl == "function" ? options.studioUrl(sourceDoc) : options.studioUrl);
        if (!baseUrl) return;
        const { _id, _type, _projectId, _dataset } = sourceDoc;
        return {
            baseUrl,
            workspace,
            tool,
            id: _id,
            type: _type,
            path: parseJsonPath(sourcePath + pathSuffix),
            projectId: _projectId,
            dataset: _dataset
        };
    }
}
function resolveStudioBaseRoute(studioUrl) {
    let baseUrl = typeof studioUrl == "string" ? studioUrl : studioUrl.baseUrl;
    return baseUrl !== "/" && (baseUrl = baseUrl.replace(/\/$/, "")), typeof studioUrl == "string" ? {
        baseUrl
    } : {
        ...studioUrl,
        baseUrl
    };
}
;
 //# sourceMappingURL=resolveEditInfo.js.map
}}),
"[project]/node_modules/valibot/dist/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// src/storages/globalConfig/globalConfig.ts
__turbopack_context__.s({
    "BASE64_REGEX": (()=>BASE64_REGEX),
    "BIC_REGEX": (()=>BIC_REGEX),
    "CUID2_REGEX": (()=>CUID2_REGEX),
    "DECIMAL_REGEX": (()=>DECIMAL_REGEX),
    "DIGITS_REGEX": (()=>DIGITS_REGEX),
    "EMAIL_REGEX": (()=>EMAIL_REGEX),
    "EMOJI_REGEX": (()=>EMOJI_REGEX),
    "HEXADECIMAL_REGEX": (()=>HEXADECIMAL_REGEX),
    "HEX_COLOR_REGEX": (()=>HEX_COLOR_REGEX),
    "IMEI_REGEX": (()=>IMEI_REGEX),
    "IPV4_REGEX": (()=>IPV4_REGEX),
    "IPV6_REGEX": (()=>IPV6_REGEX),
    "IP_REGEX": (()=>IP_REGEX),
    "ISO_DATE_REGEX": (()=>ISO_DATE_REGEX),
    "ISO_DATE_TIME_REGEX": (()=>ISO_DATE_TIME_REGEX),
    "ISO_TIMESTAMP_REGEX": (()=>ISO_TIMESTAMP_REGEX),
    "ISO_TIME_REGEX": (()=>ISO_TIME_REGEX),
    "ISO_TIME_SECOND_REGEX": (()=>ISO_TIME_SECOND_REGEX),
    "ISO_WEEK_REGEX": (()=>ISO_WEEK_REGEX),
    "MAC48_REGEX": (()=>MAC48_REGEX),
    "MAC64_REGEX": (()=>MAC64_REGEX),
    "MAC_REGEX": (()=>MAC_REGEX),
    "NANO_ID_REGEX": (()=>NANO_ID_REGEX),
    "OCTAL_REGEX": (()=>OCTAL_REGEX),
    "RFC_EMAIL_REGEX": (()=>RFC_EMAIL_REGEX),
    "SLUG_REGEX": (()=>SLUG_REGEX),
    "ULID_REGEX": (()=>ULID_REGEX),
    "UUID_REGEX": (()=>UUID_REGEX),
    "ValiError": (()=>ValiError),
    "_addIssue": (()=>_addIssue),
    "_getByteCount": (()=>_getByteCount),
    "_getGraphemeCount": (()=>_getGraphemeCount),
    "_getStandardProps": (()=>_getStandardProps),
    "_getWordCount": (()=>_getWordCount),
    "_isLuhnAlgo": (()=>_isLuhnAlgo),
    "_isValidObjectKey": (()=>_isValidObjectKey),
    "_joinExpects": (()=>_joinExpects),
    "_stringify": (()=>_stringify),
    "any": (()=>any),
    "args": (()=>args),
    "argsAsync": (()=>argsAsync),
    "array": (()=>array),
    "arrayAsync": (()=>arrayAsync),
    "assert": (()=>assert),
    "awaitAsync": (()=>awaitAsync),
    "base64": (()=>base64),
    "bic": (()=>bic),
    "bigint": (()=>bigint),
    "blob": (()=>blob),
    "boolean": (()=>boolean),
    "brand": (()=>brand),
    "bytes": (()=>bytes),
    "check": (()=>check),
    "checkAsync": (()=>checkAsync),
    "checkItems": (()=>checkItems),
    "checkItemsAsync": (()=>checkItemsAsync),
    "config": (()=>config),
    "creditCard": (()=>creditCard),
    "cuid2": (()=>cuid2),
    "custom": (()=>custom),
    "customAsync": (()=>customAsync),
    "date": (()=>date),
    "decimal": (()=>decimal),
    "deleteGlobalConfig": (()=>deleteGlobalConfig),
    "deleteGlobalMessage": (()=>deleteGlobalMessage),
    "deleteSchemaMessage": (()=>deleteSchemaMessage),
    "deleteSpecificMessage": (()=>deleteSpecificMessage),
    "description": (()=>description),
    "digits": (()=>digits),
    "email": (()=>email),
    "emoji": (()=>emoji),
    "empty": (()=>empty),
    "endsWith": (()=>endsWith),
    "entriesFromList": (()=>entriesFromList),
    "entriesFromObjects": (()=>entriesFromObjects),
    "enum": (()=>enum_),
    "enum_": (()=>enum_),
    "everyItem": (()=>everyItem),
    "exactOptional": (()=>exactOptional),
    "exactOptionalAsync": (()=>exactOptionalAsync),
    "excludes": (()=>excludes),
    "fallback": (()=>fallback),
    "fallbackAsync": (()=>fallbackAsync),
    "file": (()=>file),
    "filterItems": (()=>filterItems),
    "findItem": (()=>findItem),
    "finite": (()=>finite),
    "flatten": (()=>flatten),
    "forward": (()=>forward),
    "forwardAsync": (()=>forwardAsync),
    "function": (()=>function_),
    "function_": (()=>function_),
    "getDefault": (()=>getDefault),
    "getDefaults": (()=>getDefaults),
    "getDefaultsAsync": (()=>getDefaultsAsync),
    "getDotPath": (()=>getDotPath),
    "getFallback": (()=>getFallback),
    "getFallbacks": (()=>getFallbacks),
    "getFallbacksAsync": (()=>getFallbacksAsync),
    "getGlobalConfig": (()=>getGlobalConfig),
    "getGlobalMessage": (()=>getGlobalMessage),
    "getSchemaMessage": (()=>getSchemaMessage),
    "getSpecificMessage": (()=>getSpecificMessage),
    "graphemes": (()=>graphemes),
    "gtValue": (()=>gtValue),
    "hash": (()=>hash),
    "hexColor": (()=>hexColor),
    "hexadecimal": (()=>hexadecimal),
    "imei": (()=>imei),
    "includes": (()=>includes),
    "instance": (()=>instance),
    "integer": (()=>integer),
    "intersect": (()=>intersect),
    "intersectAsync": (()=>intersectAsync),
    "ip": (()=>ip),
    "ipv4": (()=>ipv4),
    "ipv6": (()=>ipv6),
    "is": (()=>is),
    "isOfKind": (()=>isOfKind),
    "isOfType": (()=>isOfType),
    "isValiError": (()=>isValiError),
    "isoDate": (()=>isoDate),
    "isoDateTime": (()=>isoDateTime),
    "isoTime": (()=>isoTime),
    "isoTimeSecond": (()=>isoTimeSecond),
    "isoTimestamp": (()=>isoTimestamp),
    "isoWeek": (()=>isoWeek),
    "keyof": (()=>keyof),
    "lazy": (()=>lazy),
    "lazyAsync": (()=>lazyAsync),
    "length": (()=>length),
    "literal": (()=>literal),
    "looseObject": (()=>looseObject),
    "looseObjectAsync": (()=>looseObjectAsync),
    "looseTuple": (()=>looseTuple),
    "looseTupleAsync": (()=>looseTupleAsync),
    "ltValue": (()=>ltValue),
    "mac": (()=>mac),
    "mac48": (()=>mac48),
    "mac64": (()=>mac64),
    "map": (()=>map),
    "mapAsync": (()=>mapAsync),
    "mapItems": (()=>mapItems),
    "maxBytes": (()=>maxBytes),
    "maxGraphemes": (()=>maxGraphemes),
    "maxLength": (()=>maxLength),
    "maxSize": (()=>maxSize),
    "maxValue": (()=>maxValue),
    "maxWords": (()=>maxWords),
    "metadata": (()=>metadata),
    "mimeType": (()=>mimeType),
    "minBytes": (()=>minBytes),
    "minGraphemes": (()=>minGraphemes),
    "minLength": (()=>minLength),
    "minSize": (()=>minSize),
    "minValue": (()=>minValue),
    "minWords": (()=>minWords),
    "multipleOf": (()=>multipleOf),
    "nan": (()=>nan),
    "nanoid": (()=>nanoid),
    "never": (()=>never),
    "nonEmpty": (()=>nonEmpty),
    "nonNullable": (()=>nonNullable),
    "nonNullableAsync": (()=>nonNullableAsync),
    "nonNullish": (()=>nonNullish),
    "nonNullishAsync": (()=>nonNullishAsync),
    "nonOptional": (()=>nonOptional),
    "nonOptionalAsync": (()=>nonOptionalAsync),
    "normalize": (()=>normalize),
    "notBytes": (()=>notBytes),
    "notGraphemes": (()=>notGraphemes),
    "notLength": (()=>notLength),
    "notSize": (()=>notSize),
    "notValue": (()=>notValue),
    "notValues": (()=>notValues),
    "notWords": (()=>notWords),
    "null": (()=>null_),
    "null_": (()=>null_),
    "nullable": (()=>nullable),
    "nullableAsync": (()=>nullableAsync),
    "nullish": (()=>nullish),
    "nullishAsync": (()=>nullishAsync),
    "number": (()=>number),
    "object": (()=>object),
    "objectAsync": (()=>objectAsync),
    "objectWithRest": (()=>objectWithRest),
    "objectWithRestAsync": (()=>objectWithRestAsync),
    "octal": (()=>octal),
    "omit": (()=>omit),
    "optional": (()=>optional),
    "optionalAsync": (()=>optionalAsync),
    "parse": (()=>parse),
    "parseAsync": (()=>parseAsync),
    "parser": (()=>parser),
    "parserAsync": (()=>parserAsync),
    "partial": (()=>partial),
    "partialAsync": (()=>partialAsync),
    "partialCheck": (()=>partialCheck),
    "partialCheckAsync": (()=>partialCheckAsync),
    "pick": (()=>pick),
    "picklist": (()=>picklist),
    "pipe": (()=>pipe),
    "pipeAsync": (()=>pipeAsync),
    "promise": (()=>promise),
    "rawCheck": (()=>rawCheck),
    "rawCheckAsync": (()=>rawCheckAsync),
    "rawTransform": (()=>rawTransform),
    "rawTransformAsync": (()=>rawTransformAsync),
    "readonly": (()=>readonly),
    "record": (()=>record),
    "recordAsync": (()=>recordAsync),
    "reduceItems": (()=>reduceItems),
    "regex": (()=>regex),
    "required": (()=>required),
    "requiredAsync": (()=>requiredAsync),
    "returns": (()=>returns),
    "returnsAsync": (()=>returnsAsync),
    "rfcEmail": (()=>rfcEmail),
    "safeInteger": (()=>safeInteger),
    "safeParse": (()=>safeParse),
    "safeParseAsync": (()=>safeParseAsync),
    "safeParser": (()=>safeParser),
    "safeParserAsync": (()=>safeParserAsync),
    "set": (()=>set),
    "setAsync": (()=>setAsync),
    "setGlobalConfig": (()=>setGlobalConfig),
    "setGlobalMessage": (()=>setGlobalMessage),
    "setSchemaMessage": (()=>setSchemaMessage),
    "setSpecificMessage": (()=>setSpecificMessage),
    "size": (()=>size),
    "slug": (()=>slug),
    "someItem": (()=>someItem),
    "sortItems": (()=>sortItems),
    "startsWith": (()=>startsWith),
    "strictObject": (()=>strictObject),
    "strictObjectAsync": (()=>strictObjectAsync),
    "strictTuple": (()=>strictTuple),
    "strictTupleAsync": (()=>strictTupleAsync),
    "string": (()=>string),
    "symbol": (()=>symbol),
    "title": (()=>title),
    "toLowerCase": (()=>toLowerCase),
    "toMaxValue": (()=>toMaxValue),
    "toMinValue": (()=>toMinValue),
    "toUpperCase": (()=>toUpperCase),
    "transform": (()=>transform),
    "transformAsync": (()=>transformAsync),
    "trim": (()=>trim),
    "trimEnd": (()=>trimEnd),
    "trimStart": (()=>trimStart),
    "tuple": (()=>tuple),
    "tupleAsync": (()=>tupleAsync),
    "tupleWithRest": (()=>tupleWithRest),
    "tupleWithRestAsync": (()=>tupleWithRestAsync),
    "ulid": (()=>ulid),
    "undefined": (()=>undefined_),
    "undefined_": (()=>undefined_),
    "undefinedable": (()=>undefinedable),
    "undefinedableAsync": (()=>undefinedableAsync),
    "union": (()=>union),
    "unionAsync": (()=>unionAsync),
    "unknown": (()=>unknown),
    "unwrap": (()=>unwrap),
    "url": (()=>url),
    "uuid": (()=>uuid),
    "value": (()=>value),
    "values": (()=>values),
    "variant": (()=>variant),
    "variantAsync": (()=>variantAsync),
    "void": (()=>void_),
    "void_": (()=>void_),
    "words": (()=>words)
});
var store;
function setGlobalConfig(config2) {
    store = {
        ...store,
        ...config2
    };
}
// @__NO_SIDE_EFFECTS__
function getGlobalConfig(config2) {
    return {
        lang: config2?.lang ?? store?.lang,
        message: config2?.message,
        abortEarly: config2?.abortEarly ?? store?.abortEarly,
        abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly
    };
}
function deleteGlobalConfig() {
    store = void 0;
}
// src/storages/globalMessage/globalMessage.ts
var store2;
function setGlobalMessage(message, lang) {
    if (!store2) store2 = /* @__PURE__ */ new Map();
    store2.set(lang, message);
}
// @__NO_SIDE_EFFECTS__
function getGlobalMessage(lang) {
    return store2?.get(lang);
}
function deleteGlobalMessage(lang) {
    store2?.delete(lang);
}
// src/storages/schemaMessage/schemaMessage.ts
var store3;
function setSchemaMessage(message, lang) {
    if (!store3) store3 = /* @__PURE__ */ new Map();
    store3.set(lang, message);
}
// @__NO_SIDE_EFFECTS__
function getSchemaMessage(lang) {
    return store3?.get(lang);
}
function deleteSchemaMessage(lang) {
    store3?.delete(lang);
}
// src/storages/specificMessage/specificMessage.ts
var store4;
function setSpecificMessage(reference, message, lang) {
    if (!store4) store4 = /* @__PURE__ */ new Map();
    if (!store4.get(reference)) store4.set(reference, /* @__PURE__ */ new Map());
    store4.get(reference).set(lang, message);
}
// @__NO_SIDE_EFFECTS__
function getSpecificMessage(reference, lang) {
    return store4?.get(reference)?.get(lang);
}
function deleteSpecificMessage(reference, lang) {
    store4?.get(reference)?.delete(lang);
}
// src/utils/_stringify/_stringify.ts
// @__NO_SIDE_EFFECTS__
function _stringify(input) {
    const type = typeof input;
    if (type === "string") {
        return `"${input}"`;
    }
    if (type === "number" || type === "bigint" || type === "boolean") {
        return `${input}`;
    }
    if (type === "object" || type === "function") {
        return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? "null";
    }
    return type;
}
// src/utils/_addIssue/_addIssue.ts
function _addIssue(context, label, dataset, config2, other) {
    const input = other && "input" in other ? other.input : dataset.value;
    const expected = other?.expected ?? context.expects ?? null;
    const received = other?.received ?? _stringify(input);
    const issue = {
        kind: context.kind,
        type: context.type,
        input,
        expected,
        received,
        message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : "R"}eceived ${received}`,
        requirement: context.requirement,
        path: other?.path,
        issues: other?.issues,
        lang: config2.lang,
        abortEarly: config2.abortEarly,
        abortPipeEarly: config2.abortPipeEarly
    };
    const isSchema = context.kind === "schema";
    const message = other?.message ?? context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang);
    if (message !== void 0) {
        issue.message = typeof message === "function" ? // @ts-expect-error
        message(issue) : message;
    }
    if (isSchema) {
        dataset.typed = false;
    }
    if (dataset.issues) {
        dataset.issues.push(issue);
    } else {
        dataset.issues = [
            issue
        ];
    }
}
// src/utils/_getByteCount/_getByteCount.ts
var textEncoder;
// @__NO_SIDE_EFFECTS__
function _getByteCount(input) {
    if (!textEncoder) {
        textEncoder = new TextEncoder();
    }
    return textEncoder.encode(input).length;
}
// src/utils/_getGraphemeCount/_getGraphemeCount.ts
var segmenter;
// @__NO_SIDE_EFFECTS__
function _getGraphemeCount(input) {
    if (!segmenter) {
        segmenter = new Intl.Segmenter();
    }
    const segments = segmenter.segment(input);
    let count = 0;
    for (const _ of segments){
        count++;
    }
    return count;
}
// src/utils/_getStandardProps/_getStandardProps.ts
// @__NO_SIDE_EFFECTS__
function _getStandardProps(context) {
    return {
        version: 1,
        vendor: "valibot",
        validate (value2) {
            return context["~run"]({
                value: value2
            }, getGlobalConfig());
        }
    };
}
// src/utils/_getWordCount/_getWordCount.ts
var store5;
// @__NO_SIDE_EFFECTS__
function _getWordCount(locales, input) {
    if (!store5) {
        store5 = /* @__PURE__ */ new Map();
    }
    if (!store5.get(locales)) {
        store5.set(locales, new Intl.Segmenter(locales, {
            granularity: "word"
        }));
    }
    const segments = store5.get(locales).segment(input);
    let count = 0;
    for (const segment of segments){
        if (segment.isWordLike) {
            count++;
        }
    }
    return count;
}
// src/utils/_isLuhnAlgo/_isLuhnAlgo.ts
var NON_DIGIT_REGEX = /\D/gu;
// @__NO_SIDE_EFFECTS__
function _isLuhnAlgo(input) {
    const number2 = input.replace(NON_DIGIT_REGEX, "");
    let length2 = number2.length;
    let bit = 1;
    let sum = 0;
    while(length2){
        const value2 = +number2[--length2];
        bit ^= 1;
        sum += bit ? [
            0,
            2,
            4,
            6,
            8,
            1,
            3,
            5,
            7,
            9
        ][value2] : value2;
    }
    return sum % 10 === 0;
}
// src/utils/_isValidObjectKey/_isValidObjectKey.ts
// @__NO_SIDE_EFFECTS__
function _isValidObjectKey(object2, key) {
    return Object.hasOwn(object2, key) && key !== "__proto__" && key !== "prototype" && key !== "constructor";
}
// src/utils/_joinExpects/_joinExpects.ts
// @__NO_SIDE_EFFECTS__
function _joinExpects(values2, separator) {
    const list = [
        ...new Set(values2)
    ];
    if (list.length > 1) {
        return `(${list.join(` ${separator} `)})`;
    }
    return list[0] ?? "never";
}
// src/utils/entriesFromList/entriesFromList.ts
// @__NO_SIDE_EFFECTS__
function entriesFromList(list, schema) {
    const entries = {};
    for (const key of list){
        entries[key] = schema;
    }
    return entries;
}
// src/utils/entriesFromObjects/entriesFromObjects.ts
// @__NO_SIDE_EFFECTS__
function entriesFromObjects(schemas) {
    const entries = {};
    for (const schema of schemas){
        Object.assign(entries, schema.entries);
    }
    return entries;
}
// src/utils/getDotPath/getDotPath.ts
// @__NO_SIDE_EFFECTS__
function getDotPath(issue) {
    if (issue.path) {
        let key = "";
        for (const item of issue.path){
            if (typeof item.key === "string" || typeof item.key === "number") {
                if (key) {
                    key += `.${item.key}`;
                } else {
                    key += item.key;
                }
            } else {
                return null;
            }
        }
        return key;
    }
    return null;
}
// src/utils/isOfKind/isOfKind.ts
// @__NO_SIDE_EFFECTS__
function isOfKind(kind, object2) {
    return object2.kind === kind;
}
// src/utils/isOfType/isOfType.ts
// @__NO_SIDE_EFFECTS__
function isOfType(type, object2) {
    return object2.type === type;
}
// src/utils/isValiError/isValiError.ts
// @__NO_SIDE_EFFECTS__
function isValiError(error) {
    return error instanceof ValiError;
}
// src/utils/ValiError/ValiError.ts
var ValiError = class extends Error {
    /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */ constructor(issues){
        super(issues[0].message);
        this.name = "ValiError";
        this.issues = issues;
    }
};
// src/actions/args/args.ts
// @__NO_SIDE_EFFECTS__
function args(schema) {
    return {
        kind: "transformation",
        type: "args",
        reference: args,
        async: false,
        schema,
        "~run" (dataset, config2) {
            const func = dataset.value;
            dataset.value = (...args_)=>{
                const argsDataset = this.schema["~run"]({
                    value: args_
                }, config2);
                if (argsDataset.issues) {
                    throw new ValiError(argsDataset.issues);
                }
                return func(...argsDataset.value);
            };
            return dataset;
        }
    };
}
// src/actions/args/argsAsync.ts
// @__NO_SIDE_EFFECTS__
function argsAsync(schema) {
    return {
        kind: "transformation",
        type: "args",
        reference: argsAsync,
        async: false,
        schema,
        "~run" (dataset, config2) {
            const func = dataset.value;
            dataset.value = async (...args2)=>{
                const argsDataset = await schema["~run"]({
                    value: args2
                }, config2);
                if (argsDataset.issues) {
                    throw new ValiError(argsDataset.issues);
                }
                return func(...argsDataset.value);
            };
            return dataset;
        }
    };
}
// src/actions/await/awaitAsync.ts
// @__NO_SIDE_EFFECTS__
function awaitAsync() {
    return {
        kind: "transformation",
        type: "await",
        reference: awaitAsync,
        async: true,
        async "~run" (dataset) {
            dataset.value = await dataset.value;
            return dataset;
        }
    };
}
// src/regex.ts
var BASE64_REGEX = /^(?:[\da-z+/]{4})*(?:[\da-z+/]{2}==|[\da-z+/]{3}=)?$/iu;
var BIC_REGEX = /^[A-Z]{6}(?!00)[\dA-Z]{2}(?:[\dA-Z]{3})?$/u;
var CUID2_REGEX = /^[a-z][\da-z]*$/u;
var DECIMAL_REGEX = /^[+-]?(?:\d*\.)?\d+$/u;
var DIGITS_REGEX = /^\d+$/u;
var EMAIL_REGEX = /^[\w+-]+(?:\.[\w+-]+)*@[\da-z]+(?:[.-][\da-z]+)*\.[a-z]{2,}$/iu;
var EMOJI_REGEX = // eslint-disable-next-line redos-detector/no-unsafe-regex, regexp/no-dupe-disjunctions -- false positives
/^(?:[\u{1F1E6}-\u{1F1FF}]{2}|\u{1F3F4}[\u{E0061}-\u{E007A}]{2}[\u{E0030}-\u{E0039}\u{E0061}-\u{E007A}]{1,3}\u{E007F}|(?:\p{Emoji}\uFE0F\u20E3?|\p{Emoji_Modifier_Base}\p{Emoji_Modifier}?|\p{Emoji_Presentation})(?:\u200D(?:\p{Emoji}\uFE0F\u20E3?|\p{Emoji_Modifier_Base}\p{Emoji_Modifier}?|\p{Emoji_Presentation}))*)+$/u;
var HEXADECIMAL_REGEX = /^(?:0[hx])?[\da-fA-F]+$/u;
var HEX_COLOR_REGEX = /^#(?:[\da-fA-F]{3,4}|[\da-fA-F]{6}|[\da-fA-F]{8})$/u;
var IMEI_REGEX = /^\d{15}$|^\d{2}-\d{6}-\d{6}-\d$/u;
var IPV4_REGEX = // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive
/^(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])(?:\.(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])){3}$/u;
var IPV6_REGEX = /^(?:(?:[\da-f]{1,4}:){7}[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,7}:|(?:[\da-f]{1,4}:){1,6}:[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,5}(?::[\da-f]{1,4}){1,2}|(?:[\da-f]{1,4}:){1,4}(?::[\da-f]{1,4}){1,3}|(?:[\da-f]{1,4}:){1,3}(?::[\da-f]{1,4}){1,4}|(?:[\da-f]{1,4}:){1,2}(?::[\da-f]{1,4}){1,5}|[\da-f]{1,4}:(?::[\da-f]{1,4}){1,6}|:(?:(?::[\da-f]{1,4}){1,7}|:)|fe80:(?::[\da-f]{0,4}){0,4}%[\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d)|(?:[\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d))$/iu;
var IP_REGEX = /^(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])(?:\.(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])){3}$|^(?:(?:[\da-f]{1,4}:){7}[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,7}:|(?:[\da-f]{1,4}:){1,6}:[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,5}(?::[\da-f]{1,4}){1,2}|(?:[\da-f]{1,4}:){1,4}(?::[\da-f]{1,4}){1,3}|(?:[\da-f]{1,4}:){1,3}(?::[\da-f]{1,4}){1,4}|(?:[\da-f]{1,4}:){1,2}(?::[\da-f]{1,4}){1,5}|[\da-f]{1,4}:(?::[\da-f]{1,4}){1,6}|:(?:(?::[\da-f]{1,4}){1,7}|:)|fe80:(?::[\da-f]{0,4}){0,4}%[\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d)|(?:[\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d))$/iu;
var ISO_DATE_REGEX = /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])$/u;
var ISO_DATE_TIME_REGEX = /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])[T ](?:0\d|1\d|2[0-3]):[0-5]\d$/u;
var ISO_TIME_REGEX = /^(?:0\d|1\d|2[0-3]):[0-5]\d$/u;
var ISO_TIME_SECOND_REGEX = /^(?:0\d|1\d|2[0-3])(?::[0-5]\d){2}$/u;
var ISO_TIMESTAMP_REGEX = /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])[T ](?:0\d|1\d|2[0-3])(?::[0-5]\d){2}(?:\.\d{1,9})?(?:Z|[+-](?:0\d|1\d|2[0-3])(?::?[0-5]\d)?)$/u;
var ISO_WEEK_REGEX = /^\d{4}-W(?:0[1-9]|[1-4]\d|5[0-3])$/u;
var MAC48_REGEX = /^(?:[\da-f]{2}:){5}[\da-f]{2}$|^(?:[\da-f]{2}-){5}[\da-f]{2}$|^(?:[\da-f]{4}\.){2}[\da-f]{4}$/iu;
var MAC64_REGEX = /^(?:[\da-f]{2}:){7}[\da-f]{2}$|^(?:[\da-f]{2}-){7}[\da-f]{2}$|^(?:[\da-f]{4}\.){3}[\da-f]{4}$|^(?:[\da-f]{4}:){3}[\da-f]{4}$/iu;
var MAC_REGEX = /^(?:[\da-f]{2}:){5}[\da-f]{2}$|^(?:[\da-f]{2}-){5}[\da-f]{2}$|^(?:[\da-f]{4}\.){2}[\da-f]{4}$|^(?:[\da-f]{2}:){7}[\da-f]{2}$|^(?:[\da-f]{2}-){7}[\da-f]{2}$|^(?:[\da-f]{4}\.){3}[\da-f]{4}$|^(?:[\da-f]{4}:){3}[\da-f]{4}$/iu;
var NANO_ID_REGEX = /^[\w-]+$/u;
var OCTAL_REGEX = /^(?:0o)?[0-7]+$/u;
var RFC_EMAIL_REGEX = // eslint-disable-next-line regexp/prefer-w, no-useless-escape, regexp/no-useless-escape, regexp/require-unicode-regexp
/^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var SLUG_REGEX = /^[\da-z]+(?:[-_][\da-z]+)*$/u;
var ULID_REGEX = /^[\da-hjkmnp-tv-zA-HJKMNP-TV-Z]{26}$/u;
var UUID_REGEX = /^[\da-f]{8}(?:-[\da-f]{4}){3}-[\da-f]{12}$/iu;
// src/actions/base64/base64.ts
// @__NO_SIDE_EFFECTS__
function base64(message) {
    return {
        kind: "validation",
        type: "base64",
        reference: base64,
        async: false,
        expects: null,
        requirement: BASE64_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "Base64", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/bic/bic.ts
// @__NO_SIDE_EFFECTS__
function bic(message) {
    return {
        kind: "validation",
        type: "bic",
        reference: bic,
        async: false,
        expects: null,
        requirement: BIC_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "BIC", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/brand/brand.ts
// @__NO_SIDE_EFFECTS__
function brand(name) {
    return {
        kind: "transformation",
        type: "brand",
        reference: brand,
        async: false,
        name,
        "~run" (dataset) {
            return dataset;
        }
    };
}
// src/actions/bytes/bytes.ts
// @__NO_SIDE_EFFECTS__
function bytes(requirement, message) {
    return {
        kind: "validation",
        type: "bytes",
        reference: bytes,
        async: false,
        expects: `${requirement}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed) {
                const length2 = _getByteCount(dataset.value);
                if (length2 !== this.requirement) {
                    _addIssue(this, "bytes", dataset, config2, {
                        received: `${length2}`
                    });
                }
            }
            return dataset;
        }
    };
}
// src/actions/check/check.ts
// @__NO_SIDE_EFFECTS__
function check(requirement, message) {
    return {
        kind: "validation",
        type: "check",
        reference: check,
        async: false,
        expects: null,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement(dataset.value)) {
                _addIssue(this, "input", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/check/checkAsync.ts
// @__NO_SIDE_EFFECTS__
function checkAsync(requirement, message) {
    return {
        kind: "validation",
        type: "check",
        reference: checkAsync,
        async: true,
        expects: null,
        requirement,
        message,
        async "~run" (dataset, config2) {
            if (dataset.typed && !await this.requirement(dataset.value)) {
                _addIssue(this, "input", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/checkItems/checkItems.ts
// @__NO_SIDE_EFFECTS__
function checkItems(requirement, message) {
    return {
        kind: "validation",
        type: "check_items",
        reference: checkItems,
        async: false,
        expects: null,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed) {
                for(let index = 0; index < dataset.value.length; index++){
                    const item = dataset.value[index];
                    if (!this.requirement(item, index, dataset.value)) {
                        _addIssue(this, "item", dataset, config2, {
                            input: item,
                            path: [
                                {
                                    type: "array",
                                    origin: "value",
                                    input: dataset.value,
                                    key: index,
                                    value: item
                                }
                            ]
                        });
                    }
                }
            }
            return dataset;
        }
    };
}
// src/actions/checkItems/checkItemsAsync.ts
// @__NO_SIDE_EFFECTS__
function checkItemsAsync(requirement, message) {
    return {
        kind: "validation",
        type: "check_items",
        reference: checkItemsAsync,
        async: true,
        expects: null,
        requirement,
        message,
        async "~run" (dataset, config2) {
            if (dataset.typed) {
                const requirementResults = await Promise.all(dataset.value.map(this.requirement));
                for(let index = 0; index < dataset.value.length; index++){
                    if (!requirementResults[index]) {
                        const item = dataset.value[index];
                        _addIssue(this, "item", dataset, config2, {
                            input: item,
                            path: [
                                {
                                    type: "array",
                                    origin: "value",
                                    input: dataset.value,
                                    key: index,
                                    value: item
                                }
                            ]
                        });
                    }
                }
            }
            return dataset;
        }
    };
}
// src/actions/creditCard/creditCard.ts
var CREDIT_CARD_REGEX = /^(?:\d{14,19}|\d{4}(?: \d{3,6}){2,4}|\d{4}(?:-\d{3,6}){2,4})$/u;
var SANITIZE_REGEX = /[- ]/gu;
var PROVIDER_REGEX_LIST = [
    // American Express
    /^3[47]\d{13}$/u,
    // Diners Club
    /^3(?:0[0-5]|[68]\d)\d{11,13}$/u,
    // Discover
    /^6(?:011|5\d{2})\d{12,15}$/u,
    // JCB
    /^(?:2131|1800|35\d{3})\d{11}$/u,
    // Mastercard
    // eslint-disable-next-line redos-detector/no-unsafe-regex
    /^5[1-5]\d{2}|(?:222\d|22[3-9]\d|2[3-6]\d{2}|27[01]\d|2720)\d{12}$/u,
    // UnionPay
    /^(?:6[27]\d{14,17}|81\d{14,17})$/u,
    // Visa
    /^4\d{12}(?:\d{3,6})?$/u
];
// @__NO_SIDE_EFFECTS__
function creditCard(message) {
    return {
        kind: "validation",
        type: "credit_card",
        reference: creditCard,
        async: false,
        expects: null,
        requirement (input) {
            let sanitized;
            return CREDIT_CARD_REGEX.test(input) && // Remove any hyphens and blanks
            (sanitized = input.replace(SANITIZE_REGEX, "")) && // Check if it matches a provider
            PROVIDER_REGEX_LIST.some((regex2)=>regex2.test(sanitized)) && // Check if passes luhn algorithm
            _isLuhnAlgo(sanitized);
        },
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement(dataset.value)) {
                _addIssue(this, "credit card", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/cuid2/cuid2.ts
// @__NO_SIDE_EFFECTS__
function cuid2(message) {
    return {
        kind: "validation",
        type: "cuid2",
        reference: cuid2,
        async: false,
        expects: null,
        requirement: CUID2_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "Cuid2", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/decimal/decimal.ts
// @__NO_SIDE_EFFECTS__
function decimal(message) {
    return {
        kind: "validation",
        type: "decimal",
        reference: decimal,
        async: false,
        expects: null,
        requirement: DECIMAL_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "decimal", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/description/description.ts
// @__NO_SIDE_EFFECTS__
function description(description_) {
    return {
        kind: "metadata",
        type: "description",
        reference: description,
        description: description_
    };
}
// src/actions/digits/digits.ts
// @__NO_SIDE_EFFECTS__
function digits(message) {
    return {
        kind: "validation",
        type: "digits",
        reference: digits,
        async: false,
        expects: null,
        requirement: DIGITS_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "digits", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/email/email.ts
// @__NO_SIDE_EFFECTS__
function email(message) {
    return {
        kind: "validation",
        type: "email",
        reference: email,
        expects: null,
        async: false,
        requirement: EMAIL_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "email", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/emoji/emoji.ts
// @__NO_SIDE_EFFECTS__
function emoji(message) {
    return {
        kind: "validation",
        type: "emoji",
        reference: emoji,
        async: false,
        expects: null,
        requirement: EMOJI_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "emoji", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/empty/empty.ts
// @__NO_SIDE_EFFECTS__
function empty(message) {
    return {
        kind: "validation",
        type: "empty",
        reference: empty,
        async: false,
        expects: "0",
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && dataset.value.length > 0) {
                _addIssue(this, "length", dataset, config2, {
                    received: `${dataset.value.length}`
                });
            }
            return dataset;
        }
    };
}
// src/actions/endsWith/endsWith.ts
// @__NO_SIDE_EFFECTS__
function endsWith(requirement, message) {
    return {
        kind: "validation",
        type: "ends_with",
        reference: endsWith,
        async: false,
        expects: `"${requirement}"`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !dataset.value.endsWith(this.requirement)) {
                _addIssue(this, "end", dataset, config2, {
                    received: `"${dataset.value.slice(-this.requirement.length)}"`
                });
            }
            return dataset;
        }
    };
}
// src/actions/everyItem/everyItem.ts
// @__NO_SIDE_EFFECTS__
function everyItem(requirement, message) {
    return {
        kind: "validation",
        type: "every_item",
        reference: everyItem,
        async: false,
        expects: null,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !dataset.value.every(this.requirement)) {
                _addIssue(this, "item", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/excludes/excludes.ts
// @__NO_SIDE_EFFECTS__
function excludes(requirement, message) {
    const received = _stringify(requirement);
    return {
        kind: "validation",
        type: "excludes",
        reference: excludes,
        async: false,
        expects: `!${received}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && dataset.value.includes(this.requirement)) {
                _addIssue(this, "content", dataset, config2, {
                    received
                });
            }
            return dataset;
        }
    };
}
// src/actions/filterItems/filterItems.ts
// @__NO_SIDE_EFFECTS__
function filterItems(operation) {
    return {
        kind: "transformation",
        type: "filter_items",
        reference: filterItems,
        async: false,
        operation,
        "~run" (dataset) {
            dataset.value = dataset.value.filter(this.operation);
            return dataset;
        }
    };
}
// src/actions/findItem/findItem.ts
// @__NO_SIDE_EFFECTS__
function findItem(operation) {
    return {
        kind: "transformation",
        type: "find_item",
        reference: findItem,
        async: false,
        operation,
        "~run" (dataset) {
            dataset.value = dataset.value.find(this.operation);
            return dataset;
        }
    };
}
// src/actions/finite/finite.ts
// @__NO_SIDE_EFFECTS__
function finite(message) {
    return {
        kind: "validation",
        type: "finite",
        reference: finite,
        async: false,
        expects: null,
        requirement: Number.isFinite,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement(dataset.value)) {
                _addIssue(this, "finite", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/graphemes/graphemes.ts
// @__NO_SIDE_EFFECTS__
function graphemes(requirement, message) {
    return {
        kind: "validation",
        type: "graphemes",
        reference: graphemes,
        async: false,
        expects: `${requirement}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed) {
                const count = _getGraphemeCount(dataset.value);
                if (count !== this.requirement) {
                    _addIssue(this, "graphemes", dataset, config2, {
                        received: `${count}`
                    });
                }
            }
            return dataset;
        }
    };
}
// src/actions/gtValue/gtValue.ts
// @__NO_SIDE_EFFECTS__
function gtValue(requirement, message) {
    return {
        kind: "validation",
        type: "gt_value",
        reference: gtValue,
        async: false,
        expects: `>${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !(dataset.value > this.requirement)) {
                _addIssue(this, "value", dataset, config2, {
                    received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)
                });
            }
            return dataset;
        }
    };
}
// src/actions/hash/hash.ts
var HASH_LENGTHS = {
    md4: 32,
    md5: 32,
    sha1: 40,
    sha256: 64,
    sha384: 96,
    sha512: 128,
    ripemd128: 32,
    ripemd160: 40,
    tiger128: 32,
    tiger160: 40,
    tiger192: 48,
    crc32: 8,
    crc32b: 8,
    adler32: 8
};
// @__NO_SIDE_EFFECTS__
function hash(types, message) {
    return {
        kind: "validation",
        type: "hash",
        reference: hash,
        expects: null,
        async: false,
        requirement: RegExp(types.map((type)=>`^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join("|"), "iu"),
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "hash", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/hexadecimal/hexadecimal.ts
// @__NO_SIDE_EFFECTS__
function hexadecimal(message) {
    return {
        kind: "validation",
        type: "hexadecimal",
        reference: hexadecimal,
        async: false,
        expects: null,
        requirement: HEXADECIMAL_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "hexadecimal", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/hexColor/hexColor.ts
// @__NO_SIDE_EFFECTS__
function hexColor(message) {
    return {
        kind: "validation",
        type: "hex_color",
        reference: hexColor,
        async: false,
        expects: null,
        requirement: HEX_COLOR_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "hex color", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/imei/imei.ts
// @__NO_SIDE_EFFECTS__
function imei(message) {
    return {
        kind: "validation",
        type: "imei",
        reference: imei,
        async: false,
        expects: null,
        requirement (input) {
            return IMEI_REGEX.test(input) && _isLuhnAlgo(input);
        },
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement(dataset.value)) {
                _addIssue(this, "IMEI", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/includes/includes.ts
// @__NO_SIDE_EFFECTS__
function includes(requirement, message) {
    const expects = _stringify(requirement);
    return {
        kind: "validation",
        type: "includes",
        reference: includes,
        async: false,
        expects,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !dataset.value.includes(this.requirement)) {
                _addIssue(this, "content", dataset, config2, {
                    received: `!${expects}`
                });
            }
            return dataset;
        }
    };
}
// src/actions/integer/integer.ts
// @__NO_SIDE_EFFECTS__
function integer(message) {
    return {
        kind: "validation",
        type: "integer",
        reference: integer,
        async: false,
        expects: null,
        requirement: Number.isInteger,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement(dataset.value)) {
                _addIssue(this, "integer", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/ip/ip.ts
// @__NO_SIDE_EFFECTS__
function ip(message) {
    return {
        kind: "validation",
        type: "ip",
        reference: ip,
        async: false,
        expects: null,
        requirement: IP_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "IP", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/ipv4/ipv4.ts
// @__NO_SIDE_EFFECTS__
function ipv4(message) {
    return {
        kind: "validation",
        type: "ipv4",
        reference: ipv4,
        async: false,
        expects: null,
        requirement: IPV4_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "IPv4", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/ipv6/ipv6.ts
// @__NO_SIDE_EFFECTS__
function ipv6(message) {
    return {
        kind: "validation",
        type: "ipv6",
        reference: ipv6,
        async: false,
        expects: null,
        requirement: IPV6_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "IPv6", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/isoDate/isoDate.ts
// @__NO_SIDE_EFFECTS__
function isoDate(message) {
    return {
        kind: "validation",
        type: "iso_date",
        reference: isoDate,
        async: false,
        expects: null,
        requirement: ISO_DATE_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "date", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/isoDateTime/isoDateTime.ts
// @__NO_SIDE_EFFECTS__
function isoDateTime(message) {
    return {
        kind: "validation",
        type: "iso_date_time",
        reference: isoDateTime,
        async: false,
        expects: null,
        requirement: ISO_DATE_TIME_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "date-time", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/isoTime/isoTime.ts
// @__NO_SIDE_EFFECTS__
function isoTime(message) {
    return {
        kind: "validation",
        type: "iso_time",
        reference: isoTime,
        async: false,
        expects: null,
        requirement: ISO_TIME_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "time", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/isoTimeSecond/isoTimeSecond.ts
// @__NO_SIDE_EFFECTS__
function isoTimeSecond(message) {
    return {
        kind: "validation",
        type: "iso_time_second",
        reference: isoTimeSecond,
        async: false,
        expects: null,
        requirement: ISO_TIME_SECOND_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "time-second", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/isoTimestamp/isoTimestamp.ts
// @__NO_SIDE_EFFECTS__
function isoTimestamp(message) {
    return {
        kind: "validation",
        type: "iso_timestamp",
        reference: isoTimestamp,
        async: false,
        expects: null,
        requirement: ISO_TIMESTAMP_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "timestamp", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/isoWeek/isoWeek.ts
// @__NO_SIDE_EFFECTS__
function isoWeek(message) {
    return {
        kind: "validation",
        type: "iso_week",
        reference: isoWeek,
        async: false,
        expects: null,
        requirement: ISO_WEEK_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "week", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/length/length.ts
// @__NO_SIDE_EFFECTS__
function length(requirement, message) {
    return {
        kind: "validation",
        type: "length",
        reference: length,
        async: false,
        expects: `${requirement}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && dataset.value.length !== this.requirement) {
                _addIssue(this, "length", dataset, config2, {
                    received: `${dataset.value.length}`
                });
            }
            return dataset;
        }
    };
}
// src/actions/ltValue/ltValue.ts
// @__NO_SIDE_EFFECTS__
function ltValue(requirement, message) {
    return {
        kind: "validation",
        type: "lt_value",
        reference: ltValue,
        async: false,
        expects: `<${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !(dataset.value < this.requirement)) {
                _addIssue(this, "value", dataset, config2, {
                    received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)
                });
            }
            return dataset;
        }
    };
}
// src/actions/mac/mac.ts
// @__NO_SIDE_EFFECTS__
function mac(message) {
    return {
        kind: "validation",
        type: "mac",
        reference: mac,
        async: false,
        expects: null,
        requirement: MAC_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "MAC", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/mac48/mac48.ts
// @__NO_SIDE_EFFECTS__
function mac48(message) {
    return {
        kind: "validation",
        type: "mac48",
        reference: mac48,
        async: false,
        expects: null,
        requirement: MAC48_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "48-bit MAC", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/mac64/mac64.ts
// @__NO_SIDE_EFFECTS__
function mac64(message) {
    return {
        kind: "validation",
        type: "mac64",
        reference: mac64,
        async: false,
        expects: null,
        requirement: MAC64_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "64-bit MAC", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/mapItems/mapItems.ts
// @__NO_SIDE_EFFECTS__
function mapItems(operation) {
    return {
        kind: "transformation",
        type: "map_items",
        reference: mapItems,
        async: false,
        operation,
        "~run" (dataset) {
            dataset.value = dataset.value.map(this.operation);
            return dataset;
        }
    };
}
// src/actions/maxBytes/maxBytes.ts
// @__NO_SIDE_EFFECTS__
function maxBytes(requirement, message) {
    return {
        kind: "validation",
        type: "max_bytes",
        reference: maxBytes,
        async: false,
        expects: `<=${requirement}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed) {
                const length2 = _getByteCount(dataset.value);
                if (length2 > this.requirement) {
                    _addIssue(this, "bytes", dataset, config2, {
                        received: `${length2}`
                    });
                }
            }
            return dataset;
        }
    };
}
// src/actions/maxGraphemes/maxGraphemes.ts
// @__NO_SIDE_EFFECTS__
function maxGraphemes(requirement, message) {
    return {
        kind: "validation",
        type: "max_graphemes",
        reference: maxGraphemes,
        async: false,
        expects: `<=${requirement}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed) {
                const count = _getGraphemeCount(dataset.value);
                if (count > this.requirement) {
                    _addIssue(this, "graphemes", dataset, config2, {
                        received: `${count}`
                    });
                }
            }
            return dataset;
        }
    };
}
// src/actions/maxLength/maxLength.ts
// @__NO_SIDE_EFFECTS__
function maxLength(requirement, message) {
    return {
        kind: "validation",
        type: "max_length",
        reference: maxLength,
        async: false,
        expects: `<=${requirement}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && dataset.value.length > this.requirement) {
                _addIssue(this, "length", dataset, config2, {
                    received: `${dataset.value.length}`
                });
            }
            return dataset;
        }
    };
}
// src/actions/maxSize/maxSize.ts
// @__NO_SIDE_EFFECTS__
function maxSize(requirement, message) {
    return {
        kind: "validation",
        type: "max_size",
        reference: maxSize,
        async: false,
        expects: `<=${requirement}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && dataset.value.size > this.requirement) {
                _addIssue(this, "size", dataset, config2, {
                    received: `${dataset.value.size}`
                });
            }
            return dataset;
        }
    };
}
// src/actions/maxValue/maxValue.ts
// @__NO_SIDE_EFFECTS__
function maxValue(requirement, message) {
    return {
        kind: "validation",
        type: "max_value",
        reference: maxValue,
        async: false,
        expects: `<=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !(dataset.value <= this.requirement)) {
                _addIssue(this, "value", dataset, config2, {
                    received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)
                });
            }
            return dataset;
        }
    };
}
// src/actions/maxWords/maxWords.ts
// @__NO_SIDE_EFFECTS__
function maxWords(locales, requirement, message) {
    return {
        kind: "validation",
        type: "max_words",
        reference: maxWords,
        async: false,
        expects: `<=${requirement}`,
        locales,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed) {
                const count = _getWordCount(this.locales, dataset.value);
                if (count > this.requirement) {
                    _addIssue(this, "words", dataset, config2, {
                        received: `${count}`
                    });
                }
            }
            return dataset;
        }
    };
}
// src/actions/metadata/metadata.ts
// @__NO_SIDE_EFFECTS__
function metadata(metadata_) {
    return {
        kind: "metadata",
        type: "metadata",
        reference: metadata,
        metadata: metadata_
    };
}
// src/actions/mimeType/mimeType.ts
// @__NO_SIDE_EFFECTS__
function mimeType(requirement, message) {
    return {
        kind: "validation",
        type: "mime_type",
        reference: mimeType,
        async: false,
        expects: _joinExpects(requirement.map((option)=>`"${option}"`), "|"),
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.includes(dataset.value.type)) {
                _addIssue(this, "MIME type", dataset, config2, {
                    received: `"${dataset.value.type}"`
                });
            }
            return dataset;
        }
    };
}
// src/actions/minBytes/minBytes.ts
// @__NO_SIDE_EFFECTS__
function minBytes(requirement, message) {
    return {
        kind: "validation",
        type: "min_bytes",
        reference: minBytes,
        async: false,
        expects: `>=${requirement}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed) {
                const length2 = _getByteCount(dataset.value);
                if (length2 < this.requirement) {
                    _addIssue(this, "bytes", dataset, config2, {
                        received: `${length2}`
                    });
                }
            }
            return dataset;
        }
    };
}
// src/actions/minGraphemes/minGraphemes.ts
// @__NO_SIDE_EFFECTS__
function minGraphemes(requirement, message) {
    return {
        kind: "validation",
        type: "min_graphemes",
        reference: minGraphemes,
        async: false,
        expects: `>=${requirement}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed) {
                const count = _getGraphemeCount(dataset.value);
                if (count < this.requirement) {
                    _addIssue(this, "graphemes", dataset, config2, {
                        received: `${count}`
                    });
                }
            }
            return dataset;
        }
    };
}
// src/actions/minLength/minLength.ts
// @__NO_SIDE_EFFECTS__
function minLength(requirement, message) {
    return {
        kind: "validation",
        type: "min_length",
        reference: minLength,
        async: false,
        expects: `>=${requirement}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && dataset.value.length < this.requirement) {
                _addIssue(this, "length", dataset, config2, {
                    received: `${dataset.value.length}`
                });
            }
            return dataset;
        }
    };
}
// src/actions/minSize/minSize.ts
// @__NO_SIDE_EFFECTS__
function minSize(requirement, message) {
    return {
        kind: "validation",
        type: "min_size",
        reference: minSize,
        async: false,
        expects: `>=${requirement}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && dataset.value.size < this.requirement) {
                _addIssue(this, "size", dataset, config2, {
                    received: `${dataset.value.size}`
                });
            }
            return dataset;
        }
    };
}
// src/actions/minValue/minValue.ts
// @__NO_SIDE_EFFECTS__
function minValue(requirement, message) {
    return {
        kind: "validation",
        type: "min_value",
        reference: minValue,
        async: false,
        expects: `>=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !(dataset.value >= this.requirement)) {
                _addIssue(this, "value", dataset, config2, {
                    received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)
                });
            }
            return dataset;
        }
    };
}
// src/actions/minWords/minWords.ts
// @__NO_SIDE_EFFECTS__
function minWords(locales, requirement, message) {
    return {
        kind: "validation",
        type: "min_words",
        reference: minWords,
        async: false,
        expects: `>=${requirement}`,
        locales,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed) {
                const count = _getWordCount(this.locales, dataset.value);
                if (count < this.requirement) {
                    _addIssue(this, "words", dataset, config2, {
                        received: `${count}`
                    });
                }
            }
            return dataset;
        }
    };
}
// src/actions/multipleOf/multipleOf.ts
// @__NO_SIDE_EFFECTS__
function multipleOf(requirement, message) {
    return {
        kind: "validation",
        type: "multiple_of",
        reference: multipleOf,
        async: false,
        expects: `%${requirement}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && dataset.value % this.requirement !== 0) {
                _addIssue(this, "multiple", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/nanoid/nanoid.ts
// @__NO_SIDE_EFFECTS__
function nanoid(message) {
    return {
        kind: "validation",
        type: "nanoid",
        reference: nanoid,
        async: false,
        expects: null,
        requirement: NANO_ID_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "Nano ID", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/nonEmpty/nonEmpty.ts
// @__NO_SIDE_EFFECTS__
function nonEmpty(message) {
    return {
        kind: "validation",
        type: "non_empty",
        reference: nonEmpty,
        async: false,
        expects: "!0",
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && dataset.value.length === 0) {
                _addIssue(this, "length", dataset, config2, {
                    received: "0"
                });
            }
            return dataset;
        }
    };
}
// src/actions/normalize/normalize.ts
// @__NO_SIDE_EFFECTS__
function normalize(form) {
    return {
        kind: "transformation",
        type: "normalize",
        reference: normalize,
        async: false,
        form,
        "~run" (dataset) {
            dataset.value = dataset.value.normalize(this.form);
            return dataset;
        }
    };
}
// src/actions/notBytes/notBytes.ts
// @__NO_SIDE_EFFECTS__
function notBytes(requirement, message) {
    return {
        kind: "validation",
        type: "not_bytes",
        reference: notBytes,
        async: false,
        expects: `!${requirement}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed) {
                const length2 = _getByteCount(dataset.value);
                if (length2 === this.requirement) {
                    _addIssue(this, "bytes", dataset, config2, {
                        received: `${length2}`
                    });
                }
            }
            return dataset;
        }
    };
}
// src/actions/notGraphemes/notGraphemes.ts
// @__NO_SIDE_EFFECTS__
function notGraphemes(requirement, message) {
    return {
        kind: "validation",
        type: "not_graphemes",
        reference: notGraphemes,
        async: false,
        expects: `!${requirement}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed) {
                const count = _getGraphemeCount(dataset.value);
                if (count === this.requirement) {
                    _addIssue(this, "graphemes", dataset, config2, {
                        received: `${count}`
                    });
                }
            }
            return dataset;
        }
    };
}
// src/actions/notLength/notLength.ts
// @__NO_SIDE_EFFECTS__
function notLength(requirement, message) {
    return {
        kind: "validation",
        type: "not_length",
        reference: notLength,
        async: false,
        expects: `!${requirement}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && dataset.value.length === this.requirement) {
                _addIssue(this, "length", dataset, config2, {
                    received: `${dataset.value.length}`
                });
            }
            return dataset;
        }
    };
}
// src/actions/notSize/notSize.ts
// @__NO_SIDE_EFFECTS__
function notSize(requirement, message) {
    return {
        kind: "validation",
        type: "not_size",
        reference: notSize,
        async: false,
        expects: `!${requirement}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && dataset.value.size === this.requirement) {
                _addIssue(this, "size", dataset, config2, {
                    received: `${dataset.value.size}`
                });
            }
            return dataset;
        }
    };
}
// src/actions/notValue/notValue.ts
// @__NO_SIDE_EFFECTS__
function notValue(requirement, message) {
    return {
        kind: "validation",
        type: "not_value",
        reference: notValue,
        async: false,
        expects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${_stringify(requirement)}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) {
                _addIssue(this, "value", dataset, config2, {
                    received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)
                });
            }
            return dataset;
        }
    };
}
// src/actions/notValues/notValues.ts
// @__NO_SIDE_EFFECTS__
function notValues(requirement, message) {
    return {
        kind: "validation",
        type: "not_values",
        reference: notValues,
        async: false,
        expects: `!${_joinExpects(requirement.map((value2)=>value2 instanceof Date ? value2.toJSON() : _stringify(value2)), "|")}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && this.requirement.some((value2)=>value2 <= dataset.value && value2 >= dataset.value)) {
                _addIssue(this, "value", dataset, config2, {
                    received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)
                });
            }
            return dataset;
        }
    };
}
// src/actions/notWords/notWords.ts
// @__NO_SIDE_EFFECTS__
function notWords(locales, requirement, message) {
    return {
        kind: "validation",
        type: "not_words",
        reference: notWords,
        async: false,
        expects: `!${requirement}`,
        locales,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed) {
                const count = _getWordCount(this.locales, dataset.value);
                if (count === this.requirement) {
                    _addIssue(this, "words", dataset, config2, {
                        received: `${count}`
                    });
                }
            }
            return dataset;
        }
    };
}
// src/actions/octal/octal.ts
// @__NO_SIDE_EFFECTS__
function octal(message) {
    return {
        kind: "validation",
        type: "octal",
        reference: octal,
        async: false,
        expects: null,
        requirement: OCTAL_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "octal", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/partialCheck/utils/_isPartiallyTyped/_isPartiallyTyped.ts
// @__NO_SIDE_EFFECTS__
function _isPartiallyTyped(dataset, paths) {
    if (dataset.issues) {
        for (const path of paths){
            for (const issue of dataset.issues){
                let typed = false;
                const bound = Math.min(path.length, issue.path?.length ?? 0);
                for(let index = 0; index < bound; index++){
                    if (// @ts-expect-error
                    path[index] !== issue.path[index].key && // @ts-expect-error
                    (path[index] !== "$" || issue.path[index].type !== "array")) {
                        typed = true;
                        break;
                    }
                }
                if (!typed) {
                    return false;
                }
            }
        }
    }
    return true;
}
// src/actions/partialCheck/partialCheck.ts
// @__NO_SIDE_EFFECTS__
function partialCheck(paths, requirement, message) {
    return {
        kind: "validation",
        type: "partial_check",
        reference: partialCheck,
        async: false,
        expects: null,
        paths,
        requirement,
        message,
        "~run" (dataset, config2) {
            if ((dataset.typed || _isPartiallyTyped(dataset, paths)) && // @ts-expect-error
            !this.requirement(dataset.value)) {
                _addIssue(this, "input", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/partialCheck/partialCheckAsync.ts
// @__NO_SIDE_EFFECTS__
function partialCheckAsync(paths, requirement, message) {
    return {
        kind: "validation",
        type: "partial_check",
        reference: partialCheckAsync,
        async: true,
        expects: null,
        paths,
        requirement,
        message,
        async "~run" (dataset, config2) {
            if ((dataset.typed || _isPartiallyTyped(dataset, paths)) && // @ts-expect-error
            !await this.requirement(dataset.value)) {
                _addIssue(this, "input", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/rawCheck/rawCheck.ts
// @__NO_SIDE_EFFECTS__
function rawCheck(action) {
    return {
        kind: "validation",
        type: "raw_check",
        reference: rawCheck,
        async: false,
        expects: null,
        "~run" (dataset, config2) {
            action({
                dataset,
                config: config2,
                addIssue: (info)=>_addIssue(this, info?.label ?? "input", dataset, config2, info)
            });
            return dataset;
        }
    };
}
// src/actions/rawCheck/rawCheckAsync.ts
// @__NO_SIDE_EFFECTS__
function rawCheckAsync(action) {
    return {
        kind: "validation",
        type: "raw_check",
        reference: rawCheckAsync,
        async: true,
        expects: null,
        async "~run" (dataset, config2) {
            await action({
                dataset,
                config: config2,
                addIssue: (info)=>_addIssue(this, info?.label ?? "input", dataset, config2, info)
            });
            return dataset;
        }
    };
}
// src/actions/rawTransform/rawTransform.ts
// @__NO_SIDE_EFFECTS__
function rawTransform(action) {
    return {
        kind: "transformation",
        type: "raw_transform",
        reference: rawTransform,
        async: false,
        "~run" (dataset, config2) {
            const output = action({
                dataset,
                config: config2,
                addIssue: (info)=>_addIssue(this, info?.label ?? "input", dataset, config2, info),
                NEVER: null
            });
            if (dataset.issues) {
                dataset.typed = false;
            } else {
                dataset.value = output;
            }
            return dataset;
        }
    };
}
// src/actions/rawTransform/rawTransformAsync.ts
// @__NO_SIDE_EFFECTS__
function rawTransformAsync(action) {
    return {
        kind: "transformation",
        type: "raw_transform",
        reference: rawTransformAsync,
        async: true,
        async "~run" (dataset, config2) {
            const output = await action({
                dataset,
                config: config2,
                addIssue: (info)=>_addIssue(this, info?.label ?? "input", dataset, config2, info),
                NEVER: null
            });
            if (dataset.issues) {
                dataset.typed = false;
            } else {
                dataset.value = output;
            }
            return dataset;
        }
    };
}
// src/actions/readonly/readonly.ts
// @__NO_SIDE_EFFECTS__
function readonly() {
    return {
        kind: "transformation",
        type: "readonly",
        reference: readonly,
        async: false,
        "~run" (dataset) {
            return dataset;
        }
    };
}
// src/actions/reduceItems/reduceItems.ts
// @__NO_SIDE_EFFECTS__
function reduceItems(operation, initial) {
    return {
        kind: "transformation",
        type: "reduce_items",
        reference: reduceItems,
        async: false,
        operation,
        initial,
        "~run" (dataset) {
            dataset.value = dataset.value.reduce(this.operation, this.initial);
            return dataset;
        }
    };
}
// src/actions/regex/regex.ts
// @__NO_SIDE_EFFECTS__
function regex(requirement, message) {
    return {
        kind: "validation",
        type: "regex",
        reference: regex,
        async: false,
        expects: `${requirement}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "format", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/returns/returns.ts
// @__NO_SIDE_EFFECTS__
function returns(schema) {
    return {
        kind: "transformation",
        type: "returns",
        reference: returns,
        async: false,
        schema,
        "~run" (dataset, config2) {
            const func = dataset.value;
            dataset.value = (...args_)=>{
                const returnsDataset = this.schema["~run"]({
                    value: func(...args_)
                }, config2);
                if (returnsDataset.issues) {
                    throw new ValiError(returnsDataset.issues);
                }
                return returnsDataset.value;
            };
            return dataset;
        }
    };
}
// src/actions/returns/returnsAsync.ts
// @__NO_SIDE_EFFECTS__
function returnsAsync(schema) {
    return {
        kind: "transformation",
        type: "returns",
        reference: returnsAsync,
        async: false,
        schema,
        "~run" (dataset, config2) {
            const func = dataset.value;
            dataset.value = async (...args_)=>{
                const returnsDataset = await this.schema["~run"]({
                    value: await func(...args_)
                }, config2);
                if (returnsDataset.issues) {
                    throw new ValiError(returnsDataset.issues);
                }
                return returnsDataset.value;
            };
            return dataset;
        }
    };
}
// src/actions/rfcEmail/rfcEmail.ts
// @__NO_SIDE_EFFECTS__
function rfcEmail(message) {
    return {
        kind: "validation",
        type: "rfc_email",
        reference: rfcEmail,
        expects: null,
        async: false,
        requirement: RFC_EMAIL_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "email", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/safeInteger/safeInteger.ts
// @__NO_SIDE_EFFECTS__
function safeInteger(message) {
    return {
        kind: "validation",
        type: "safe_integer",
        reference: safeInteger,
        async: false,
        expects: null,
        requirement: Number.isSafeInteger,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement(dataset.value)) {
                _addIssue(this, "safe integer", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/size/size.ts
// @__NO_SIDE_EFFECTS__
function size(requirement, message) {
    return {
        kind: "validation",
        type: "size",
        reference: size,
        async: false,
        expects: `${requirement}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && dataset.value.size !== this.requirement) {
                _addIssue(this, "size", dataset, config2, {
                    received: `${dataset.value.size}`
                });
            }
            return dataset;
        }
    };
}
// src/actions/slug/slug.ts
// @__NO_SIDE_EFFECTS__
function slug(message) {
    return {
        kind: "validation",
        type: "slug",
        reference: slug,
        async: false,
        expects: null,
        requirement: SLUG_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "slug", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/someItem/someItem.ts
// @__NO_SIDE_EFFECTS__
function someItem(requirement, message) {
    return {
        kind: "validation",
        type: "some_item",
        reference: someItem,
        async: false,
        expects: null,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !dataset.value.some(this.requirement)) {
                _addIssue(this, "item", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/sortItems/sortItems.ts
// @__NO_SIDE_EFFECTS__
function sortItems(operation) {
    return {
        kind: "transformation",
        type: "sort_items",
        reference: sortItems,
        async: false,
        operation,
        "~run" (dataset) {
            dataset.value = dataset.value.sort(this.operation);
            return dataset;
        }
    };
}
// src/actions/startsWith/startsWith.ts
// @__NO_SIDE_EFFECTS__
function startsWith(requirement, message) {
    return {
        kind: "validation",
        type: "starts_with",
        reference: startsWith,
        async: false,
        expects: `"${requirement}"`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !dataset.value.startsWith(this.requirement)) {
                _addIssue(this, "start", dataset, config2, {
                    received: `"${dataset.value.slice(0, this.requirement.length)}"`
                });
            }
            return dataset;
        }
    };
}
// src/actions/title/title.ts
// @__NO_SIDE_EFFECTS__
function title(title_) {
    return {
        kind: "metadata",
        type: "title",
        reference: title,
        title: title_
    };
}
// src/actions/toLowerCase/toLowerCase.ts
// @__NO_SIDE_EFFECTS__
function toLowerCase() {
    return {
        kind: "transformation",
        type: "to_lower_case",
        reference: toLowerCase,
        async: false,
        "~run" (dataset) {
            dataset.value = dataset.value.toLowerCase();
            return dataset;
        }
    };
}
// src/actions/toMaxValue/toMaxValue.ts
// @__NO_SIDE_EFFECTS__
function toMaxValue(requirement) {
    return {
        kind: "transformation",
        type: "to_max_value",
        reference: toMaxValue,
        async: false,
        requirement,
        "~run" (dataset) {
            dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;
            return dataset;
        }
    };
}
// src/actions/toMinValue/toMinValue.ts
// @__NO_SIDE_EFFECTS__
function toMinValue(requirement) {
    return {
        kind: "transformation",
        type: "to_min_value",
        reference: toMinValue,
        async: false,
        requirement,
        "~run" (dataset) {
            dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;
            return dataset;
        }
    };
}
// src/actions/toUpperCase/toUpperCase.ts
// @__NO_SIDE_EFFECTS__
function toUpperCase() {
    return {
        kind: "transformation",
        type: "to_upper_case",
        reference: toUpperCase,
        async: false,
        "~run" (dataset) {
            dataset.value = dataset.value.toUpperCase();
            return dataset;
        }
    };
}
// src/actions/transform/transform.ts
// @__NO_SIDE_EFFECTS__
function transform(operation) {
    return {
        kind: "transformation",
        type: "transform",
        reference: transform,
        async: false,
        operation,
        "~run" (dataset) {
            dataset.value = this.operation(dataset.value);
            return dataset;
        }
    };
}
// src/actions/transform/transformAsync.ts
// @__NO_SIDE_EFFECTS__
function transformAsync(operation) {
    return {
        kind: "transformation",
        type: "transform",
        reference: transformAsync,
        async: true,
        operation,
        async "~run" (dataset) {
            dataset.value = await this.operation(dataset.value);
            return dataset;
        }
    };
}
// src/actions/trim/trim.ts
// @__NO_SIDE_EFFECTS__
function trim() {
    return {
        kind: "transformation",
        type: "trim",
        reference: trim,
        async: false,
        "~run" (dataset) {
            dataset.value = dataset.value.trim();
            return dataset;
        }
    };
}
// src/actions/trimEnd/trimEnd.ts
// @__NO_SIDE_EFFECTS__
function trimEnd() {
    return {
        kind: "transformation",
        type: "trim_end",
        reference: trimEnd,
        async: false,
        "~run" (dataset) {
            dataset.value = dataset.value.trimEnd();
            return dataset;
        }
    };
}
// src/actions/trimStart/trimStart.ts
// @__NO_SIDE_EFFECTS__
function trimStart() {
    return {
        kind: "transformation",
        type: "trim_start",
        reference: trimStart,
        async: false,
        "~run" (dataset) {
            dataset.value = dataset.value.trimStart();
            return dataset;
        }
    };
}
// src/actions/ulid/ulid.ts
// @__NO_SIDE_EFFECTS__
function ulid(message) {
    return {
        kind: "validation",
        type: "ulid",
        reference: ulid,
        async: false,
        expects: null,
        requirement: ULID_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "ULID", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/url/url.ts
// @__NO_SIDE_EFFECTS__
function url(message) {
    return {
        kind: "validation",
        type: "url",
        reference: url,
        async: false,
        expects: null,
        requirement (input) {
            try {
                new URL(input);
                return true;
            } catch  {
                return false;
            }
        },
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement(dataset.value)) {
                _addIssue(this, "URL", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/uuid/uuid.ts
// @__NO_SIDE_EFFECTS__
function uuid(message) {
    return {
        kind: "validation",
        type: "uuid",
        reference: uuid,
        async: false,
        expects: null,
        requirement: UUID_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "UUID", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/value/value.ts
// @__NO_SIDE_EFFECTS__
function value(requirement, message) {
    return {
        kind: "validation",
        type: "value",
        reference: value,
        async: false,
        expects: requirement instanceof Date ? requirement.toJSON() : _stringify(requirement),
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) {
                _addIssue(this, "value", dataset, config2, {
                    received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)
                });
            }
            return dataset;
        }
    };
}
// src/actions/values/values.ts
// @__NO_SIDE_EFFECTS__
function values(requirement, message) {
    return {
        kind: "validation",
        type: "values",
        reference: values,
        async: false,
        expects: `${_joinExpects(requirement.map((value2)=>value2 instanceof Date ? value2.toJSON() : _stringify(value2)), "|")}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.some((value2)=>value2 <= dataset.value && value2 >= dataset.value)) {
                _addIssue(this, "value", dataset, config2, {
                    received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)
                });
            }
            return dataset;
        }
    };
}
// src/actions/words/words.ts
// @__NO_SIDE_EFFECTS__
function words(locales, requirement, message) {
    return {
        kind: "validation",
        type: "words",
        reference: words,
        async: false,
        expects: `${requirement}`,
        locales,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed) {
                const count = _getWordCount(this.locales, dataset.value);
                if (count !== this.requirement) {
                    _addIssue(this, "words", dataset, config2, {
                        received: `${count}`
                    });
                }
            }
            return dataset;
        }
    };
}
// src/methods/assert/assert.ts
function assert(schema, input) {
    const issues = schema["~run"]({
        value: input
    }, {
        abortEarly: true
    }).issues;
    if (issues) {
        throw new ValiError(issues);
    }
}
// src/methods/config/config.ts
// @__NO_SIDE_EFFECTS__
function config(schema, config2) {
    return {
        ...schema,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config_) {
            return schema["~run"](dataset, {
                ...config_,
                ...config2
            });
        }
    };
}
// src/methods/getFallback/getFallback.ts
// @__NO_SIDE_EFFECTS__
function getFallback(schema, dataset, config2) {
    return typeof schema.fallback === "function" ? // @ts-expect-error
    schema.fallback(dataset, config2) : // @ts-expect-error
    schema.fallback;
}
// src/methods/fallback/fallback.ts
// @__NO_SIDE_EFFECTS__
function fallback(schema, fallback2) {
    return {
        ...schema,
        fallback: fallback2,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            const outputDataset = schema["~run"](dataset, config2);
            return outputDataset.issues ? {
                typed: true,
                value: getFallback(this, outputDataset, config2)
            } : outputDataset;
        }
    };
}
// src/methods/fallback/fallbackAsync.ts
// @__NO_SIDE_EFFECTS__
function fallbackAsync(schema, fallback2) {
    return {
        ...schema,
        fallback: fallback2,
        async: true,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            const outputDataset = await schema["~run"](dataset, config2);
            return outputDataset.issues ? {
                typed: true,
                value: await getFallback(this, outputDataset, config2)
            } : outputDataset;
        }
    };
}
// src/methods/flatten/flatten.ts
// @__NO_SIDE_EFFECTS__
function flatten(issues) {
    const flatErrors = {};
    for (const issue of issues){
        if (issue.path) {
            const dotPath = getDotPath(issue);
            if (dotPath) {
                if (!flatErrors.nested) {
                    flatErrors.nested = {};
                }
                if (flatErrors.nested[dotPath]) {
                    flatErrors.nested[dotPath].push(issue.message);
                } else {
                    flatErrors.nested[dotPath] = [
                        issue.message
                    ];
                }
            } else {
                if (flatErrors.other) {
                    flatErrors.other.push(issue.message);
                } else {
                    flatErrors.other = [
                        issue.message
                    ];
                }
            }
        } else {
            if (flatErrors.root) {
                flatErrors.root.push(issue.message);
            } else {
                flatErrors.root = [
                    issue.message
                ];
            }
        }
    }
    return flatErrors;
}
// src/methods/forward/forward.ts
// @__NO_SIDE_EFFECTS__
function forward(action, path) {
    return {
        ...action,
        "~run" (dataset, config2) {
            const prevIssues = dataset.issues && [
                ...dataset.issues
            ];
            dataset = action["~run"](dataset, config2);
            if (dataset.issues) {
                for (const issue of dataset.issues){
                    if (!prevIssues?.includes(issue)) {
                        let pathInput = dataset.value;
                        for (const key of path){
                            const pathValue = pathInput[key];
                            const pathItem = {
                                type: "unknown",
                                origin: "value",
                                input: pathInput,
                                key,
                                value: pathValue
                            };
                            if (issue.path) {
                                issue.path.push(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            if (!pathValue) {
                                break;
                            }
                            pathInput = pathValue;
                        }
                    }
                }
            }
            return dataset;
        }
    };
}
// src/methods/forward/forwardAsync.ts
// @__NO_SIDE_EFFECTS__
function forwardAsync(action, path) {
    return {
        ...action,
        async: true,
        async "~run" (dataset, config2) {
            const prevIssues = dataset.issues && [
                ...dataset.issues
            ];
            dataset = await action["~run"](dataset, config2);
            if (dataset.issues) {
                for (const issue of dataset.issues){
                    if (!prevIssues?.includes(issue)) {
                        let pathInput = dataset.value;
                        for (const key of path){
                            const pathValue = pathInput[key];
                            const pathItem = {
                                type: "unknown",
                                origin: "value",
                                input: pathInput,
                                key,
                                value: pathValue
                            };
                            if (issue.path) {
                                issue.path.push(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            if (!pathValue) {
                                break;
                            }
                            pathInput = pathValue;
                        }
                    }
                }
            }
            return dataset;
        }
    };
}
// src/methods/getDefault/getDefault.ts
// @__NO_SIDE_EFFECTS__
function getDefault(schema, dataset, config2) {
    return typeof schema.default === "function" ? // @ts-expect-error
    schema.default(dataset, config2) : // @ts-expect-error
    schema.default;
}
// src/methods/getDefaults/getDefaults.ts
// @__NO_SIDE_EFFECTS__
function getDefaults(schema) {
    if ("entries" in schema) {
        const object2 = {};
        for(const key in schema.entries){
            object2[key] = /* @__PURE__ */ getDefaults(schema.entries[key]);
        }
        return object2;
    }
    if ("items" in schema) {
        return schema.items.map(getDefaults);
    }
    return getDefault(schema);
}
// src/methods/getDefaults/getDefaultsAsync.ts
// @__NO_SIDE_EFFECTS__
async function getDefaultsAsync(schema) {
    if ("entries" in schema) {
        return Object.fromEntries(await Promise.all(Object.entries(schema.entries).map(async ([key, value2])=>[
                key,
                await /* @__PURE__ */ getDefaultsAsync(value2)
            ])));
    }
    if ("items" in schema) {
        return Promise.all(schema.items.map(getDefaultsAsync));
    }
    return getDefault(schema);
}
// src/methods/getFallbacks/getFallbacks.ts
// @__NO_SIDE_EFFECTS__
function getFallbacks(schema) {
    if ("entries" in schema) {
        const object2 = {};
        for(const key in schema.entries){
            object2[key] = /* @__PURE__ */ getFallbacks(schema.entries[key]);
        }
        return object2;
    }
    if ("items" in schema) {
        return schema.items.map(getFallbacks);
    }
    return getFallback(schema);
}
// src/methods/getFallbacks/getFallbacksAsync.ts
// @__NO_SIDE_EFFECTS__
async function getFallbacksAsync(schema) {
    if ("entries" in schema) {
        return Object.fromEntries(await Promise.all(Object.entries(schema.entries).map(async ([key, value2])=>[
                key,
                await /* @__PURE__ */ getFallbacksAsync(value2)
            ])));
    }
    if ("items" in schema) {
        return Promise.all(schema.items.map(getFallbacksAsync));
    }
    return getFallback(schema);
}
// src/methods/is/is.ts
// @__NO_SIDE_EFFECTS__
function is(schema, input) {
    return !schema["~run"]({
        value: input
    }, {
        abortEarly: true
    }).issues;
}
// src/schemas/any/any.ts
// @__NO_SIDE_EFFECTS__
function any() {
    return {
        kind: "schema",
        type: "any",
        reference: any,
        expects: "any",
        async: false,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset) {
            dataset.typed = true;
            return dataset;
        }
    };
}
// src/schemas/array/array.ts
// @__NO_SIDE_EFFECTS__
function array(item, message) {
    return {
        kind: "schema",
        type: "array",
        reference: array,
        expects: "Array",
        async: false,
        item,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                for(let key = 0; key < input.length; key++){
                    const value2 = input[key];
                    const itemDataset = this.item["~run"]({
                        value: value2
                    }, config2);
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "array",
                            origin: "value",
                            input,
                            key,
                            value: value2
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = itemDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.push(itemDataset.value);
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/array/arrayAsync.ts
// @__NO_SIDE_EFFECTS__
function arrayAsync(item, message) {
    return {
        kind: "schema",
        type: "array",
        reference: arrayAsync,
        expects: "Array",
        async: true,
        item,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                const itemDatasets = await Promise.all(input.map((value2)=>this.item["~run"]({
                        value: value2
                    }, config2)));
                for(let key = 0; key < itemDatasets.length; key++){
                    const itemDataset = itemDatasets[key];
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "array",
                            origin: "value",
                            input,
                            key,
                            value: input[key]
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = itemDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.push(itemDataset.value);
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/bigint/bigint.ts
// @__NO_SIDE_EFFECTS__
function bigint(message) {
    return {
        kind: "schema",
        type: "bigint",
        reference: bigint,
        expects: "bigint",
        async: false,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (typeof dataset.value === "bigint") {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/blob/blob.ts
// @__NO_SIDE_EFFECTS__
function blob(message) {
    return {
        kind: "schema",
        type: "blob",
        reference: blob,
        expects: "Blob",
        async: false,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (dataset.value instanceof Blob) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/boolean/boolean.ts
// @__NO_SIDE_EFFECTS__
function boolean(message) {
    return {
        kind: "schema",
        type: "boolean",
        reference: boolean,
        expects: "boolean",
        async: false,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (typeof dataset.value === "boolean") {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/custom/custom.ts
// @__NO_SIDE_EFFECTS__
function custom(check2, message) {
    return {
        kind: "schema",
        type: "custom",
        reference: custom,
        expects: "unknown",
        async: false,
        check: check2,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (this.check(dataset.value)) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/custom/customAsync.ts
// @__NO_SIDE_EFFECTS__
function customAsync(check2, message) {
    return {
        kind: "schema",
        type: "custom",
        reference: customAsync,
        expects: "unknown",
        async: true,
        check: check2,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            if (await this.check(dataset.value)) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/date/date.ts
// @__NO_SIDE_EFFECTS__
function date(message) {
    return {
        kind: "schema",
        type: "date",
        reference: date,
        expects: "Date",
        async: false,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (dataset.value instanceof Date) {
                if (!isNaN(dataset.value)) {
                    dataset.typed = true;
                } else {
                    _addIssue(this, "type", dataset, config2, {
                        received: '"Invalid Date"'
                    });
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/enum/enum.ts
// @__NO_SIDE_EFFECTS__
function enum_(enum__, message) {
    const options = [];
    for(const key in enum__){
        if (`${+key}` !== key || typeof enum__[key] !== "string" || !Object.is(enum__[enum__[key]], +key)) {
            options.push(enum__[key]);
        }
    }
    return {
        kind: "schema",
        type: "enum",
        reference: enum_,
        expects: _joinExpects(options.map(_stringify), "|"),
        async: false,
        enum: enum__,
        options,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (this.options.includes(dataset.value)) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/exactOptional/exactOptional.ts
// @__NO_SIDE_EFFECTS__
function exactOptional(wrapped, default_) {
    return {
        kind: "schema",
        type: "exact_optional",
        reference: exactOptional,
        expects: wrapped.expects,
        async: false,
        wrapped,
        default: default_,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            return this.wrapped["~run"](dataset, config2);
        }
    };
}
// src/schemas/exactOptional/exactOptionalAsync.ts
// @__NO_SIDE_EFFECTS__
function exactOptionalAsync(wrapped, default_) {
    return {
        kind: "schema",
        type: "exact_optional",
        reference: exactOptionalAsync,
        expects: wrapped.expects,
        async: true,
        wrapped,
        default: default_,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            return this.wrapped["~run"](dataset, config2);
        }
    };
}
// src/schemas/file/file.ts
// @__NO_SIDE_EFFECTS__
function file(message) {
    return {
        kind: "schema",
        type: "file",
        reference: file,
        expects: "File",
        async: false,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (dataset.value instanceof File) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/function/function.ts
// @__NO_SIDE_EFFECTS__
function function_(message) {
    return {
        kind: "schema",
        type: "function",
        reference: function_,
        expects: "Function",
        async: false,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (typeof dataset.value === "function") {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/instance/instance.ts
// @__NO_SIDE_EFFECTS__
function instance(class_, message) {
    return {
        kind: "schema",
        type: "instance",
        reference: instance,
        expects: class_.name,
        async: false,
        class: class_,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (dataset.value instanceof this.class) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/intersect/utils/_merge/_merge.ts
// @__NO_SIDE_EFFECTS__
function _merge(value1, value2) {
    if (typeof value1 === typeof value2) {
        if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) {
            return {
                value: value1
            };
        }
        if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {
            for(const key in value2){
                if (key in value1) {
                    const dataset = /* @__PURE__ */ _merge(value1[key], value2[key]);
                    if (dataset.issue) {
                        return dataset;
                    }
                    value1[key] = dataset.value;
                } else {
                    value1[key] = value2[key];
                }
            }
            return {
                value: value1
            };
        }
        if (Array.isArray(value1) && Array.isArray(value2)) {
            if (value1.length === value2.length) {
                for(let index = 0; index < value1.length; index++){
                    const dataset = /* @__PURE__ */ _merge(value1[index], value2[index]);
                    if (dataset.issue) {
                        return dataset;
                    }
                    value1[index] = dataset.value;
                }
                return {
                    value: value1
                };
            }
        }
    }
    return {
        issue: true
    };
}
// src/schemas/intersect/intersect.ts
// @__NO_SIDE_EFFECTS__
function intersect(options, message) {
    return {
        kind: "schema",
        type: "intersect",
        reference: intersect,
        expects: _joinExpects(options.map((option)=>option.expects), "&"),
        async: false,
        options,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (this.options.length) {
                const input = dataset.value;
                let outputs;
                dataset.typed = true;
                for (const schema of this.options){
                    const optionDataset = schema["~run"]({
                        value: input
                    }, config2);
                    if (optionDataset.issues) {
                        if (dataset.issues) {
                            dataset.issues.push(...optionDataset.issues);
                        } else {
                            dataset.issues = optionDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!optionDataset.typed) {
                        dataset.typed = false;
                    }
                    if (dataset.typed) {
                        if (outputs) {
                            outputs.push(optionDataset.value);
                        } else {
                            outputs = [
                                optionDataset.value
                            ];
                        }
                    }
                }
                if (dataset.typed) {
                    dataset.value = outputs[0];
                    for(let index = 1; index < outputs.length; index++){
                        const mergeDataset = _merge(dataset.value, outputs[index]);
                        if (mergeDataset.issue) {
                            _addIssue(this, "type", dataset, config2, {
                                received: "unknown"
                            });
                            break;
                        }
                        dataset.value = mergeDataset.value;
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/intersect/intersectAsync.ts
// @__NO_SIDE_EFFECTS__
function intersectAsync(options, message) {
    return {
        kind: "schema",
        type: "intersect",
        reference: intersectAsync,
        expects: _joinExpects(options.map((option)=>option.expects), "&"),
        async: true,
        options,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            if (this.options.length) {
                const input = dataset.value;
                let outputs;
                dataset.typed = true;
                const optionDatasets = await Promise.all(this.options.map((schema)=>schema["~run"]({
                        value: input
                    }, config2)));
                for (const optionDataset of optionDatasets){
                    if (optionDataset.issues) {
                        if (dataset.issues) {
                            dataset.issues.push(...optionDataset.issues);
                        } else {
                            dataset.issues = optionDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!optionDataset.typed) {
                        dataset.typed = false;
                    }
                    if (dataset.typed) {
                        if (outputs) {
                            outputs.push(optionDataset.value);
                        } else {
                            outputs = [
                                optionDataset.value
                            ];
                        }
                    }
                }
                if (dataset.typed) {
                    dataset.value = outputs[0];
                    for(let index = 1; index < outputs.length; index++){
                        const mergeDataset = _merge(dataset.value, outputs[index]);
                        if (mergeDataset.issue) {
                            _addIssue(this, "type", dataset, config2, {
                                received: "unknown"
                            });
                            break;
                        }
                        dataset.value = mergeDataset.value;
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/lazy/lazy.ts
// @__NO_SIDE_EFFECTS__
function lazy(getter) {
    return {
        kind: "schema",
        type: "lazy",
        reference: lazy,
        expects: "unknown",
        async: false,
        getter,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            return this.getter(dataset.value)["~run"](dataset, config2);
        }
    };
}
// src/schemas/lazy/lazyAsync.ts
// @__NO_SIDE_EFFECTS__
function lazyAsync(getter) {
    return {
        kind: "schema",
        type: "lazy",
        reference: lazyAsync,
        expects: "unknown",
        async: true,
        getter,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            return (await this.getter(dataset.value))["~run"](dataset, config2);
        }
    };
}
// src/schemas/literal/literal.ts
// @__NO_SIDE_EFFECTS__
function literal(literal_, message) {
    return {
        kind: "schema",
        type: "literal",
        reference: literal,
        expects: _stringify(literal_),
        async: false,
        literal: literal_,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (dataset.value === this.literal) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/looseObject/looseObject.ts
// @__NO_SIDE_EFFECTS__
function looseObject(entries, message) {
    return {
        kind: "schema",
        type: "loose_object",
        reference: looseObject,
        expects: "Object",
        async: false,
        entries,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                for(const key in this.entries){
                    const valueSchema = this.entries[key];
                    if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && // @ts-expect-error
                    valueSchema.default !== void 0) {
                        const value2 = key in input ? // @ts-expect-error
                        input[key] : getDefault(valueSchema);
                        const valueDataset = valueSchema["~run"]({
                            value: value2
                        }, config2);
                        if (valueDataset.issues) {
                            const pathItem = {
                                type: "object",
                                origin: "value",
                                input,
                                key,
                                value: value2
                            };
                            for (const issue of valueDataset.issues){
                                if (issue.path) {
                                    issue.path.unshift(pathItem);
                                } else {
                                    issue.path = [
                                        pathItem
                                    ];
                                }
                                dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                                dataset.issues = valueDataset.issues;
                            }
                            if (config2.abortEarly) {
                                dataset.typed = false;
                                break;
                            }
                        }
                        if (!valueDataset.typed) {
                            dataset.typed = false;
                        }
                        dataset.value[key] = valueDataset.value;
                    } else if (valueSchema.fallback !== void 0) {
                        dataset.value[key] = getFallback(valueSchema);
                    } else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
                        _addIssue(this, "key", dataset, config2, {
                            input: void 0,
                            expected: `"${key}"`,
                            path: [
                                {
                                    type: "object",
                                    origin: "key",
                                    input,
                                    key,
                                    // @ts-expect-error
                                    value: input[key]
                                }
                            ]
                        });
                        if (config2.abortEarly) {
                            break;
                        }
                    }
                }
                if (!dataset.issues || !config2.abortEarly) {
                    for(const key in input){
                        if (_isValidObjectKey(input, key) && !(key in this.entries)) {
                            dataset.value[key] = input[key];
                        }
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/looseObject/looseObjectAsync.ts
// @__NO_SIDE_EFFECTS__
function looseObjectAsync(entries, message) {
    return {
        kind: "schema",
        type: "loose_object",
        reference: looseObjectAsync,
        expects: "Object",
        async: true,
        entries,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                const valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema])=>{
                    if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && // @ts-expect-error
                    valueSchema.default !== void 0) {
                        const value2 = key in input ? // @ts-expect-error
                        input[key] : await getDefault(valueSchema);
                        return [
                            key,
                            value2,
                            valueSchema,
                            await valueSchema["~run"]({
                                value: value2
                            }, config2)
                        ];
                    }
                    return [
                        key,
                        // @ts-expect-error
                        input[key],
                        valueSchema,
                        null
                    ];
                }));
                for (const [key, value2, valueSchema, valueDataset] of valueDatasets){
                    if (valueDataset) {
                        if (valueDataset.issues) {
                            const pathItem = {
                                type: "object",
                                origin: "value",
                                input,
                                key,
                                value: value2
                            };
                            for (const issue of valueDataset.issues){
                                if (issue.path) {
                                    issue.path.unshift(pathItem);
                                } else {
                                    issue.path = [
                                        pathItem
                                    ];
                                }
                                dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                                dataset.issues = valueDataset.issues;
                            }
                            if (config2.abortEarly) {
                                dataset.typed = false;
                                break;
                            }
                        }
                        if (!valueDataset.typed) {
                            dataset.typed = false;
                        }
                        dataset.value[key] = valueDataset.value;
                    } else if (valueSchema.fallback !== void 0) {
                        dataset.value[key] = await getFallback(valueSchema);
                    } else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
                        _addIssue(this, "key", dataset, config2, {
                            input: void 0,
                            expected: `"${key}"`,
                            path: [
                                {
                                    type: "object",
                                    origin: "key",
                                    input,
                                    key,
                                    value: value2
                                }
                            ]
                        });
                        if (config2.abortEarly) {
                            break;
                        }
                    }
                }
                if (!dataset.issues || !config2.abortEarly) {
                    for(const key in input){
                        if (_isValidObjectKey(input, key) && !(key in this.entries)) {
                            dataset.value[key] = input[key];
                        }
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/looseTuple/looseTuple.ts
// @__NO_SIDE_EFFECTS__
function looseTuple(items, message) {
    return {
        kind: "schema",
        type: "loose_tuple",
        reference: looseTuple,
        expects: "Array",
        async: false,
        items,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                for(let key = 0; key < this.items.length; key++){
                    const value2 = input[key];
                    const itemDataset = this.items[key]["~run"]({
                        value: value2
                    }, config2);
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "array",
                            origin: "value",
                            input,
                            key,
                            value: value2
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = itemDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.push(itemDataset.value);
                }
                if (!dataset.issues || !config2.abortEarly) {
                    for(let key = this.items.length; key < input.length; key++){
                        dataset.value.push(input[key]);
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/looseTuple/looseTupleAsync.ts
// @__NO_SIDE_EFFECTS__
function looseTupleAsync(items, message) {
    return {
        kind: "schema",
        type: "loose_tuple",
        reference: looseTupleAsync,
        expects: "Array",
        async: true,
        items,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                const itemDatasets = await Promise.all(this.items.map(async (item, key)=>{
                    const value2 = input[key];
                    return [
                        key,
                        value2,
                        await item["~run"]({
                            value: value2
                        }, config2)
                    ];
                }));
                for (const [key, value2, itemDataset] of itemDatasets){
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "array",
                            origin: "value",
                            input,
                            key,
                            value: value2
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = itemDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.push(itemDataset.value);
                }
                if (!dataset.issues || !config2.abortEarly) {
                    for(let key = this.items.length; key < input.length; key++){
                        dataset.value.push(input[key]);
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/map/map.ts
// @__NO_SIDE_EFFECTS__
function map(key, value2, message) {
    return {
        kind: "schema",
        type: "map",
        reference: map,
        expects: "Map",
        async: false,
        key,
        value: value2,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            const input = dataset.value;
            if (input instanceof Map) {
                dataset.typed = true;
                dataset.value = /* @__PURE__ */ new Map();
                for (const [inputKey, inputValue] of input){
                    const keyDataset = this.key["~run"]({
                        value: inputKey
                    }, config2);
                    if (keyDataset.issues) {
                        const pathItem = {
                            type: "map",
                            origin: "key",
                            input,
                            key: inputKey,
                            value: inputValue
                        };
                        for (const issue of keyDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = keyDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    const valueDataset = this.value["~run"]({
                        value: inputValue
                    }, config2);
                    if (valueDataset.issues) {
                        const pathItem = {
                            type: "map",
                            origin: "value",
                            input,
                            key: inputKey,
                            value: inputValue
                        };
                        for (const issue of valueDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = valueDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!keyDataset.typed || !valueDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.set(keyDataset.value, valueDataset.value);
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/map/mapAsync.ts
// @__NO_SIDE_EFFECTS__
function mapAsync(key, value2, message) {
    return {
        kind: "schema",
        type: "map",
        reference: mapAsync,
        expects: "Map",
        async: true,
        key,
        value: value2,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            const input = dataset.value;
            if (input instanceof Map) {
                dataset.typed = true;
                dataset.value = /* @__PURE__ */ new Map();
                const datasets = await Promise.all([
                    ...input
                ].map(([inputKey, inputValue])=>Promise.all([
                        inputKey,
                        inputValue,
                        this.key["~run"]({
                            value: inputKey
                        }, config2),
                        this.value["~run"]({
                            value: inputValue
                        }, config2)
                    ])));
                for (const [inputKey, inputValue, keyDataset, valueDataset] of datasets){
                    if (keyDataset.issues) {
                        const pathItem = {
                            type: "map",
                            origin: "key",
                            input,
                            key: inputKey,
                            value: inputValue
                        };
                        for (const issue of keyDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = keyDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (valueDataset.issues) {
                        const pathItem = {
                            type: "map",
                            origin: "value",
                            input,
                            key: inputKey,
                            value: inputValue
                        };
                        for (const issue of valueDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = valueDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!keyDataset.typed || !valueDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.set(keyDataset.value, valueDataset.value);
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/nan/nan.ts
// @__NO_SIDE_EFFECTS__
function nan(message) {
    return {
        kind: "schema",
        type: "nan",
        reference: nan,
        expects: "NaN",
        async: false,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (Number.isNaN(dataset.value)) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/never/never.ts
// @__NO_SIDE_EFFECTS__
function never(message) {
    return {
        kind: "schema",
        type: "never",
        reference: never,
        expects: "never",
        async: false,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            _addIssue(this, "type", dataset, config2);
            return dataset;
        }
    };
}
// src/schemas/nonNullable/nonNullable.ts
// @__NO_SIDE_EFFECTS__
function nonNullable(wrapped, message) {
    return {
        kind: "schema",
        type: "non_nullable",
        reference: nonNullable,
        expects: "!null",
        async: false,
        wrapped,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (dataset.value !== null) {
                dataset = this.wrapped["~run"](dataset, config2);
            }
            if (dataset.value === null) {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/nonNullable/nonNullableAsync.ts
// @__NO_SIDE_EFFECTS__
function nonNullableAsync(wrapped, message) {
    return {
        kind: "schema",
        type: "non_nullable",
        reference: nonNullableAsync,
        expects: "!null",
        async: true,
        wrapped,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            if (dataset.value !== null) {
                dataset = await this.wrapped["~run"](dataset, config2);
            }
            if (dataset.value === null) {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/nonNullish/nonNullish.ts
// @__NO_SIDE_EFFECTS__
function nonNullish(wrapped, message) {
    return {
        kind: "schema",
        type: "non_nullish",
        reference: nonNullish,
        expects: "(!null & !undefined)",
        async: false,
        wrapped,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (!(dataset.value === null || dataset.value === void 0)) {
                dataset = this.wrapped["~run"](dataset, config2);
            }
            if (dataset.value === null || dataset.value === void 0) {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/nonNullish/nonNullishAsync.ts
// @__NO_SIDE_EFFECTS__
function nonNullishAsync(wrapped, message) {
    return {
        kind: "schema",
        type: "non_nullish",
        reference: nonNullishAsync,
        expects: "(!null & !undefined)",
        async: true,
        wrapped,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            if (!(dataset.value === null || dataset.value === void 0)) {
                dataset = await this.wrapped["~run"](dataset, config2);
            }
            if (dataset.value === null || dataset.value === void 0) {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/nonOptional/nonOptional.ts
// @__NO_SIDE_EFFECTS__
function nonOptional(wrapped, message) {
    return {
        kind: "schema",
        type: "non_optional",
        reference: nonOptional,
        expects: "!undefined",
        async: false,
        wrapped,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (dataset.value !== void 0) {
                dataset = this.wrapped["~run"](dataset, config2);
            }
            if (dataset.value === void 0) {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/nonOptional/nonOptionalAsync.ts
// @__NO_SIDE_EFFECTS__
function nonOptionalAsync(wrapped, message) {
    return {
        kind: "schema",
        type: "non_optional",
        reference: nonOptionalAsync,
        expects: "!undefined",
        async: true,
        wrapped,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            if (dataset.value !== void 0) {
                dataset = await this.wrapped["~run"](dataset, config2);
            }
            if (dataset.value === void 0) {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/null/null.ts
// @__NO_SIDE_EFFECTS__
function null_(message) {
    return {
        kind: "schema",
        type: "null",
        reference: null_,
        expects: "null",
        async: false,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (dataset.value === null) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/nullable/nullable.ts
// @__NO_SIDE_EFFECTS__
function nullable(wrapped, default_) {
    return {
        kind: "schema",
        type: "nullable",
        reference: nullable,
        expects: `(${wrapped.expects} | null)`,
        async: false,
        wrapped,
        default: default_,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (dataset.value === null) {
                if (this.default !== void 0) {
                    dataset.value = getDefault(this, dataset, config2);
                }
                if (dataset.value === null) {
                    dataset.typed = true;
                    return dataset;
                }
            }
            return this.wrapped["~run"](dataset, config2);
        }
    };
}
// src/schemas/nullable/nullableAsync.ts
// @__NO_SIDE_EFFECTS__
function nullableAsync(wrapped, default_) {
    return {
        kind: "schema",
        type: "nullable",
        reference: nullableAsync,
        expects: `(${wrapped.expects} | null)`,
        async: true,
        wrapped,
        default: default_,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            if (dataset.value === null) {
                if (this.default !== void 0) {
                    dataset.value = await getDefault(this, dataset, config2);
                }
                if (dataset.value === null) {
                    dataset.typed = true;
                    return dataset;
                }
            }
            return this.wrapped["~run"](dataset, config2);
        }
    };
}
// src/schemas/nullish/nullish.ts
// @__NO_SIDE_EFFECTS__
function nullish(wrapped, default_) {
    return {
        kind: "schema",
        type: "nullish",
        reference: nullish,
        expects: `(${wrapped.expects} | null | undefined)`,
        async: false,
        wrapped,
        default: default_,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (dataset.value === null || dataset.value === void 0) {
                if (this.default !== void 0) {
                    dataset.value = getDefault(this, dataset, config2);
                }
                if (dataset.value === null || dataset.value === void 0) {
                    dataset.typed = true;
                    return dataset;
                }
            }
            return this.wrapped["~run"](dataset, config2);
        }
    };
}
// src/schemas/nullish/nullishAsync.ts
// @__NO_SIDE_EFFECTS__
function nullishAsync(wrapped, default_) {
    return {
        kind: "schema",
        type: "nullish",
        reference: nullishAsync,
        expects: `(${wrapped.expects} | null | undefined)`,
        async: true,
        wrapped,
        default: default_,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            if (dataset.value === null || dataset.value === void 0) {
                if (this.default !== void 0) {
                    dataset.value = await getDefault(this, dataset, config2);
                }
                if (dataset.value === null || dataset.value === void 0) {
                    dataset.typed = true;
                    return dataset;
                }
            }
            return this.wrapped["~run"](dataset, config2);
        }
    };
}
// src/schemas/number/number.ts
// @__NO_SIDE_EFFECTS__
function number(message) {
    return {
        kind: "schema",
        type: "number",
        reference: number,
        expects: "number",
        async: false,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (typeof dataset.value === "number" && !isNaN(dataset.value)) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/object/object.ts
// @__NO_SIDE_EFFECTS__
function object(entries, message) {
    return {
        kind: "schema",
        type: "object",
        reference: object,
        expects: "Object",
        async: false,
        entries,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                for(const key in this.entries){
                    const valueSchema = this.entries[key];
                    if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && // @ts-expect-error
                    valueSchema.default !== void 0) {
                        const value2 = key in input ? // @ts-expect-error
                        input[key] : getDefault(valueSchema);
                        const valueDataset = valueSchema["~run"]({
                            value: value2
                        }, config2);
                        if (valueDataset.issues) {
                            const pathItem = {
                                type: "object",
                                origin: "value",
                                input,
                                key,
                                value: value2
                            };
                            for (const issue of valueDataset.issues){
                                if (issue.path) {
                                    issue.path.unshift(pathItem);
                                } else {
                                    issue.path = [
                                        pathItem
                                    ];
                                }
                                dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                                dataset.issues = valueDataset.issues;
                            }
                            if (config2.abortEarly) {
                                dataset.typed = false;
                                break;
                            }
                        }
                        if (!valueDataset.typed) {
                            dataset.typed = false;
                        }
                        dataset.value[key] = valueDataset.value;
                    } else if (valueSchema.fallback !== void 0) {
                        dataset.value[key] = getFallback(valueSchema);
                    } else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
                        _addIssue(this, "key", dataset, config2, {
                            input: void 0,
                            expected: `"${key}"`,
                            path: [
                                {
                                    type: "object",
                                    origin: "key",
                                    input,
                                    key,
                                    // @ts-expect-error
                                    value: input[key]
                                }
                            ]
                        });
                        if (config2.abortEarly) {
                            break;
                        }
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/object/objectAsync.ts
// @__NO_SIDE_EFFECTS__
function objectAsync(entries, message) {
    return {
        kind: "schema",
        type: "object",
        reference: objectAsync,
        expects: "Object",
        async: true,
        entries,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                const valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema])=>{
                    if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && // @ts-expect-error
                    valueSchema.default !== void 0) {
                        const value2 = key in input ? // @ts-expect-error
                        input[key] : await getDefault(valueSchema);
                        return [
                            key,
                            value2,
                            valueSchema,
                            await valueSchema["~run"]({
                                value: value2
                            }, config2)
                        ];
                    }
                    return [
                        key,
                        // @ts-expect-error
                        input[key],
                        valueSchema,
                        null
                    ];
                }));
                for (const [key, value2, valueSchema, valueDataset] of valueDatasets){
                    if (valueDataset) {
                        if (valueDataset.issues) {
                            const pathItem = {
                                type: "object",
                                origin: "value",
                                input,
                                key,
                                value: value2
                            };
                            for (const issue of valueDataset.issues){
                                if (issue.path) {
                                    issue.path.unshift(pathItem);
                                } else {
                                    issue.path = [
                                        pathItem
                                    ];
                                }
                                dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                                dataset.issues = valueDataset.issues;
                            }
                            if (config2.abortEarly) {
                                dataset.typed = false;
                                break;
                            }
                        }
                        if (!valueDataset.typed) {
                            dataset.typed = false;
                        }
                        dataset.value[key] = valueDataset.value;
                    } else if (valueSchema.fallback !== void 0) {
                        dataset.value[key] = await getFallback(valueSchema);
                    } else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
                        _addIssue(this, "key", dataset, config2, {
                            input: void 0,
                            expected: `"${key}"`,
                            path: [
                                {
                                    type: "object",
                                    origin: "key",
                                    input,
                                    key,
                                    value: value2
                                }
                            ]
                        });
                        if (config2.abortEarly) {
                            break;
                        }
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/objectWithRest/objectWithRest.ts
// @__NO_SIDE_EFFECTS__
function objectWithRest(entries, rest, message) {
    return {
        kind: "schema",
        type: "object_with_rest",
        reference: objectWithRest,
        expects: "Object",
        async: false,
        entries,
        rest,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                for(const key in this.entries){
                    const valueSchema = this.entries[key];
                    if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && // @ts-expect-error
                    valueSchema.default !== void 0) {
                        const value2 = key in input ? // @ts-expect-error
                        input[key] : getDefault(valueSchema);
                        const valueDataset = valueSchema["~run"]({
                            value: value2
                        }, config2);
                        if (valueDataset.issues) {
                            const pathItem = {
                                type: "object",
                                origin: "value",
                                input,
                                key,
                                value: value2
                            };
                            for (const issue of valueDataset.issues){
                                if (issue.path) {
                                    issue.path.unshift(pathItem);
                                } else {
                                    issue.path = [
                                        pathItem
                                    ];
                                }
                                dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                                dataset.issues = valueDataset.issues;
                            }
                            if (config2.abortEarly) {
                                dataset.typed = false;
                                break;
                            }
                        }
                        if (!valueDataset.typed) {
                            dataset.typed = false;
                        }
                        dataset.value[key] = valueDataset.value;
                    } else if (valueSchema.fallback !== void 0) {
                        dataset.value[key] = getFallback(valueSchema);
                    } else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
                        _addIssue(this, "key", dataset, config2, {
                            input: void 0,
                            expected: `"${key}"`,
                            path: [
                                {
                                    type: "object",
                                    origin: "key",
                                    input,
                                    key,
                                    // @ts-expect-error
                                    value: input[key]
                                }
                            ]
                        });
                        if (config2.abortEarly) {
                            break;
                        }
                    }
                }
                if (!dataset.issues || !config2.abortEarly) {
                    for(const key in input){
                        if (_isValidObjectKey(input, key) && !(key in this.entries)) {
                            const valueDataset = this.rest["~run"](// @ts-expect-error
                            {
                                value: input[key]
                            }, config2);
                            if (valueDataset.issues) {
                                const pathItem = {
                                    type: "object",
                                    origin: "value",
                                    input,
                                    key,
                                    // @ts-expect-error
                                    value: input[key]
                                };
                                for (const issue of valueDataset.issues){
                                    if (issue.path) {
                                        issue.path.unshift(pathItem);
                                    } else {
                                        issue.path = [
                                            pathItem
                                        ];
                                    }
                                    dataset.issues?.push(issue);
                                }
                                if (!dataset.issues) {
                                    dataset.issues = valueDataset.issues;
                                }
                                if (config2.abortEarly) {
                                    dataset.typed = false;
                                    break;
                                }
                            }
                            if (!valueDataset.typed) {
                                dataset.typed = false;
                            }
                            dataset.value[key] = valueDataset.value;
                        }
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/objectWithRest/objectWithRestAsync.ts
// @__NO_SIDE_EFFECTS__
function objectWithRestAsync(entries, rest, message) {
    return {
        kind: "schema",
        type: "object_with_rest",
        reference: objectWithRestAsync,
        expects: "Object",
        async: true,
        entries,
        rest,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                const [normalDatasets, restDatasets] = await Promise.all([
                    // If key is present or its an optional schema with a default value,
                    // parse input of key or default value asynchronously
                    Promise.all(Object.entries(this.entries).map(async ([key, valueSchema])=>{
                        if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && // @ts-expect-error
                        valueSchema.default !== void 0) {
                            const value2 = key in input ? // @ts-expect-error
                            input[key] : await getDefault(valueSchema);
                            return [
                                key,
                                value2,
                                valueSchema,
                                await valueSchema["~run"]({
                                    value: value2
                                }, config2)
                            ];
                        }
                        return [
                            key,
                            // @ts-expect-error
                            input[key],
                            valueSchema,
                            null
                        ];
                    })),
                    // Parse other entries with rest schema asynchronously
                    // Hint: We exclude specific keys for security reasons
                    Promise.all(Object.entries(input).filter(([key])=>_isValidObjectKey(input, key) && !(key in this.entries)).map(async ([key, value2])=>[
                            key,
                            value2,
                            await this.rest["~run"]({
                                value: value2
                            }, config2)
                        ]))
                ]);
                for (const [key, value2, valueSchema, valueDataset] of normalDatasets){
                    if (valueDataset) {
                        if (valueDataset.issues) {
                            const pathItem = {
                                type: "object",
                                origin: "value",
                                input,
                                key,
                                value: value2
                            };
                            for (const issue of valueDataset.issues){
                                if (issue.path) {
                                    issue.path.unshift(pathItem);
                                } else {
                                    issue.path = [
                                        pathItem
                                    ];
                                }
                                dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                                dataset.issues = valueDataset.issues;
                            }
                            if (config2.abortEarly) {
                                dataset.typed = false;
                                break;
                            }
                        }
                        if (!valueDataset.typed) {
                            dataset.typed = false;
                        }
                        dataset.value[key] = valueDataset.value;
                    } else if (valueSchema.fallback !== void 0) {
                        dataset.value[key] = await getFallback(valueSchema);
                    } else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
                        _addIssue(this, "key", dataset, config2, {
                            input: void 0,
                            expected: `"${key}"`,
                            path: [
                                {
                                    type: "object",
                                    origin: "key",
                                    input,
                                    key,
                                    value: value2
                                }
                            ]
                        });
                        if (config2.abortEarly) {
                            break;
                        }
                    }
                }
                if (!dataset.issues || !config2.abortEarly) {
                    for (const [key, value2, valueDataset] of restDatasets){
                        if (valueDataset.issues) {
                            const pathItem = {
                                type: "object",
                                origin: "value",
                                input,
                                key,
                                value: value2
                            };
                            for (const issue of valueDataset.issues){
                                if (issue.path) {
                                    issue.path.unshift(pathItem);
                                } else {
                                    issue.path = [
                                        pathItem
                                    ];
                                }
                                dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                                dataset.issues = valueDataset.issues;
                            }
                            if (config2.abortEarly) {
                                dataset.typed = false;
                                break;
                            }
                        }
                        if (!valueDataset.typed) {
                            dataset.typed = false;
                        }
                        dataset.value[key] = valueDataset.value;
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/optional/optional.ts
// @__NO_SIDE_EFFECTS__
function optional(wrapped, default_) {
    return {
        kind: "schema",
        type: "optional",
        reference: optional,
        expects: `(${wrapped.expects} | undefined)`,
        async: false,
        wrapped,
        default: default_,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (dataset.value === void 0) {
                if (this.default !== void 0) {
                    dataset.value = getDefault(this, dataset, config2);
                }
                if (dataset.value === void 0) {
                    dataset.typed = true;
                    return dataset;
                }
            }
            return this.wrapped["~run"](dataset, config2);
        }
    };
}
// src/schemas/optional/optionalAsync.ts
// @__NO_SIDE_EFFECTS__
function optionalAsync(wrapped, default_) {
    return {
        kind: "schema",
        type: "optional",
        reference: optionalAsync,
        expects: `(${wrapped.expects} | undefined)`,
        async: true,
        wrapped,
        default: default_,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            if (dataset.value === void 0) {
                if (this.default !== void 0) {
                    dataset.value = await getDefault(this, dataset, config2);
                }
                if (dataset.value === void 0) {
                    dataset.typed = true;
                    return dataset;
                }
            }
            return this.wrapped["~run"](dataset, config2);
        }
    };
}
// src/schemas/picklist/picklist.ts
// @__NO_SIDE_EFFECTS__
function picklist(options, message) {
    return {
        kind: "schema",
        type: "picklist",
        reference: picklist,
        expects: _joinExpects(options.map(_stringify), "|"),
        async: false,
        options,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (this.options.includes(dataset.value)) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/promise/promise.ts
// @__NO_SIDE_EFFECTS__
function promise(message) {
    return {
        kind: "schema",
        type: "promise",
        reference: promise,
        expects: "Promise",
        async: false,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (dataset.value instanceof Promise) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/record/record.ts
// @__NO_SIDE_EFFECTS__
function record(key, value2, message) {
    return {
        kind: "schema",
        type: "record",
        reference: record,
        expects: "Object",
        async: false,
        key,
        value: value2,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                for(const entryKey in input){
                    if (_isValidObjectKey(input, entryKey)) {
                        const entryValue = input[entryKey];
                        const keyDataset = this.key["~run"]({
                            value: entryKey
                        }, config2);
                        if (keyDataset.issues) {
                            const pathItem = {
                                type: "object",
                                origin: "key",
                                input,
                                key: entryKey,
                                value: entryValue
                            };
                            for (const issue of keyDataset.issues){
                                issue.path = [
                                    pathItem
                                ];
                                dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                                dataset.issues = keyDataset.issues;
                            }
                            if (config2.abortEarly) {
                                dataset.typed = false;
                                break;
                            }
                        }
                        const valueDataset = this.value["~run"]({
                            value: entryValue
                        }, config2);
                        if (valueDataset.issues) {
                            const pathItem = {
                                type: "object",
                                origin: "value",
                                input,
                                key: entryKey,
                                value: entryValue
                            };
                            for (const issue of valueDataset.issues){
                                if (issue.path) {
                                    issue.path.unshift(pathItem);
                                } else {
                                    issue.path = [
                                        pathItem
                                    ];
                                }
                                dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                                dataset.issues = valueDataset.issues;
                            }
                            if (config2.abortEarly) {
                                dataset.typed = false;
                                break;
                            }
                        }
                        if (!keyDataset.typed || !valueDataset.typed) {
                            dataset.typed = false;
                        }
                        if (keyDataset.typed) {
                            dataset.value[keyDataset.value] = valueDataset.value;
                        }
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/record/recordAsync.ts
// @__NO_SIDE_EFFECTS__
function recordAsync(key, value2, message) {
    return {
        kind: "schema",
        type: "record",
        reference: recordAsync,
        expects: "Object",
        async: true,
        key,
        value: value2,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                const datasets = await Promise.all(Object.entries(input).filter(([key2])=>_isValidObjectKey(input, key2)).map(([entryKey, entryValue])=>Promise.all([
                        entryKey,
                        entryValue,
                        this.key["~run"]({
                            value: entryKey
                        }, config2),
                        this.value["~run"]({
                            value: entryValue
                        }, config2)
                    ])));
                for (const [entryKey, entryValue, keyDataset, valueDataset] of datasets){
                    if (keyDataset.issues) {
                        const pathItem = {
                            type: "object",
                            origin: "key",
                            input,
                            key: entryKey,
                            value: entryValue
                        };
                        for (const issue of keyDataset.issues){
                            issue.path = [
                                pathItem
                            ];
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = keyDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (valueDataset.issues) {
                        const pathItem = {
                            type: "object",
                            origin: "value",
                            input,
                            key: entryKey,
                            value: entryValue
                        };
                        for (const issue of valueDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = valueDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!keyDataset.typed || !valueDataset.typed) {
                        dataset.typed = false;
                    }
                    if (keyDataset.typed) {
                        dataset.value[keyDataset.value] = valueDataset.value;
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/set/set.ts
// @__NO_SIDE_EFFECTS__
function set(value2, message) {
    return {
        kind: "schema",
        type: "set",
        reference: set,
        expects: "Set",
        async: false,
        value: value2,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            const input = dataset.value;
            if (input instanceof Set) {
                dataset.typed = true;
                dataset.value = /* @__PURE__ */ new Set();
                for (const inputValue of input){
                    const valueDataset = this.value["~run"]({
                        value: inputValue
                    }, config2);
                    if (valueDataset.issues) {
                        const pathItem = {
                            type: "set",
                            origin: "value",
                            input,
                            key: null,
                            value: inputValue
                        };
                        for (const issue of valueDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = valueDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!valueDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.add(valueDataset.value);
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/set/setAsync.ts
// @__NO_SIDE_EFFECTS__
function setAsync(value2, message) {
    return {
        kind: "schema",
        type: "set",
        reference: setAsync,
        expects: "Set",
        async: true,
        value: value2,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            const input = dataset.value;
            if (input instanceof Set) {
                dataset.typed = true;
                dataset.value = /* @__PURE__ */ new Set();
                const valueDatasets = await Promise.all([
                    ...input
                ].map(async (inputValue)=>[
                        inputValue,
                        await this.value["~run"]({
                            value: inputValue
                        }, config2)
                    ]));
                for (const [inputValue, valueDataset] of valueDatasets){
                    if (valueDataset.issues) {
                        const pathItem = {
                            type: "set",
                            origin: "value",
                            input,
                            key: null,
                            value: inputValue
                        };
                        for (const issue of valueDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = valueDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!valueDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.add(valueDataset.value);
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/strictObject/strictObject.ts
// @__NO_SIDE_EFFECTS__
function strictObject(entries, message) {
    return {
        kind: "schema",
        type: "strict_object",
        reference: strictObject,
        expects: "Object",
        async: false,
        entries,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                for(const key in this.entries){
                    const valueSchema = this.entries[key];
                    if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && // @ts-expect-error
                    valueSchema.default !== void 0) {
                        const value2 = key in input ? // @ts-expect-error
                        input[key] : getDefault(valueSchema);
                        const valueDataset = valueSchema["~run"]({
                            value: value2
                        }, config2);
                        if (valueDataset.issues) {
                            const pathItem = {
                                type: "object",
                                origin: "value",
                                input,
                                key,
                                value: value2
                            };
                            for (const issue of valueDataset.issues){
                                if (issue.path) {
                                    issue.path.unshift(pathItem);
                                } else {
                                    issue.path = [
                                        pathItem
                                    ];
                                }
                                dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                                dataset.issues = valueDataset.issues;
                            }
                            if (config2.abortEarly) {
                                dataset.typed = false;
                                break;
                            }
                        }
                        if (!valueDataset.typed) {
                            dataset.typed = false;
                        }
                        dataset.value[key] = valueDataset.value;
                    } else if (valueSchema.fallback !== void 0) {
                        dataset.value[key] = getFallback(valueSchema);
                    } else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
                        _addIssue(this, "key", dataset, config2, {
                            input: void 0,
                            expected: `"${key}"`,
                            path: [
                                {
                                    type: "object",
                                    origin: "key",
                                    input,
                                    key,
                                    // @ts-expect-error
                                    value: input[key]
                                }
                            ]
                        });
                        if (config2.abortEarly) {
                            break;
                        }
                    }
                }
                if (!dataset.issues || !config2.abortEarly) {
                    for(const key in input){
                        if (!(key in this.entries)) {
                            _addIssue(this, "key", dataset, config2, {
                                input: key,
                                expected: "never",
                                path: [
                                    {
                                        type: "object",
                                        origin: "key",
                                        input,
                                        key,
                                        // @ts-expect-error
                                        value: input[key]
                                    }
                                ]
                            });
                            break;
                        }
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/strictObject/strictObjectAsync.ts
// @__NO_SIDE_EFFECTS__
function strictObjectAsync(entries, message) {
    return {
        kind: "schema",
        type: "strict_object",
        reference: strictObjectAsync,
        expects: "Object",
        async: true,
        entries,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                const valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema])=>{
                    if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && // @ts-expect-error
                    valueSchema.default !== void 0) {
                        const value2 = key in input ? // @ts-expect-error
                        input[key] : await getDefault(valueSchema);
                        return [
                            key,
                            value2,
                            valueSchema,
                            await valueSchema["~run"]({
                                value: value2
                            }, config2)
                        ];
                    }
                    return [
                        key,
                        // @ts-expect-error
                        input[key],
                        valueSchema,
                        null
                    ];
                }));
                for (const [key, value2, valueSchema, valueDataset] of valueDatasets){
                    if (valueDataset) {
                        if (valueDataset.issues) {
                            const pathItem = {
                                type: "object",
                                origin: "value",
                                input,
                                key,
                                value: value2
                            };
                            for (const issue of valueDataset.issues){
                                if (issue.path) {
                                    issue.path.unshift(pathItem);
                                } else {
                                    issue.path = [
                                        pathItem
                                    ];
                                }
                                dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                                dataset.issues = valueDataset.issues;
                            }
                            if (config2.abortEarly) {
                                dataset.typed = false;
                                break;
                            }
                        }
                        if (!valueDataset.typed) {
                            dataset.typed = false;
                        }
                        dataset.value[key] = valueDataset.value;
                    } else if (valueSchema.fallback !== void 0) {
                        dataset.value[key] = await getFallback(valueSchema);
                    } else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
                        _addIssue(this, "key", dataset, config2, {
                            input: void 0,
                            expected: `"${key}"`,
                            path: [
                                {
                                    type: "object",
                                    origin: "key",
                                    input,
                                    key,
                                    value: value2
                                }
                            ]
                        });
                        if (config2.abortEarly) {
                            break;
                        }
                    }
                }
                if (!dataset.issues || !config2.abortEarly) {
                    for(const key in input){
                        if (!(key in this.entries)) {
                            _addIssue(this, "key", dataset, config2, {
                                input: key,
                                expected: "never",
                                path: [
                                    {
                                        type: "object",
                                        origin: "key",
                                        input,
                                        key,
                                        // @ts-expect-error
                                        value: input[key]
                                    }
                                ]
                            });
                            break;
                        }
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/strictTuple/strictTuple.ts
// @__NO_SIDE_EFFECTS__
function strictTuple(items, message) {
    return {
        kind: "schema",
        type: "strict_tuple",
        reference: strictTuple,
        expects: "Array",
        async: false,
        items,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                for(let key = 0; key < this.items.length; key++){
                    const value2 = input[key];
                    const itemDataset = this.items[key]["~run"]({
                        value: value2
                    }, config2);
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "array",
                            origin: "value",
                            input,
                            key,
                            value: value2
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = itemDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.push(itemDataset.value);
                }
                if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {
                    _addIssue(this, "type", dataset, config2, {
                        input: input[this.items.length],
                        expected: "never",
                        path: [
                            {
                                type: "array",
                                origin: "value",
                                input,
                                key: this.items.length,
                                value: input[this.items.length]
                            }
                        ]
                    });
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/strictTuple/strictTupleAsync.ts
// @__NO_SIDE_EFFECTS__
function strictTupleAsync(items, message) {
    return {
        kind: "schema",
        type: "strict_tuple",
        reference: strictTupleAsync,
        expects: "Array",
        async: true,
        items,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                const itemDatasets = await Promise.all(this.items.map(async (item, key)=>{
                    const value2 = input[key];
                    return [
                        key,
                        value2,
                        await item["~run"]({
                            value: value2
                        }, config2)
                    ];
                }));
                for (const [key, value2, itemDataset] of itemDatasets){
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "array",
                            origin: "value",
                            input,
                            key,
                            value: value2
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = itemDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.push(itemDataset.value);
                }
                if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {
                    _addIssue(this, "type", dataset, config2, {
                        input: input[this.items.length],
                        expected: "never",
                        path: [
                            {
                                type: "array",
                                origin: "value",
                                input,
                                key: this.items.length,
                                value: input[this.items.length]
                            }
                        ]
                    });
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/string/string.ts
// @__NO_SIDE_EFFECTS__
function string(message) {
    return {
        kind: "schema",
        type: "string",
        reference: string,
        expects: "string",
        async: false,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (typeof dataset.value === "string") {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/symbol/symbol.ts
// @__NO_SIDE_EFFECTS__
function symbol(message) {
    return {
        kind: "schema",
        type: "symbol",
        reference: symbol,
        expects: "symbol",
        async: false,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (typeof dataset.value === "symbol") {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/tuple/tuple.ts
// @__NO_SIDE_EFFECTS__
function tuple(items, message) {
    return {
        kind: "schema",
        type: "tuple",
        reference: tuple,
        expects: "Array",
        async: false,
        items,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                for(let key = 0; key < this.items.length; key++){
                    const value2 = input[key];
                    const itemDataset = this.items[key]["~run"]({
                        value: value2
                    }, config2);
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "array",
                            origin: "value",
                            input,
                            key,
                            value: value2
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = itemDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.push(itemDataset.value);
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/tuple/tupleAsync.ts
// @__NO_SIDE_EFFECTS__
function tupleAsync(items, message) {
    return {
        kind: "schema",
        type: "tuple",
        reference: tupleAsync,
        expects: "Array",
        async: true,
        items,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                const itemDatasets = await Promise.all(this.items.map(async (item, key)=>{
                    const value2 = input[key];
                    return [
                        key,
                        value2,
                        await item["~run"]({
                            value: value2
                        }, config2)
                    ];
                }));
                for (const [key, value2, itemDataset] of itemDatasets){
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "array",
                            origin: "value",
                            input,
                            key,
                            value: value2
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = itemDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.push(itemDataset.value);
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/tupleWithRest/tupleWithRest.ts
// @__NO_SIDE_EFFECTS__
function tupleWithRest(items, rest, message) {
    return {
        kind: "schema",
        type: "tuple_with_rest",
        reference: tupleWithRest,
        expects: "Array",
        async: false,
        items,
        rest,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                for(let key = 0; key < this.items.length; key++){
                    const value2 = input[key];
                    const itemDataset = this.items[key]["~run"]({
                        value: value2
                    }, config2);
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "array",
                            origin: "value",
                            input,
                            key,
                            value: value2
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = itemDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.push(itemDataset.value);
                }
                if (!dataset.issues || !config2.abortEarly) {
                    for(let key = this.items.length; key < input.length; key++){
                        const value2 = input[key];
                        const itemDataset = this.rest["~run"]({
                            value: value2
                        }, config2);
                        if (itemDataset.issues) {
                            const pathItem = {
                                type: "array",
                                origin: "value",
                                input,
                                key,
                                value: value2
                            };
                            for (const issue of itemDataset.issues){
                                if (issue.path) {
                                    issue.path.unshift(pathItem);
                                } else {
                                    issue.path = [
                                        pathItem
                                    ];
                                }
                                dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                                dataset.issues = itemDataset.issues;
                            }
                            if (config2.abortEarly) {
                                dataset.typed = false;
                                break;
                            }
                        }
                        if (!itemDataset.typed) {
                            dataset.typed = false;
                        }
                        dataset.value.push(itemDataset.value);
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/tupleWithRest/tupleWithRestAsync.ts
// @__NO_SIDE_EFFECTS__
function tupleWithRestAsync(items, rest, message) {
    return {
        kind: "schema",
        type: "tuple_with_rest",
        reference: tupleWithRestAsync,
        expects: "Array",
        async: true,
        items,
        rest,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                const [normalDatasets, restDatasets] = await Promise.all([
                    // Parse schema of each normal item
                    Promise.all(this.items.map(async (item, key)=>{
                        const value2 = input[key];
                        return [
                            key,
                            value2,
                            await item["~run"]({
                                value: value2
                            }, config2)
                        ];
                    })),
                    // Parse other items with rest schema
                    Promise.all(input.slice(this.items.length).map(async (value2, key)=>{
                        return [
                            key + this.items.length,
                            value2,
                            await this.rest["~run"]({
                                value: value2
                            }, config2)
                        ];
                    }))
                ]);
                for (const [key, value2, itemDataset] of normalDatasets){
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "array",
                            origin: "value",
                            input,
                            key,
                            value: value2
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = itemDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.push(itemDataset.value);
                }
                if (!dataset.issues || !config2.abortEarly) {
                    for (const [key, value2, itemDataset] of restDatasets){
                        if (itemDataset.issues) {
                            const pathItem = {
                                type: "array",
                                origin: "value",
                                input,
                                key,
                                value: value2
                            };
                            for (const issue of itemDataset.issues){
                                if (issue.path) {
                                    issue.path.unshift(pathItem);
                                } else {
                                    issue.path = [
                                        pathItem
                                    ];
                                }
                                dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                                dataset.issues = itemDataset.issues;
                            }
                            if (config2.abortEarly) {
                                dataset.typed = false;
                                break;
                            }
                        }
                        if (!itemDataset.typed) {
                            dataset.typed = false;
                        }
                        dataset.value.push(itemDataset.value);
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/undefined/undefined.ts
// @__NO_SIDE_EFFECTS__
function undefined_(message) {
    return {
        kind: "schema",
        type: "undefined",
        reference: undefined_,
        expects: "undefined",
        async: false,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (dataset.value === void 0) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/undefinedable/undefinedable.ts
// @__NO_SIDE_EFFECTS__
function undefinedable(wrapped, default_) {
    return {
        kind: "schema",
        type: "undefinedable",
        reference: undefinedable,
        expects: `(${wrapped.expects} | undefined)`,
        async: false,
        wrapped,
        default: default_,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (dataset.value === void 0) {
                if (this.default !== void 0) {
                    dataset.value = getDefault(this, dataset, config2);
                }
                if (dataset.value === void 0) {
                    dataset.typed = true;
                    return dataset;
                }
            }
            return this.wrapped["~run"](dataset, config2);
        }
    };
}
// src/schemas/undefinedable/undefinedableAsync.ts
// @__NO_SIDE_EFFECTS__
function undefinedableAsync(wrapped, default_) {
    return {
        kind: "schema",
        type: "undefinedable",
        reference: undefinedableAsync,
        expects: `(${wrapped.expects} | undefined)`,
        async: true,
        wrapped,
        default: default_,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            if (dataset.value === void 0) {
                if (this.default !== void 0) {
                    dataset.value = await getDefault(this, dataset, config2);
                }
                if (dataset.value === void 0) {
                    dataset.typed = true;
                    return dataset;
                }
            }
            return this.wrapped["~run"](dataset, config2);
        }
    };
}
// src/schemas/union/utils/_subIssues/_subIssues.ts
// @__NO_SIDE_EFFECTS__
function _subIssues(datasets) {
    let issues;
    if (datasets) {
        for (const dataset of datasets){
            if (issues) {
                issues.push(...dataset.issues);
            } else {
                issues = dataset.issues;
            }
        }
    }
    return issues;
}
// src/schemas/union/union.ts
// @__NO_SIDE_EFFECTS__
function union(options, message) {
    return {
        kind: "schema",
        type: "union",
        reference: union,
        expects: _joinExpects(options.map((option)=>option.expects), "|"),
        async: false,
        options,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            let validDataset;
            let typedDatasets;
            let untypedDatasets;
            for (const schema of this.options){
                const optionDataset = schema["~run"]({
                    value: dataset.value
                }, config2);
                if (optionDataset.typed) {
                    if (optionDataset.issues) {
                        if (typedDatasets) {
                            typedDatasets.push(optionDataset);
                        } else {
                            typedDatasets = [
                                optionDataset
                            ];
                        }
                    } else {
                        validDataset = optionDataset;
                        break;
                    }
                } else {
                    if (untypedDatasets) {
                        untypedDatasets.push(optionDataset);
                    } else {
                        untypedDatasets = [
                            optionDataset
                        ];
                    }
                }
            }
            if (validDataset) {
                return validDataset;
            }
            if (typedDatasets) {
                if (typedDatasets.length === 1) {
                    return typedDatasets[0];
                }
                _addIssue(this, "type", dataset, config2, {
                    issues: _subIssues(typedDatasets)
                });
                dataset.typed = true;
            } else if (untypedDatasets?.length === 1) {
                return untypedDatasets[0];
            } else {
                _addIssue(this, "type", dataset, config2, {
                    issues: _subIssues(untypedDatasets)
                });
            }
            return dataset;
        }
    };
}
// src/schemas/union/unionAsync.ts
// @__NO_SIDE_EFFECTS__
function unionAsync(options, message) {
    return {
        kind: "schema",
        type: "union",
        reference: unionAsync,
        expects: _joinExpects(options.map((option)=>option.expects), "|"),
        async: true,
        options,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            let validDataset;
            let typedDatasets;
            let untypedDatasets;
            for (const schema of this.options){
                const optionDataset = await schema["~run"]({
                    value: dataset.value
                }, config2);
                if (optionDataset.typed) {
                    if (optionDataset.issues) {
                        if (typedDatasets) {
                            typedDatasets.push(optionDataset);
                        } else {
                            typedDatasets = [
                                optionDataset
                            ];
                        }
                    } else {
                        validDataset = optionDataset;
                        break;
                    }
                } else {
                    if (untypedDatasets) {
                        untypedDatasets.push(optionDataset);
                    } else {
                        untypedDatasets = [
                            optionDataset
                        ];
                    }
                }
            }
            if (validDataset) {
                return validDataset;
            }
            if (typedDatasets) {
                if (typedDatasets.length === 1) {
                    return typedDatasets[0];
                }
                _addIssue(this, "type", dataset, config2, {
                    issues: _subIssues(typedDatasets)
                });
                dataset.typed = true;
            } else if (untypedDatasets?.length === 1) {
                return untypedDatasets[0];
            } else {
                _addIssue(this, "type", dataset, config2, {
                    issues: _subIssues(untypedDatasets)
                });
            }
            return dataset;
        }
    };
}
// src/schemas/unknown/unknown.ts
// @__NO_SIDE_EFFECTS__
function unknown() {
    return {
        kind: "schema",
        type: "unknown",
        reference: unknown,
        expects: "unknown",
        async: false,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset) {
            dataset.typed = true;
            return dataset;
        }
    };
}
// src/schemas/variant/variant.ts
// @__NO_SIDE_EFFECTS__
function variant(key, options, message) {
    return {
        kind: "schema",
        type: "variant",
        reference: variant,
        expects: "Object",
        async: false,
        key,
        options,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                let outputDataset;
                let maxDiscriminatorPriority = 0;
                let invalidDiscriminatorKey = this.key;
                let expectedDiscriminators = [];
                const parseOptions = (variant2, allKeys)=>{
                    for (const schema of variant2.options){
                        if (schema.type === "variant") {
                            parseOptions(schema, new Set(allKeys).add(schema.key));
                        } else {
                            let keysAreValid = true;
                            let currentPriority = 0;
                            for (const currentKey of allKeys){
                                const discriminatorSchema = schema.entries[currentKey];
                                if (currentKey in input ? discriminatorSchema["~run"](// @ts-expect-error
                                {
                                    typed: false,
                                    value: input[currentKey]
                                }, config2).issues : discriminatorSchema.type !== "exact_optional" && discriminatorSchema.type !== "optional" && discriminatorSchema.type !== "nullish") {
                                    keysAreValid = false;
                                    if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {
                                        maxDiscriminatorPriority = currentPriority;
                                        invalidDiscriminatorKey = currentKey;
                                        expectedDiscriminators = [];
                                    }
                                    if (invalidDiscriminatorKey === currentKey) {
                                        expectedDiscriminators.push(schema.entries[currentKey].expects);
                                    }
                                    break;
                                }
                                currentPriority++;
                            }
                            if (keysAreValid) {
                                const optionDataset = schema["~run"]({
                                    value: input
                                }, config2);
                                if (!outputDataset || !outputDataset.typed && optionDataset.typed) {
                                    outputDataset = optionDataset;
                                }
                            }
                        }
                        if (outputDataset && !outputDataset.issues) {
                            break;
                        }
                    }
                };
                parseOptions(this, /* @__PURE__ */ new Set([
                    this.key
                ]));
                if (outputDataset) {
                    return outputDataset;
                }
                _addIssue(this, "type", dataset, config2, {
                    // @ts-expect-error
                    input: input[invalidDiscriminatorKey],
                    expected: _joinExpects(expectedDiscriminators, "|"),
                    path: [
                        {
                            type: "object",
                            origin: "value",
                            input,
                            key: invalidDiscriminatorKey,
                            // @ts-expect-error
                            value: input[invalidDiscriminatorKey]
                        }
                    ]
                });
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/variant/variantAsync.ts
// @__NO_SIDE_EFFECTS__
function variantAsync(key, options, message) {
    return {
        kind: "schema",
        type: "variant",
        reference: variantAsync,
        expects: "Object",
        async: true,
        key,
        options,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                let outputDataset;
                let maxDiscriminatorPriority = 0;
                let invalidDiscriminatorKey = this.key;
                let expectedDiscriminators = [];
                const parseOptions = async (variant2, allKeys)=>{
                    for (const schema of variant2.options){
                        if (schema.type === "variant") {
                            await parseOptions(schema, new Set(allKeys).add(schema.key));
                        } else {
                            let keysAreValid = true;
                            let currentPriority = 0;
                            for (const currentKey of allKeys){
                                const discriminatorSchema = schema.entries[currentKey];
                                if (currentKey in input ? (await discriminatorSchema["~run"](// @ts-expect-error
                                {
                                    typed: false,
                                    value: input[currentKey]
                                }, config2)).issues : discriminatorSchema.type !== "exact_optional" && discriminatorSchema.type !== "optional" && discriminatorSchema.type !== "nullish") {
                                    keysAreValid = false;
                                    if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {
                                        maxDiscriminatorPriority = currentPriority;
                                        invalidDiscriminatorKey = currentKey;
                                        expectedDiscriminators = [];
                                    }
                                    if (invalidDiscriminatorKey === currentKey) {
                                        expectedDiscriminators.push(schema.entries[currentKey].expects);
                                    }
                                    break;
                                }
                                currentPriority++;
                            }
                            if (keysAreValid) {
                                const optionDataset = await schema["~run"]({
                                    value: input
                                }, config2);
                                if (!outputDataset || !outputDataset.typed && optionDataset.typed) {
                                    outputDataset = optionDataset;
                                }
                            }
                        }
                        if (outputDataset && !outputDataset.issues) {
                            break;
                        }
                    }
                };
                await parseOptions(this, /* @__PURE__ */ new Set([
                    this.key
                ]));
                if (outputDataset) {
                    return outputDataset;
                }
                _addIssue(this, "type", dataset, config2, {
                    // @ts-expect-error
                    input: input[invalidDiscriminatorKey],
                    expected: _joinExpects(expectedDiscriminators, "|"),
                    path: [
                        {
                            type: "object",
                            origin: "value",
                            input,
                            key: invalidDiscriminatorKey,
                            // @ts-expect-error
                            value: input[invalidDiscriminatorKey]
                        }
                    ]
                });
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/void/void.ts
// @__NO_SIDE_EFFECTS__
function void_(message) {
    return {
        kind: "schema",
        type: "void",
        reference: void_,
        expects: "void",
        async: false,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (dataset.value === void 0) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/methods/keyof/keyof.ts
// @__NO_SIDE_EFFECTS__
function keyof(schema, message) {
    return picklist(Object.keys(schema.entries), message);
}
// src/methods/omit/omit.ts
// @__NO_SIDE_EFFECTS__
function omit(schema, keys) {
    const entries = {
        ...schema.entries
    };
    for (const key of keys){
        delete entries[key];
    }
    return {
        ...schema,
        entries,
        get "~standard" () {
            return _getStandardProps(this);
        }
    };
}
// src/methods/parse/parse.ts
function parse(schema, input, config2) {
    const dataset = schema["~run"]({
        value: input
    }, getGlobalConfig(config2));
    if (dataset.issues) {
        throw new ValiError(dataset.issues);
    }
    return dataset.value;
}
// src/methods/parse/parseAsync.ts
async function parseAsync(schema, input, config2) {
    const dataset = await schema["~run"]({
        value: input
    }, getGlobalConfig(config2));
    if (dataset.issues) {
        throw new ValiError(dataset.issues);
    }
    return dataset.value;
}
// src/methods/parser/parser.ts
// @__NO_SIDE_EFFECTS__
function parser(schema, config2) {
    const func = (input)=>parse(schema, input, config2);
    func.schema = schema;
    func.config = config2;
    return func;
}
// src/methods/parser/parserAsync.ts
// @__NO_SIDE_EFFECTS__
function parserAsync(schema, config2) {
    const func = (input)=>parseAsync(schema, input, config2);
    func.schema = schema;
    func.config = config2;
    return func;
}
// src/methods/partial/partial.ts
// @__NO_SIDE_EFFECTS__
function partial(schema, keys) {
    const entries = {};
    for(const key in schema.entries){
        entries[key] = !keys || keys.includes(key) ? optional(schema.entries[key]) : schema.entries[key];
    }
    return {
        ...schema,
        entries,
        get "~standard" () {
            return _getStandardProps(this);
        }
    };
}
// src/methods/partial/partialAsync.ts
// @__NO_SIDE_EFFECTS__
function partialAsync(schema, keys) {
    const entries = {};
    for(const key in schema.entries){
        entries[key] = !keys || keys.includes(key) ? optionalAsync(schema.entries[key]) : schema.entries[key];
    }
    return {
        ...schema,
        entries,
        get "~standard" () {
            return _getStandardProps(this);
        }
    };
}
// src/methods/pick/pick.ts
// @__NO_SIDE_EFFECTS__
function pick(schema, keys) {
    const entries = {};
    for (const key of keys){
        entries[key] = schema.entries[key];
    }
    return {
        ...schema,
        entries,
        get "~standard" () {
            return _getStandardProps(this);
        }
    };
}
// src/methods/pipe/pipe.ts
// @__NO_SIDE_EFFECTS__
function pipe(...pipe2) {
    return {
        ...pipe2[0],
        pipe: pipe2,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            for (const item of pipe2){
                if (item.kind !== "metadata") {
                    if (dataset.issues && (item.kind === "schema" || item.kind === "transformation")) {
                        dataset.typed = false;
                        break;
                    }
                    if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {
                        dataset = item["~run"](dataset, config2);
                    }
                }
            }
            return dataset;
        }
    };
}
// src/methods/pipe/pipeAsync.ts
// @__NO_SIDE_EFFECTS__
function pipeAsync(...pipe2) {
    return {
        ...pipe2[0],
        pipe: pipe2,
        async: true,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            for (const item of pipe2){
                if (item.kind !== "metadata") {
                    if (dataset.issues && (item.kind === "schema" || item.kind === "transformation")) {
                        dataset.typed = false;
                        break;
                    }
                    if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {
                        dataset = await item["~run"](dataset, config2);
                    }
                }
            }
            return dataset;
        }
    };
}
// src/methods/required/required.ts
// @__NO_SIDE_EFFECTS__
function required(schema, arg2, arg3) {
    const keys = Array.isArray(arg2) ? arg2 : void 0;
    const message = Array.isArray(arg2) ? arg3 : arg2;
    const entries = {};
    for(const key in schema.entries){
        entries[key] = !keys || keys.includes(key) ? nonOptional(schema.entries[key], message) : schema.entries[key];
    }
    return {
        ...schema,
        entries,
        get "~standard" () {
            return _getStandardProps(this);
        }
    };
}
// src/methods/required/requiredAsync.ts
// @__NO_SIDE_EFFECTS__
function requiredAsync(schema, arg2, arg3) {
    const keys = Array.isArray(arg2) ? arg2 : void 0;
    const message = Array.isArray(arg2) ? arg3 : arg2;
    const entries = {};
    for(const key in schema.entries){
        entries[key] = !keys || keys.includes(key) ? nonOptionalAsync(schema.entries[key], message) : schema.entries[key];
    }
    return {
        ...schema,
        entries,
        get "~standard" () {
            return _getStandardProps(this);
        }
    };
}
// src/methods/safeParse/safeParse.ts
// @__NO_SIDE_EFFECTS__
function safeParse(schema, input, config2) {
    const dataset = schema["~run"]({
        value: input
    }, getGlobalConfig(config2));
    return {
        typed: dataset.typed,
        success: !dataset.issues,
        output: dataset.value,
        issues: dataset.issues
    };
}
// src/methods/safeParse/safeParseAsync.ts
// @__NO_SIDE_EFFECTS__
async function safeParseAsync(schema, input, config2) {
    const dataset = await schema["~run"]({
        value: input
    }, getGlobalConfig(config2));
    return {
        typed: dataset.typed,
        success: !dataset.issues,
        output: dataset.value,
        issues: dataset.issues
    };
}
// src/methods/safeParser/safeParser.ts
// @__NO_SIDE_EFFECTS__
function safeParser(schema, config2) {
    const func = (input)=>safeParse(schema, input, config2);
    func.schema = schema;
    func.config = config2;
    return func;
}
// src/methods/safeParser/safeParserAsync.ts
// @__NO_SIDE_EFFECTS__
function safeParserAsync(schema, config2) {
    const func = (input)=>safeParseAsync(schema, input, config2);
    func.schema = schema;
    func.config = config2;
    return func;
}
// src/methods/unwrap/unwrap.ts
// @__NO_SIDE_EFFECTS__
function unwrap(schema) {
    return schema.wrapped;
}
;
}}),
"[project]/node_modules/@sanity/visual-editing-csm/dist/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createDataAttribute": (()=>createDataAttribute),
    "decodeSanityNodeData": (()=>decodeSanityNodeData),
    "encodeSanityNodeData": (()=>encodeSanityNodeData),
    "pathToUrlString": (()=>pathToUrlString),
    "urlStringToPath": (()=>urlStringToPath)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/client/dist/_chunks-es/resolveEditInfo.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/valibot/dist/index.js [app-ssr] (ecmascript)");
;
;
const lengthyStr$1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pipe"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["string"])(), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["minLength"])(1)), optionalLengthyStr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["optional"])(lengthyStr$1), sanityNodeSchema = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["object"])({
    baseUrl: lengthyStr$1,
    dataset: optionalLengthyStr,
    id: lengthyStr$1,
    path: lengthyStr$1,
    projectId: optionalLengthyStr,
    tool: optionalLengthyStr,
    type: optionalLengthyStr,
    workspace: optionalLengthyStr
});
function isValidSanityNode(node) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["is"])(sanityNodeSchema, node);
}
function isArray(value) {
    return value !== null && Array.isArray(value);
}
function pathToUrlString(path) {
    let str = "";
    for (const segment of path){
        if (typeof segment == "string") {
            str && (str += "."), str += segment;
            continue;
        }
        if (typeof segment == "number") {
            str && (str += ":"), str += `${segment}`;
            continue;
        }
        if (isArray(segment)) {
            str && (str += ":"), str += `${segment.join(",")}}`;
            continue;
        }
        if (segment._key) {
            str && (str += ":"), str += `${segment._key}`;
            continue;
        }
    }
    return str;
}
function encodeSanityNodeData(node) {
    const { id: _id, path, baseUrl, tool, workspace, type } = node;
    return isValidSanityNode(node) ? [
        [
            "id",
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getPublishedId"])(_id)
        ],
        [
            "type",
            type
        ],
        [
            "path",
            pathToUrlString(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["studioPath"].fromString(path))
        ],
        [
            "base",
            encodeURIComponent(baseUrl)
        ],
        [
            "workspace",
            workspace
        ],
        [
            "tool",
            tool
        ]
    ].filter(([, value])=>!!value).map((part)=>part.join("=")).join(";") : void 0;
}
function createDataAttribute(props) {
    function normalizePath(path) {
        return path ? typeof path == "string" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["studioPath"].fromString(path) : path : [];
    }
    function toString(props2) {
        if (!props2.id) throw new Error("`id` is required to create a data attribute");
        if (!props2.type) throw new Error("`type` is required to create a data attribute");
        if (!props2.path || !props2.path.length) throw new Error("`path` is required to create a data attribute");
        const attrs = {
            baseUrl: props2.baseUrl || "/",
            workspace: props2.workspace,
            tool: props2.tool,
            type: props2.type,
            id: props2.id,
            path: typeof props2.path == "string" ? props2.path : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["studioPath"].toString(props2.path)
        };
        return encodeSanityNodeData(attrs);
    }
    const DataAttribute = (path)=>toString({
            ...props,
            path: [
                ...normalizePath(props.path),
                ...normalizePath(path)
            ]
        });
    return DataAttribute.toString = function() {
        return toString(props);
    }, DataAttribute.combine = function(attrs) {
        return createDataAttribute({
            ...props,
            ...attrs
        });
    }, DataAttribute.scope = function(path) {
        return createDataAttribute({
            ...props,
            path: [
                ...normalizePath(props.path),
                ...normalizePath(path)
            ]
        });
    }, DataAttribute;
}
const RE_SEGMENT_WITH_INDEX = /^([\w-]+):(0|[1-9][0-9]*)$/, RE_SEGMENT_WITH_TUPLE = /^([\w-]+):([0-9]+),([0-9]+)$/, RE_SEGMENT_WITH_KEY = /^([\w-]+):([\w-]+)$/;
function urlStringToPath(str) {
    const path = [];
    for (const segment of str.split(".")){
        const withIndex = RE_SEGMENT_WITH_INDEX.exec(segment);
        if (withIndex) {
            path.push(withIndex[1], Number(withIndex[2]));
            continue;
        }
        const withTuple = RE_SEGMENT_WITH_TUPLE.exec(segment);
        if (withTuple) {
            path.push(withTuple[1], [
                Number(withTuple[2]),
                Number(withTuple[3])
            ]);
            continue;
        }
        const withKey = RE_SEGMENT_WITH_KEY.exec(segment);
        if (withKey) {
            path.push(withKey[1], {
                _key: withKey[2]
            });
            continue;
        }
        path.push(segment);
    }
    return path;
}
const lengthyStr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pipe"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["string"])(), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["minLength"])(1)), sanityLegacyNodeSchema = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["object"])({
    origin: lengthyStr,
    href: lengthyStr,
    data: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["optional"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["record"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["string"])(), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unknown"])()))
});
function decodeSanityString(str) {
    const data = str.split(";").reduce((acc, segment)=>{
        const [key, value] = segment.split("=");
        if (!key || segment.includes("=") && !value) return acc;
        switch(key){
            case "id":
                acc.id = value;
                break;
            case "type":
                acc.type = value;
                break;
            case "path":
                acc.path = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["studioPath"].toString(urlStringToPath(value));
                break;
            case "base":
                acc.baseUrl = decodeURIComponent(value);
                break;
            case "tool":
                acc.tool = value;
                break;
            case "workspace":
                acc.workspace = value;
                break;
            case "projectId":
                acc.projectId = value;
                break;
            case "dataset":
                acc.dataset = value;
                break;
        }
        return acc;
    }, {});
    if (isValidSanityNode(data)) return data;
}
function decodeSanityObject(data) {
    const sanityNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["safeParse"])(sanityNodeSchema, data);
    if (sanityNode.success) return sanityNode.output;
    const sanityLegacyNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["safeParse"])(sanityLegacyNodeSchema, data);
    if (sanityLegacyNode.success) try {
        const url = new URL(sanityLegacyNode.output.href, typeof document > "u" ? "https://example.com" : location.origin);
        return url.searchParams.size > 0 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"])(sanityNodeSchema, Object.fromEntries(url.searchParams.entries())) : sanityLegacyNode.output;
    } catch (err) {
        return console.error("Failed to parse sanity node", err), sanityLegacyNode.output;
    }
}
function decodeSanityNodeData(data) {
    if (typeof data == "object" && data !== null) return decodeSanityObject(data);
    try {
        const obj = JSON.parse(data);
        return decodeSanityObject(obj);
    } catch  {
        return decodeSanityString(data);
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/react-compiler-runtime/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @lightSyntaxTransform
 * @noflow
 * @nolint
 * @preventMunge
 * @preserve-invariant-messages
 */ "use no memo";
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
// src/index.ts
var index_exports = {};
__export(index_exports, {
    $dispatcherGuard: ()=>$dispatcherGuard,
    $makeReadOnly: ()=>$makeReadOnly,
    $reset: ()=>$reset,
    $structuralCheck: ()=>$structuralCheck,
    c: ()=>c,
    clearRenderCounterRegistry: ()=>clearRenderCounterRegistry,
    renderCounterRegistry: ()=>renderCounterRegistry,
    useRenderCounter: ()=>useRenderCounter
});
module.exports = __toCommonJS(index_exports);
var React = __toESM(__turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"));
var { useRef, useEffect, isValidElement } = React;
var _a;
var ReactSecretInternals = //@ts-ignore
(_a = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE) != null ? _a : React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
var $empty = Symbol.for("react.memo_cache_sentinel");
var _a2;
var c = // @ts-expect-error
typeof ((_a2 = React.__COMPILER_RUNTIME) == null ? void 0 : _a2.c) === "function" ? // @ts-expect-error
React.__COMPILER_RUNTIME.c : function c2(size) {
    return React.useMemo(()=>{
        const $ = new Array(size);
        for(let ii = 0; ii < size; ii++){
            $[ii] = $empty;
        }
        $[$empty] = true;
        return $;
    }, []);
};
var LazyGuardDispatcher = {};
[
    "readContext",
    "useCallback",
    "useContext",
    "useEffect",
    "useImperativeHandle",
    "useInsertionEffect",
    "useLayoutEffect",
    "useMemo",
    "useReducer",
    "useRef",
    "useState",
    "useDebugValue",
    "useDeferredValue",
    "useTransition",
    "useMutableSource",
    "useSyncExternalStore",
    "useId",
    "unstable_isNewReconciler",
    "getCacheSignal",
    "getCacheForType",
    "useCacheRefresh"
].forEach((name)=>{
    LazyGuardDispatcher[name] = ()=>{
        throw new Error(`[React] Unexpected React hook call (${name}) from a React compiled function. Check that all hooks are called directly and named according to convention ('use[A-Z]') `);
    };
});
var originalDispatcher = null;
LazyGuardDispatcher["useMemoCache"] = (count)=>{
    if (originalDispatcher == null) {
        throw new Error("React Compiler internal invariant violation: unexpected null dispatcher");
    } else {
        return originalDispatcher.useMemoCache(count);
    }
};
function setCurrent(newDispatcher) {
    ReactSecretInternals.ReactCurrentDispatcher.current = newDispatcher;
    return ReactSecretInternals.ReactCurrentDispatcher.current;
}
var guardFrames = [];
function $dispatcherGuard(kind) {
    const curr = ReactSecretInternals.ReactCurrentDispatcher.current;
    if (kind === 0 /* PushGuardContext */ ) {
        guardFrames.push(curr);
        if (guardFrames.length === 1) {
            originalDispatcher = curr;
        }
        if (curr === LazyGuardDispatcher) {
            throw new Error(`[React] Unexpected call to custom hook or component from a React compiled function. Check that (1) all hooks are called directly and named according to convention ('use[A-Z]') and (2) components are returned as JSX instead of being directly invoked.`);
        }
        setCurrent(LazyGuardDispatcher);
    } else if (kind === 1 /* PopGuardContext */ ) {
        const lastFrame = guardFrames.pop();
        if (lastFrame == null) {
            throw new Error("React Compiler internal error: unexpected null in guard stack");
        }
        if (guardFrames.length === 0) {
            originalDispatcher = null;
        }
        setCurrent(lastFrame);
    } else if (kind === 2 /* PushExpectHook */ ) {
        guardFrames.push(curr);
        setCurrent(originalDispatcher);
    } else if (kind === 3 /* PopExpectHook */ ) {
        const lastFrame = guardFrames.pop();
        if (lastFrame == null) {
            throw new Error("React Compiler internal error: unexpected null in guard stack");
        }
        setCurrent(lastFrame);
    } else {
        throw new Error("React Compiler internal error: unreachable block" + kind);
    }
}
function $reset($) {
    for(let ii = 0; ii < $.length; ii++){
        $[ii] = $empty;
    }
}
function $makeReadOnly() {
    throw new Error("TODO: implement $makeReadOnly in react-compiler-runtime");
}
var renderCounterRegistry = /* @__PURE__ */ new Map();
function clearRenderCounterRegistry() {
    for (const counters of renderCounterRegistry.values()){
        counters.forEach((counter)=>{
            counter.count = 0;
        });
    }
}
function registerRenderCounter(name, val) {
    let counters = renderCounterRegistry.get(name);
    if (counters == null) {
        counters = /* @__PURE__ */ new Set();
        renderCounterRegistry.set(name, counters);
    }
    counters.add(val);
}
function removeRenderCounter(name, val) {
    const counters = renderCounterRegistry.get(name);
    if (counters == null) {
        return;
    }
    counters.delete(val);
}
function useRenderCounter(name) {
    const val = useRef(null);
    if (val.current != null) {
        val.current.count += 1;
    }
    useEffect(()=>{
        if (val.current == null) {
            const counter = {
                count: 0
            };
            registerRenderCounter(name, counter);
            val.current = counter;
        }
        return ()=>{
            if (val.current !== null) {
                removeRenderCounter(name, val.current);
            }
        };
    });
}
var seenErrors = /* @__PURE__ */ new Set();
function $structuralCheck(oldValue, newValue, variableName, fnName, kind, loc) {
    function error(l, r, path, depth) {
        const str = `${fnName}:${loc} [${kind}] ${variableName}${path} changed from ${l} to ${r} at depth ${depth}`;
        if (seenErrors.has(str)) {
            return;
        }
        seenErrors.add(str);
        console.error(str);
    }
    const depthLimit = 2;
    function recur(oldValue2, newValue2, path, depth) {
        if (depth > depthLimit) {
            return;
        } else if (oldValue2 === newValue2) {
            return;
        } else if (typeof oldValue2 !== typeof newValue2) {
            error(`type ${typeof oldValue2}`, `type ${typeof newValue2}`, path, depth);
        } else if (typeof oldValue2 === "object") {
            const oldArray = Array.isArray(oldValue2);
            const newArray = Array.isArray(newValue2);
            if (oldValue2 === null && newValue2 !== null) {
                error("null", `type ${typeof newValue2}`, path, depth);
            } else if (newValue2 === null) {
                error(`type ${typeof oldValue2}`, "null", path, depth);
            } else if (oldValue2 instanceof Map) {
                if (!(newValue2 instanceof Map)) {
                    error(`Map instance`, `other value`, path, depth);
                } else if (oldValue2.size !== newValue2.size) {
                    error(`Map instance with size ${oldValue2.size}`, `Map instance with size ${newValue2.size}`, path, depth);
                } else {
                    for (const [k, v] of oldValue2){
                        if (!newValue2.has(k)) {
                            error(`Map instance with key ${k}`, `Map instance without key ${k}`, path, depth);
                        } else {
                            recur(v, newValue2.get(k), `${path}.get(${k})`, depth + 1);
                        }
                    }
                }
            } else if (newValue2 instanceof Map) {
                error("other value", `Map instance`, path, depth);
            } else if (oldValue2 instanceof Set) {
                if (!(newValue2 instanceof Set)) {
                    error(`Set instance`, `other value`, path, depth);
                } else if (oldValue2.size !== newValue2.size) {
                    error(`Set instance with size ${oldValue2.size}`, `Set instance with size ${newValue2.size}`, path, depth);
                } else {
                    for (const v of newValue2){
                        if (!oldValue2.has(v)) {
                            error(`Set instance without element ${v}`, `Set instance with element ${v}`, path, depth);
                        }
                    }
                }
            } else if (newValue2 instanceof Set) {
                error("other value", `Set instance`, path, depth);
            } else if (oldArray || newArray) {
                if (oldArray !== newArray) {
                    error(`type ${oldArray ? "array" : "object"}`, `type ${newArray ? "array" : "object"}`, path, depth);
                } else if (oldValue2.length !== newValue2.length) {
                    error(`array with length ${oldValue2.length}`, `array with length ${newValue2.length}`, path, depth);
                } else {
                    for(let ii = 0; ii < oldValue2.length; ii++){
                        recur(oldValue2[ii], newValue2[ii], `${path}[${ii}]`, depth + 1);
                    }
                }
            } else if (isValidElement(oldValue2) || isValidElement(newValue2)) {
                if (isValidElement(oldValue2) !== isValidElement(newValue2)) {
                    error(`type ${isValidElement(oldValue2) ? "React element" : "object"}`, `type ${isValidElement(newValue2) ? "React element" : "object"}`, path, depth);
                } else if (oldValue2.type !== newValue2.type) {
                    error(`React element of type ${oldValue2.type}`, `React element of type ${newValue2.type}`, path, depth);
                } else {
                    recur(oldValue2.props, newValue2.props, `[props of ${path}]`, depth + 1);
                }
            } else {
                for(const key in newValue2){
                    if (!(key in oldValue2)) {
                        error(`object without key ${key}`, `object with key ${key}`, path, depth);
                    }
                }
                for(const key in oldValue2){
                    if (!(key in newValue2)) {
                        error(`object with key ${key}`, `object without key ${key}`, path, depth);
                    } else {
                        recur(oldValue2[key], newValue2[key], `${path}.${key}`, depth + 1);
                    }
                }
            }
        } else if (typeof oldValue2 === "function") {
            return;
        } else if (isNaN(oldValue2) || isNaN(newValue2)) {
            if (isNaN(oldValue2) !== isNaN(newValue2)) {
                error(`${isNaN(oldValue2) ? "NaN" : "non-NaN value"}`, `${isNaN(newValue2) ? "NaN" : "non-NaN value"}`, path, depth);
            }
        } else if (oldValue2 !== newValue2) {
            error(oldValue2, newValue2, path, depth);
        }
    }
    recur(oldValue, newValue, "", 0);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    $dispatcherGuard,
    $makeReadOnly,
    $reset,
    $structuralCheck,
    c,
    clearRenderCounterRegistry,
    renderCounterRegistry,
    useRenderCounter
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/next-sanity/node_modules/@sanity/visual-editing/dist/_chunks-es/context.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "actor": (()=>actor),
    "emptyActor": (()=>emptyActor),
    "isEmptyActor": (()=>isEmptyActor),
    "listeners": (()=>listeners),
    "setActor": (()=>setActor)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$actors$2f$dist$2f$xstate$2d$actors$2e$development$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/xstate/actors/dist/xstate-actors.development.esm.js [app-ssr] (ecmascript)");
;
const emptyActor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$actors$2f$dist$2f$xstate$2d$actors$2e$development$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createEmptyActor"])();
let actor = emptyActor;
const listeners = /* @__PURE__ */ new Set();
function isEmptyActor(actor2) {
    return actor2 === emptyActor;
}
function setActor(nextActor) {
    actor = nextActor;
    for (const onActorChange of listeners)onActorChange();
}
;
 //# sourceMappingURL=context.js.map
}}),
"[project]/node_modules/next-sanity/node_modules/@sanity/mutate/dist/_chunks-es/parse.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "parse": (()=>parse)
});
function parse(path) {
    return path.split(/[[.\]]/g).filter(Boolean).map((seg)=>seg.includes("==") ? parseSegment(seg) : coerce(seg));
}
const IS_NUMERIC = /^-?\d+$/;
function unquote(str) {
    return str.replace(/^['"]/, "").replace(/['"]$/, "");
}
function parseSegment(segment) {
    const [key, value] = segment.split("==");
    if (key !== "_key") throw new Error(`Currently only "_key" is supported as path segment. Found ${key}`);
    if (typeof value > "u") throw new Error('Invalid path segment, expected `key=="value"`');
    return {
        _key: unquote(value)
    };
}
function coerce(segment) {
    return IS_NUMERIC.test(segment) ? Number(segment) : segment;
}
;
 //# sourceMappingURL=parse.js.map
}}),
"[project]/node_modules/next-sanity/node_modules/@sanity/mutate/dist/_chunks-es/stringify.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "isArrayElement": (()=>isArrayElement),
    "isElementEqual": (()=>isElementEqual),
    "isEqual": (()=>isEqual),
    "isIndexElement": (()=>isIndexElement),
    "isKeyElement": (()=>isKeyElement),
    "isKeyedElement": (()=>isKeyedElement),
    "isPropertyElement": (()=>isPropertyElement),
    "startsWith": (()=>startsWith),
    "stringify": (()=>stringify)
});
function safeGetElementAt(array, index) {
    if (index < 0 || index >= array.length) throw new Error("Index out of bounds");
    return array[index];
}
function startsWith(parentPath, path) {
    return parentPath.length <= path.length && parentPath.every((segment, i)=>isElementEqual(segment, safeGetElementAt(path, i)));
}
function isEqual(path, otherPath) {
    return path.length === otherPath.length && path.every((segment, i)=>isElementEqual(segment, safeGetElementAt(path, i)));
}
function isElementEqual(segmentA, segmentB) {
    return isKeyElement(segmentA) && isKeyElement(segmentB) ? segmentA._key === segmentB._key : isIndexElement(segmentA) ? Number(segmentA) === Number(segmentB) : segmentA === segmentB;
}
function isKeyElement(segment) {
    return typeof segment?._key == "string";
}
function isIndexElement(segment) {
    return typeof segment == "number";
}
function isKeyedElement(element) {
    return typeof element == "object" && "_key" in element && typeof element._key == "string";
}
function isArrayElement(element) {
    return typeof element == "number" || isKeyedElement(element);
}
function isPropertyElement(element) {
    return typeof element == "string";
}
const IS_DOTTABLE = /^[a-z_$]+/;
function stringifySegment(segment, hasLeading) {
    return Array.isArray(segment) ? `[${segment[0]}:${segment[1] || ""}]` : typeof segment == "number" ? `[${segment}]` : isKeyedElement(segment) ? `[_key==${JSON.stringify(segment._key)}]` : typeof segment == "string" && IS_DOTTABLE.test(segment) ? hasLeading ? segment : `.${segment}` : `['${segment}']`;
}
function stringify(pathArray) {
    return pathArray.map((segment, i)=>stringifySegment(segment, i === 0)).join("");
}
;
 //# sourceMappingURL=stringify.js.map
}}),
"[project]/node_modules/next-sanity/node_modules/@sanity/mutate/dist/_chunks-es/decode.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "decode": (()=>decode),
    "decodeAll": (()=>decodeAll)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next-sanity/node_modules/@sanity/mutate/dist/_chunks-es/parse.js [app-ssr] (ecmascript)");
;
function isCreateIfNotExistsMutation(sanityMutation) {
    return "createIfNotExists" in sanityMutation;
}
function isCreateOrReplaceMutation(sanityMutation) {
    return "createOrReplace" in sanityMutation;
}
function isCreateMutation(sanityMutation) {
    return "create" in sanityMutation;
}
function isDeleteMutation(sanityMutation) {
    return "delete" in sanityMutation;
}
function isPatchMutation(sanityMutation) {
    return "patch" in sanityMutation;
}
function isSetPatch(sanityPatch) {
    return "set" in sanityPatch;
}
function isSetIfMissingPatch(sanityPatch) {
    return "setIfMissing" in sanityPatch;
}
function isUnsetPatch(sanityPatch) {
    return "unset" in sanityPatch;
}
function isIncPatch(sanityPatch) {
    return "inc" in sanityPatch;
}
function isDecPatch(sanityPatch) {
    return "inc" in sanityPatch;
}
function isInsertPatch(sanityPatch) {
    return "insert" in sanityPatch;
}
function decodeAll(sanityMutations) {
    return sanityMutations.map(decodeMutation);
}
function decode(encodedMutation) {
    return decodeMutation(encodedMutation);
}
function decodeMutation(encodedMutation) {
    if (isCreateIfNotExistsMutation(encodedMutation)) return {
        type: "createIfNotExists",
        document: encodedMutation.createIfNotExists
    };
    if (isCreateOrReplaceMutation(encodedMutation)) return {
        type: "createOrReplace",
        document: encodedMutation.createOrReplace
    };
    if (isCreateMutation(encodedMutation)) return {
        type: "create",
        document: encodedMutation.create
    };
    if (isDeleteMutation(encodedMutation)) return {
        id: encodedMutation.delete.id,
        type: "delete"
    };
    if (isPatchMutation(encodedMutation)) return {
        type: "patch",
        id: encodedMutation.patch.id,
        patches: decodeNodePatches(encodedMutation.patch)
    };
    throw new Error(`Unknown mutation: ${JSON.stringify(encodedMutation)}`);
}
const POSITION_KEYS = [
    "before",
    "replace",
    "after"
];
function getInsertPosition(insert) {
    const positions = POSITION_KEYS.filter((k)=>k in insert);
    if (positions.length > 1) throw new Error(`Insert patch is ambiguous. Should only contain one of: ${POSITION_KEYS.join(", ")}, instead found ${positions.join(", ")}`);
    return positions[0];
}
function decodeNodePatches(patch) {
    return [
        ...getSetPatches(patch),
        ...getSetIfMissingPatches(patch),
        ...getUnsetPatches(patch),
        ...getIncPatches(patch),
        ...getDecPatches(patch),
        ...getInsertPatches(patch)
    ];
}
function getSetPatches(patch) {
    return isSetPatch(patch) ? Object.keys(patch.set).map((path)=>({
            path: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"])(path),
            op: {
                type: "set",
                value: patch.set[path]
            }
        })) : [];
}
function getSetIfMissingPatches(patch) {
    return isSetIfMissingPatch(patch) ? Object.keys(patch.setIfMissing).map((path)=>({
            path: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"])(path),
            op: {
                type: "setIfMissing",
                value: patch.setIfMissing[path]
            }
        })) : [];
}
function getUnsetPatches(patch) {
    return isUnsetPatch(patch) ? patch.unset.map((path)=>({
            path: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"])(path),
            op: {
                type: "unset"
            }
        })) : [];
}
function getIncPatches(patch) {
    return isIncPatch(patch) ? Object.keys(patch.inc).map((path)=>({
            path: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"])(path),
            op: {
                type: "inc",
                amount: patch.inc[path]
            }
        })) : [];
}
function getDecPatches(patch) {
    return isDecPatch(patch) ? Object.keys(patch.dec).map((path)=>({
            path: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"])(path),
            op: {
                type: "dec",
                amount: patch.dec[path]
            }
        })) : [];
}
function getInsertPatches(patch) {
    if (!isInsertPatch(patch)) return [];
    const position = getInsertPosition(patch.insert);
    if (!position) throw new Error("Insert patch missing position");
    const path = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"])(patch.insert[position]), referenceItem = path.pop(), op = position === "replace" ? {
        type: "insert",
        position,
        referenceItem,
        items: patch.insert.items
    } : {
        type: "insert",
        position,
        referenceItem,
        items: patch.insert.items
    };
    return [
        {
            path,
            op
        }
    ];
}
;
 //# sourceMappingURL=decode.js.map
}}),
"[project]/node_modules/next-sanity/node_modules/@sanity/mutate/dist/_chunks-es/encode.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "encode": (()=>encode),
    "encodeAll": (()=>encodeAll),
    "encodeMutation": (()=>encodeMutation),
    "encodeTransaction": (()=>encodeTransaction)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next-sanity/node_modules/@sanity/mutate/dist/_chunks-es/stringify.js [app-ssr] (ecmascript)");
;
function encode(mutation) {
    return encodeMutation(mutation);
}
function encodeAll(mutations) {
    return mutations.flatMap(encode);
}
function encodeTransaction(transaction) {
    return {
        transactionId: transaction.id,
        mutations: encodeAll(transaction.mutations)
    };
}
function encodeMutation(mutation) {
    if (mutation.type === "create" || mutation.type === "createIfNotExists" || mutation.type === "createOrReplace") return {
        [mutation.type]: mutation.document
    };
    if (mutation.type === "delete") return {
        delete: {
            id: mutation.id
        }
    };
    const ifRevisionID = mutation.options?.ifRevision;
    return mutation.patches.map((patch)=>({
            patch: {
                id: mutation.id,
                ...ifRevisionID && {
                    ifRevisionID
                },
                ...patchToSanity(patch)
            }
        }));
}
function patchToSanity(patch) {
    const { path, op } = patch;
    if (op.type === "unset") return {
        unset: [
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringify"])(path)
        ]
    };
    if (op.type === "insert") return {
        insert: {
            [op.position]: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringify"])([
                ...path,
                op.referenceItem
            ]),
            items: op.items
        }
    };
    if (op.type === "diffMatchPatch") return {
        diffMatchPatch: {
            [(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringify"])(path)]: op.value
        }
    };
    if (op.type === "inc") return {
        inc: {
            [(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringify"])(path)]: op.amount
        }
    };
    if (op.type === "dec") return {
        dec: {
            [(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringify"])(path)]: op.amount
        }
    };
    if (op.type === "set" || op.type === "setIfMissing") return {
        [op.type]: {
            [(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringify"])(path)]: op.value
        }
    };
    if (op.type === "truncate") {
        const range = [
            op.startIndex,
            typeof op.endIndex == "number" ? op.endIndex : ""
        ].join(":");
        return {
            unset: [
                `${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringify"])(path)}[${range}]`
            ]
        };
    }
    if (op.type === "upsert") return {
        unset: op.items.map((item)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringify"])([
                ...path,
                {
                    _key: item._key
                }
            ])),
        insert: {
            [op.position]: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringify"])([
                ...path,
                op.referenceItem
            ]),
            items: op.items
        }
    };
    if (op.type === "assign") return {
        set: Object.fromEntries(Object.keys(op.value).map((key)=>[
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringify"])(path.concat(key)),
                op.value[key]
            ]))
    };
    if (op.type === "unassign") return {
        unset: op.keys.map((key)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringify"])(path.concat(key)))
    };
    if (op.type === "replace") return {
        insert: {
            replace: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringify"])(path.concat(op.referenceItem)),
            items: op.items
        }
    };
    if (op.type === "remove") return {
        unset: [
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringify"])(path.concat(op.referenceItem))
        ]
    };
    throw new Error(`Unknown operation type ${op.type}`);
}
;
 //# sourceMappingURL=encode.js.map
}}),
"[project]/node_modules/next-sanity/node_modules/@sanity/mutate/dist/_chunks-es/isObject.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "isObject": (()=>isObject)
});
function isObject(val) {
    return val !== null && typeof val == "object" && !Array.isArray(val);
}
;
 //# sourceMappingURL=isObject.js.map
}}),
"[project]/node_modules/next-sanity/node_modules/@sanity/mutate/dist/_chunks-es/arrify.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "arrify": (()=>arrify)
});
function arrify(val) {
    return Array.isArray(val) ? val : [
        val
    ];
}
;
 //# sourceMappingURL=arrify.js.map
}}),
"[project]/node_modules/next-sanity/node_modules/@sanity/mutate/dist/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "CompactEncoder": (()=>index$1),
    "CompactFormatter": (()=>compact),
    "SanityEncoder": (()=>index),
    "append": (()=>append),
    "assign": (()=>assign),
    "at": (()=>at),
    "autoKeys": (()=>autoKeys),
    "create": (()=>create),
    "createIfNotExists": (()=>createIfNotExists),
    "createOrReplace": (()=>createOrReplace),
    "dec": (()=>dec),
    "del": (()=>del),
    "delete_": (()=>delete_),
    "destroy": (()=>destroy),
    "diffMatchPatch": (()=>diffMatchPatch),
    "inc": (()=>inc),
    "insert": (()=>insert),
    "insertAfter": (()=>insertAfter),
    "insertBefore": (()=>insertBefore),
    "patch": (()=>patch),
    "prepend": (()=>prepend),
    "remove": (()=>remove),
    "replace": (()=>replace),
    "set": (()=>set),
    "setIfMissing": (()=>setIfMissing),
    "truncate": (()=>truncate),
    "unassign": (()=>unassign),
    "unset": (()=>unset),
    "upsert": (()=>upsert)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next-sanity/node_modules/@sanity/mutate/dist/_chunks-es/parse.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next-sanity/node_modules/@sanity/mutate/dist/_chunks-es/stringify.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$decode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next-sanity/node_modules/@sanity/mutate/dist/_chunks-es/decode.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$encode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next-sanity/node_modules/@sanity/mutate/dist/_chunks-es/encode.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$isObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next-sanity/node_modules/@sanity/mutate/dist/_chunks-es/isObject.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$arrify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next-sanity/node_modules/@sanity/mutate/dist/_chunks-es/arrify.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
function decode(mutations) {
    return mutations.map(decodeMutation);
}
function decodeMutation(mutation) {
    const [type] = mutation;
    if (type === "delete") {
        const [, id] = mutation;
        return {
            id,
            type
        };
    } else if (type === "create") {
        const [, document] = mutation;
        return {
            type,
            document
        };
    } else if (type === "createIfNotExists") {
        const [, document] = mutation;
        return {
            type,
            document
        };
    } else if (type === "createOrReplace") {
        const [, document] = mutation;
        return {
            type,
            document
        };
    } else if (type === "patch") return decodePatchMutation(mutation);
    throw new Error(`Unrecognized mutation: ${JSON.stringify(mutation)}`);
}
function decodePatchMutation(mutation) {
    const [, type, id, serializedPath, , revisionId] = mutation, path = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"])(serializedPath);
    if (type === "dec" || type === "inc") {
        const [, , , , [amount]] = mutation;
        return {
            type: "patch",
            id,
            patches: [
                {
                    path,
                    op: {
                        type: "inc",
                        amount
                    }
                }
            ],
            ...createOpts(revisionId)
        };
    }
    if (type === "unset") return {
        type: "patch",
        id,
        patches: [
            {
                path,
                op: {
                    type: "unset"
                }
            }
        ],
        ...createOpts(revisionId)
    };
    if (type === "insert") {
        const [, , , , [position, ref, items]] = mutation;
        return {
            type: "patch",
            id,
            patches: [
                {
                    path,
                    op: {
                        type: "insert",
                        position,
                        items,
                        referenceItem: typeof ref == "string" ? {
                            _key: ref
                        } : ref
                    }
                }
            ],
            ...createOpts(revisionId)
        };
    }
    if (type === "set") {
        const [, , , , [value]] = mutation;
        return {
            type: "patch",
            id,
            patches: [
                {
                    path,
                    op: {
                        type: "set",
                        value
                    }
                }
            ],
            ...createOpts(revisionId)
        };
    }
    if (type === "setIfMissing") {
        const [, , , , [value]] = mutation;
        return {
            type: "patch",
            id,
            patches: [
                {
                    path,
                    op: {
                        type: "setIfMissing",
                        value
                    }
                }
            ],
            ...createOpts(revisionId)
        };
    }
    if (type === "diffMatchPatch") {
        const [, , , , [value]] = mutation;
        return {
            type: "patch",
            id,
            patches: [
                {
                    path,
                    op: {
                        type: "diffMatchPatch",
                        value
                    }
                }
            ],
            ...createOpts(revisionId)
        };
    }
    if (type === "truncate") {
        const [, , , , [startIndex, endIndex]] = mutation;
        return {
            type: "patch",
            id,
            patches: [
                {
                    path,
                    op: {
                        type: "truncate",
                        startIndex,
                        endIndex
                    }
                }
            ],
            ...createOpts(revisionId)
        };
    }
    if (type === "assign") {
        const [, , , , [value]] = mutation;
        return {
            type: "patch",
            id,
            patches: [
                {
                    path,
                    op: {
                        type: "assign",
                        value
                    }
                }
            ],
            ...createOpts(revisionId)
        };
    }
    if (type === "replace") {
        const [, , , , [ref, items]] = mutation;
        return {
            type: "patch",
            id,
            patches: [
                {
                    path,
                    op: {
                        type: "replace",
                        items,
                        referenceItem: decodeItemRef(ref)
                    }
                }
            ],
            ...createOpts(revisionId)
        };
    }
    if (type === "upsert") {
        const [, , , , [position, referenceItem, items]] = mutation;
        return {
            type: "patch",
            id,
            patches: [
                {
                    path,
                    op: {
                        type: "upsert",
                        items,
                        referenceItem: decodeItemRef(referenceItem),
                        position
                    }
                }
            ],
            ...createOpts(revisionId)
        };
    }
    throw new Error(`Invalid mutation type: ${type}`);
}
function decodeItemRef(ref) {
    return typeof ref == "string" ? {
        _key: ref
    } : ref;
}
function createOpts(revisionId) {
    return revisionId ? {
        options: {
            ifRevision: revisionId
        }
    } : null;
}
function encode(mutations) {
    return mutations.flatMap((m)=>encodeMutation$1(m));
}
function encodeItemRef$1(ref) {
    return typeof ref == "number" ? ref : ref._key;
}
function encodeMutation$1(mutation) {
    if (mutation.type === "create" || mutation.type === "createIfNotExists" || mutation.type === "createOrReplace") return [
        [
            mutation.type,
            mutation.document
        ]
    ];
    if (mutation.type === "delete") return [
        [
            "delete",
            mutation.id
        ]
    ];
    if (mutation.type === "patch") return mutation.patches.map((patch2)=>maybeAddRevision(mutation.options?.ifRevision, encodePatchMutation(mutation.id, patch2)));
    throw new Error(`Invalid mutation type: ${mutation.type}`);
}
function encodePatchMutation(id, patch2) {
    const { op } = patch2, path = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringify"])(patch2.path);
    if (op.type === "unset") return [
        "patch",
        "unset",
        id,
        path,
        []
    ];
    if (op.type === "diffMatchPatch") return [
        "patch",
        "diffMatchPatch",
        id,
        path,
        [
            op.value
        ]
    ];
    if (op.type === "inc" || op.type === "dec") return [
        "patch",
        op.type,
        id,
        path,
        [
            op.amount
        ]
    ];
    if (op.type === "set") return [
        "patch",
        op.type,
        id,
        path,
        [
            op.value
        ]
    ];
    if (op.type === "setIfMissing") return [
        "patch",
        op.type,
        id,
        path,
        [
            op.value
        ]
    ];
    if (op.type === "insert") return [
        "patch",
        "insert",
        id,
        path,
        [
            op.position,
            encodeItemRef$1(op.referenceItem),
            op.items
        ]
    ];
    if (op.type === "upsert") return [
        "patch",
        "upsert",
        id,
        path,
        [
            op.position,
            encodeItemRef$1(op.referenceItem),
            op.items
        ]
    ];
    if (op.type === "assign") return [
        "patch",
        "assign",
        id,
        path,
        [
            op.value
        ]
    ];
    if (op.type === "unassign") return [
        "patch",
        "assign",
        id,
        path,
        [
            op.keys
        ]
    ];
    if (op.type === "replace") return [
        "patch",
        "replace",
        id,
        path,
        [
            encodeItemRef$1(op.referenceItem),
            op.items
        ]
    ];
    if (op.type === "truncate") return [
        "patch",
        "truncate",
        id,
        path,
        [
            op.startIndex,
            op.endIndex
        ]
    ];
    if (op.type === "remove") return [
        "patch",
        "remove",
        id,
        path,
        [
            encodeItemRef$1(op.referenceItem)
        ]
    ];
    throw new Error(`Invalid operation type: ${op.type}`);
}
function maybeAddRevision(revision, mut) {
    const [mutType, patchType, id, path, args] = mut;
    return revision ? [
        mutType,
        patchType,
        id,
        path,
        args,
        revision
    ] : mut;
}
var index$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    decode,
    encode
}), index = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    decode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$decode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decode"],
    decodeAll: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$decode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decodeAll"],
    encode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$encode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encode"],
    encodeAll: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$encode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encodeAll"],
    encodeMutation: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$encode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encodeMutation"],
    encodeTransaction: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$encode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encodeTransaction"]
});
function format(mutations) {
    return mutations.flatMap((m)=>encodeMutation(m)).join(`
`);
}
function encodeItemRef(ref) {
    return typeof ref == "number" ? ref : ref._key;
}
function encodeMutation(mutation) {
    if (mutation.type === "create" || mutation.type === "createIfNotExists" || mutation.type === "createOrReplace") return [
        mutation.type,
        ": ",
        JSON.stringify(mutation.document)
    ].join("");
    if (mutation.type === "delete") return [
        "delete ",
        mutation.id
    ].join(": ");
    if (mutation.type === "patch") {
        const ifRevision = mutation.options?.ifRevision;
        return [
            "patch",
            " ",
            `id=${mutation.id}`,
            ifRevision ? ` (if revision==${ifRevision})` : "",
            `:
`,
            mutation.patches.map((nodePatch)=>`  ${formatPatchMutation(nodePatch)}`).join(`
`)
        ].join("");
    }
    throw new Error(`Invalid mutation type: ${mutation.type}`);
}
function formatPatchMutation(patch2) {
    const { op } = patch2, path = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringify"])(patch2.path);
    if (op.type === "unset") return [
        path,
        "unset()"
    ].join(": ");
    if (op.type === "diffMatchPatch") return [
        path,
        `diffMatchPatch(${op.value})`
    ].join(": ");
    if (op.type === "inc" || op.type === "dec") return [
        path,
        `${op.type}(${op.amount})`
    ].join(": ");
    if (op.type === "set" || op.type === "setIfMissing") return [
        path,
        `${op.type}(${JSON.stringify(op.value)})`
    ].join(": ");
    if (op.type === "assign") return [
        path,
        `${op.type}(${JSON.stringify(op.value)})`
    ].join(": ");
    if (op.type === "unassign") return [
        path,
        `${op.type}(${JSON.stringify(op.keys)})`
    ].join(": ");
    if (op.type === "insert" || op.type === "upsert") return [
        path,
        `${op.type}(${op.position}, ${encodeItemRef(op.referenceItem)}, ${JSON.stringify(op.items)})`
    ].join(": ");
    if (op.type === "replace") return [
        path,
        `replace(${encodeItemRef(op.referenceItem)}, ${JSON.stringify(op.items)})`
    ].join(": ");
    if (op.type === "truncate") return [
        path,
        `truncate(${op.startIndex}, ${op.endIndex}`
    ].join(": ");
    if (op.type === "remove") return [
        path,
        `remove(${encodeItemRef(op.referenceItem)})`
    ].join(": ");
    throw new Error(`Invalid operation type: ${op.type}`);
}
var compact = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    format
});
const set = (value)=>({
        type: "set",
        value
    }), assign = (value)=>({
        type: "assign",
        value
    }), unassign = (keys)=>({
        type: "unassign",
        keys
    }), setIfMissing = (value)=>({
        type: "setIfMissing",
        value
    }), unset = ()=>({
        type: "unset"
    }), inc = (amount = 1)=>({
        type: "inc",
        amount
    }), dec = (amount = 1)=>({
        type: "dec",
        amount
    }), diffMatchPatch = (value)=>({
        type: "diffMatchPatch",
        value
    });
function insert(items, position, indexOrReferenceItem) {
    return {
        type: "insert",
        referenceItem: indexOrReferenceItem,
        position,
        items: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$arrify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arrify"])(items)
    };
}
function append(items) {
    return insert(items, "after", -1);
}
function prepend(items) {
    return insert(items, "before", 0);
}
function insertBefore(items, indexOrReferenceItem) {
    return insert(items, "before", indexOrReferenceItem);
}
const insertAfter = (items, indexOrReferenceItem)=>insert(items, "after", indexOrReferenceItem);
function truncate(startIndex, endIndex) {
    return {
        type: "truncate",
        startIndex,
        endIndex
    };
}
function replace(items, referenceItem) {
    return {
        type: "replace",
        referenceItem,
        items: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$arrify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arrify"])(items)
    };
}
function remove(referenceItem) {
    return {
        type: "remove",
        referenceItem
    };
}
function upsert(items, position, referenceItem) {
    return {
        type: "upsert",
        items: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$arrify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arrify"])(items),
        referenceItem,
        position
    };
}
function autoKeys(generateKey) {
    const ensureKeys = createEnsureKeys(generateKey), insert$1 = (position, referenceItem, items)=>insert(ensureKeys(items), position, referenceItem), upsert$1 = (items, position, referenceItem)=>upsert(ensureKeys(items), position, referenceItem), replace$1 = (items, position, referenceItem)=>replace(ensureKeys(items), referenceItem), insertBefore2 = (ref, items)=>insert$1("before", ref, items);
    return {
        insert: insert$1,
        upsert: upsert$1,
        replace: replace$1,
        insertBefore: insertBefore2,
        prepend: (items)=>insertBefore2(0, items),
        insertAfter: (ref, items)=>insert$1("after", ref, items),
        append: (items)=>insert$1("after", -1, items)
    };
}
function hasKey(item) {
    return "_key" in item;
}
function createEnsureKeys(generateKey) {
    return (array)=>{
        let didModify = !1;
        const withKeys = array.map((item)=>needsKey(item) ? (didModify = !0, {
                ...item,
                _key: generateKey(item)
            }) : item);
        return didModify ? withKeys : array;
    };
}
function needsKey(arrayItem) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$isObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(arrayItem) && !hasKey(arrayItem);
}
function create(document) {
    return {
        type: "create",
        document
    };
}
function patch(id, patches, options) {
    return {
        type: "patch",
        id,
        patches: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$arrify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arrify"])(patches),
        ...options ? {
            options
        } : {}
    };
}
function at(path, operation) {
    return {
        path: typeof path == "string" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"])(path) : path,
        op: operation
    };
}
function createIfNotExists(document) {
    return {
        type: "createIfNotExists",
        document
    };
}
function createOrReplace(document) {
    return {
        type: "createOrReplace",
        document
    };
}
function delete_(id) {
    return {
        type: "delete",
        id
    };
}
const del = delete_, destroy = delete_;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/get-random-values-esm/index.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Strict ESM env, designed to run outside Node.js in envs that provide WebCrypto (deno, browsers, etc)
__turbopack_context__.s({
    "default": (()=>getRandomValues)
});
function getRandomValues(typedArray) {
    const crypto = typeof window !== 'undefined' && 'crypto' in window ? window.crypto : globalThis.crypto;
    if (!crypto || !crypto.getRandomValues) {
        throw new Error('WebCrypto not available in this environment');
    }
    return crypto.getRandomValues(typedArray);
}
}}),
"[project]/node_modules/next-sanity/node_modules/@sanity/visual-editing/dist/_chunks-es/mutations.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "get": (()=>get),
    "getArrayDuplicatePatches": (()=>getArrayDuplicatePatches),
    "getArrayInsertPatches": (()=>getArrayInsertPatches),
    "getArrayItemKeyAndParentPath": (()=>getArrayItemKeyAndParentPath),
    "getArrayMovePatches": (()=>getArrayMovePatches),
    "getArrayRemovePatches": (()=>getArrayRemovePatches),
    "useDocuments": (()=>useDocuments),
    "useOptimisticActor": (()=>useOptimisticActor),
    "useOptimisticActorReady": (()=>useOptimisticActorReady)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-compiler-runtime/dist/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/client/dist/_chunks-es/resolveEditInfo.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next-sanity/node_modules/@sanity/mutate/dist/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$presentation$2d$comlink$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@sanity/presentation-comlink/dist/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$dist$2f$_chunks$2d$es$2f$context$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next-sanity/node_modules/@sanity/visual-editing/dist/_chunks-es/context.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$random$2d$values$2d$esm$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/get-random-values-esm/index.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
const reKeySegment$1 = /_key\s*==\s*['"](.*)['"]/, reIndexTuple = /^\d*:\d*$/;
function isIndexSegment(segment) {
    return typeof segment == "number" || typeof segment == "string" && /^\[\d+\]$/.test(segment);
}
function isKeySegment(segment) {
    return typeof segment == "string" ? reKeySegment$1.test(segment.trim()) : typeof segment == "object" && "_key" in segment;
}
function isIndexTuple(segment) {
    if (typeof segment == "string" && reIndexTuple.test(segment)) return !0;
    if (!Array.isArray(segment) || segment.length !== 2) return !1;
    const [from, to] = segment;
    return (typeof from == "number" || from === "") && (typeof to == "number" || to === "");
}
const rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, reKeySegment = /_key\s*==\s*['"](.*)['"]/;
function get(obj, path, defaultVal) {
    const select = typeof path == "string" ? fromString(path) : path;
    if (!Array.isArray(select)) throw new Error("Path must be an array or a string");
    let acc = obj;
    for(let i = 0; i < select.length; i++){
        const segment = select[i];
        if (isIndexSegment(segment)) {
            if (!Array.isArray(acc)) return defaultVal;
            acc = acc[segment];
        }
        if (isKeySegment(segment)) {
            if (!Array.isArray(acc)) return defaultVal;
            acc = acc.find((item)=>item._key === segment._key);
        }
        if (typeof segment == "string" && (acc = typeof acc == "object" && acc !== null ? acc[segment] : void 0), typeof acc > "u") return defaultVal;
    }
    return acc;
}
function fromString(path) {
    if (typeof path != "string") throw new Error("Path is not a string");
    const segments = path.match(rePropName);
    if (!segments) throw new Error("Invalid path string");
    return segments.map(normalizePathSegment);
}
function normalizePathSegment(segment) {
    return isIndexSegment(segment) ? normalizeIndexSegment(segment) : isKeySegment(segment) ? normalizeKeySegment(segment) : isIndexTuple(segment) ? normalizeIndexTupleSegment(segment) : segment;
}
function normalizeIndexSegment(segment) {
    return Number(segment.replace(/[^\d]/g, ""));
}
function normalizeKeySegment(segment) {
    return {
        _key: segment.match(reKeySegment)[1]
    };
}
function normalizeIndexTupleSegment(segment) {
    const [from, to] = segment.split(":").map((seg)=>seg === "" ? seg : Number(seg));
    return [
        from,
        to
    ];
}
function useOptimisticActor() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useSyncExternalStore"])(_temp, _temp2, _temp3);
}
function _temp3() {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$dist$2f$_chunks$2d$es$2f$context$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["emptyActor"];
}
function _temp2() {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$dist$2f$_chunks$2d$es$2f$context$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["actor"];
}
function _temp(listener) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$dist$2f$_chunks$2d$es$2f$context$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["listeners"].add(listener), ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$dist$2f$_chunks$2d$es$2f$context$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["listeners"].delete(listener);
}
function useOptimisticActorReady() {
    const actor2 = useOptimisticActor();
    let t0;
    return t0 = !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$dist$2f$_chunks$2d$es$2f$context$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isEmptyActor"])(actor2), t0;
}
function debounce(fn, timeout) {
    let timer;
    return (...args)=>{
        clearTimeout(timer), timer = setTimeout(()=>{
            fn.apply(fn, args);
        }, timeout);
    };
}
function getDocumentsAndSnapshot(id, actor2) {
    const inFrame = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$presentation$2d$comlink$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isMaybePreviewIframe"])(), inPopUp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$presentation$2d$comlink$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isMaybePreviewWindow"])();
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$dist$2f$_chunks$2d$es$2f$context$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isEmptyActor"])(actor2) || !inFrame && !inPopUp) throw new Error("The `useDocuments` hook cannot be used in this context");
    const draftId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getDraftId"])(id), publishedId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getPublishedId"])(id), documents = actor2.getSnapshot().context?.documents, draftDoc = documents?.[draftId], publishedDoc = documents?.[publishedId], doc = draftDoc || publishedDoc;
    if (!doc) throw new Error(`Document "${id}" not found`);
    const snapshot = draftDoc.getSnapshot().context?.local || publishedDoc.getSnapshot().context?.local, snapshotPromise = new Promise((resolve)=>{
        if (snapshot) resolve(snapshot);
        else {
            const subscriber = doc.on("ready", (event)=>{
                const { snapshot: snapshot2 } = event;
                resolve(snapshot2 || null), subscriber.unsubscribe();
            });
        }
    });
    return {
        draftDoc,
        draftId,
        getSnapshot: ()=>snapshotPromise,
        publishedDoc,
        publishedId,
        /**
     * @deprecated - use `getSnapshot` instead
     */ get snapshot () {
            if (!snapshot) throw new Error(`Snapshot for document "${id}" not found`);
            return snapshot;
        }
    };
}
function createDocumentCommit(id, actor2) {
    return ()=>{
        const { draftDoc } = getDocumentsAndSnapshot(id, actor2);
        draftDoc.send({
            type: "submit"
        });
    };
}
function createDocumentGet(id, actor2) {
    return (path)=>{
        const { snapshot } = getDocumentsAndSnapshot(id, actor2);
        return path ? get(snapshot, path) : snapshot;
    };
}
function createDocumentGetSnapshot(id, actor2) {
    const { getSnapshot } = getDocumentsAndSnapshot(id, actor2);
    return getSnapshot;
}
function createDocumentPatch(id, actor2) {
    return async (patches, options)=>{
        const result = getDocumentsAndSnapshot(id, actor2), { draftDoc, draftId, getSnapshot, publishedId } = result, { commit = !0 } = options || {}, resolvedPatches = await (typeof patches == "function" ? patches({
            draftId,
            publishedId,
            /**
       * @deprecated - use `getSnapshot` instead
       */ get snapshot () {
                return result.snapshot;
            },
            getSnapshot
        }) : patches), _snapshot = await getSnapshot();
        if (!_snapshot) throw new Error(`Snapshot for document "${id}" not found`);
        draftDoc.send({
            type: "mutate",
            mutations: [
                // Attempt to create the draft document, it might not exist if the
                // snapshot was from the published document
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createIfNotExists"])({
                    ..._snapshot,
                    _id: draftId
                }),
                // Patch the draft document with the resolved patches
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["patch"])(draftId, resolvedPatches)
            ]
        }), commit && (typeof commit == "object" && "debounce" in commit ? debounce(()=>draftDoc.send({
                type: "submit"
            }), commit.debounce)() : draftDoc.send({
            type: "submit"
        }));
    };
}
function useDocuments() {
    const $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])(7), actor2 = useOptimisticActor();
    let t0;
    $[0] !== actor2 ? (t0 = (documentId)=>({
            id: documentId,
            commit: createDocumentCommit(documentId, actor2),
            get: createDocumentGet(documentId, actor2),
            getSnapshot: createDocumentGetSnapshot(documentId, actor2),
            patch: createDocumentPatch(documentId, actor2)
        }), $[0] = actor2, $[1] = t0) : t0 = $[1];
    const getDocument = t0;
    let t1;
    $[2] !== actor2 ? (t1 = (id, mutations, options)=>{
        const { draftDoc } = getDocumentsAndSnapshot(id, actor2), { commit: t22 } = options || {}, commit = t22 === void 0 ? !0 : t22;
        draftDoc.send({
            type: "mutate",
            mutations
        }), commit && (typeof commit == "object" && "debounce" in commit ? debounce(()=>draftDoc.send({
                type: "submit"
            }), commit.debounce)() : draftDoc.send({
            type: "submit"
        }));
    }, $[2] = actor2, $[3] = t1) : t1 = $[3];
    const mutateDocument = t1;
    let t2;
    return $[4] !== getDocument || $[5] !== mutateDocument ? (t2 = {
        getDocument,
        mutateDocument
    }, $[4] = getDocument, $[5] = mutateDocument, $[6] = t2) : t2 = $[6], t2;
}
function whatwgRNG(length = 16) {
    const rnds8 = new Uint8Array(length);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$random$2d$values$2d$esm$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(rnds8), rnds8;
}
const getByteHexTable = /* @__PURE__ */ (()=>{
    let table;
    return ()=>{
        if (table) return table;
        table = [];
        for(let i = 0; i < 256; ++i)table[i] = (i + 256).toString(16).slice(1);
        return table;
    };
})();
function randomKey(length) {
    const table = getByteHexTable();
    return whatwgRNG(length).reduce((str, n)=>str + table[n], "").slice(0, length);
}
function getArrayItemKeyAndParentPath(pathOrNode) {
    const elementPath = typeof pathOrNode == "string" ? pathOrNode : pathOrNode.path, lastDotIndex = elementPath.lastIndexOf("."), lastPathItem = elementPath.substring(lastDotIndex + 1, elementPath.length);
    if (!lastPathItem.indexOf("[")) throw new Error("Invalid path: not an array");
    const lastArrayIndex = elementPath.lastIndexOf("["), path = elementPath.substring(0, lastArrayIndex);
    let key, hasExplicitKey;
    if (lastPathItem.includes("_key")) {
        const startIndex = lastPathItem.indexOf('"') + 1, endIndex = lastPathItem.indexOf('"', startIndex);
        key = lastPathItem.substring(startIndex, endIndex), hasExplicitKey = !0;
    } else {
        const startIndex = lastPathItem.indexOf("[") + 1, endIndex = lastPathItem.indexOf("]", startIndex);
        key = lastPathItem.substring(startIndex, endIndex), hasExplicitKey = !1;
    }
    if (!path || !key) throw new Error("Invalid path");
    return {
        path,
        key,
        hasExplicitKey
    };
}
function getArrayDuplicatePatches(node, snapshot, position = "after") {
    const { path: arrayPath, key: itemKey } = getArrayItemKeyAndParentPath(node), duplicate = {
        ...get(snapshot, node.path),
        _key: randomKey()
    };
    return [
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["at"])(arrayPath, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["insert"])(duplicate, position, {
            _key: itemKey
        }))
    ];
}
function getArrayRemovePatches(node, snapshot) {
    const { path: arrayPath, key: itemKey } = getArrayItemKeyAndParentPath(node), currentIndex = get(snapshot, arrayPath).findIndex((item)=>item._key === itemKey);
    return [
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["at"])(arrayPath, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["truncate"])(currentIndex, currentIndex + 1))
    ];
}
function getArrayInsertPatches(node, insertType, position) {
    const { path: arrayPath, key: itemKey } = getArrayItemKeyAndParentPath(node), insertKey = randomKey();
    return [
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["at"])(arrayPath, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["insert"])([
            {
                _type: insertType,
                _key: insertKey
            }
        ], position, {
            _key: itemKey
        }))
    ];
}
async function getArrayMovePatches(node, doc, moveTo) {
    if (!node.type) throw new Error("Node type is missing");
    const { path: arrayPath, key: itemKey } = getArrayItemKeyAndParentPath(node), snapshot = await doc.getSnapshot(), array = get(snapshot, arrayPath), item = get(snapshot, node.path), currentIndex = array.findIndex((item2)=>item2._key === itemKey);
    let nextIndex = -1, position = "before";
    if (moveTo === "first") {
        if (currentIndex === 0) return [];
        nextIndex = 0, position = "before";
    } else if (moveTo === "last") {
        if (currentIndex === array.length - 1) return [];
        nextIndex = -1, position = "after";
    } else if (moveTo === "next") {
        if (currentIndex === array.length - 1) return [];
        nextIndex = currentIndex, position = "after";
    } else if (moveTo === "previous") {
        if (currentIndex === 0) return [];
        nextIndex = currentIndex - 1, position = "before";
    }
    return [
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["at"])(arrayPath, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["truncate"])(currentIndex, currentIndex + 1)),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["at"])(arrayPath, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["insert"])(item, position, nextIndex))
    ];
}
;
 //# sourceMappingURL=mutations.js.map
}}),
"[project]/node_modules/@vercel/stega/dist/index.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "VERCEL_STEGA_REGEX": (()=>f),
    "legacyStegaEncode": (()=>y),
    "vercelStegaClean": (()=>O),
    "vercelStegaCombine": (()=>C),
    "vercelStegaDecode": (()=>G),
    "vercelStegaDecodeAll": (()=>$),
    "vercelStegaEncode": (()=>E),
    "vercelStegaSplit": (()=>_)
});
var s = {
    0: 8203,
    1: 8204,
    2: 8205,
    3: 8290,
    4: 8291,
    5: 8288,
    6: 65279,
    7: 8289,
    8: 119155,
    9: 119156,
    a: 119157,
    b: 119158,
    c: 119159,
    d: 119160,
    e: 119161,
    f: 119162
}, c = {
    0: 8203,
    1: 8204,
    2: 8205,
    3: 65279
}, u = new Array(4).fill(String.fromCodePoint(c[0])).join(""), m = String.fromCharCode(0);
function E(t) {
    let e = JSON.stringify(t);
    return `${u}${Array.from(e).map((r)=>{
        let n = r.charCodeAt(0);
        if (n > 255) throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${e} on character ${r} (${n})`);
        return Array.from(n.toString(4).padStart(4, "0")).map((o)=>String.fromCodePoint(c[o])).join("");
    }).join("")}`;
}
function y(t) {
    let e = JSON.stringify(t);
    return Array.from(e).map((r)=>{
        let n = r.charCodeAt(0);
        if (n > 255) throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${e} on character ${r} (${n})`);
        return Array.from(n.toString(16).padStart(2, "0")).map((o)=>String.fromCodePoint(s[o])).join("");
    }).join("");
}
function I(t) {
    return !Number.isNaN(Number(t)) || /[a-z]/i.test(t) && !/\d+(?:[-:\/]\d+){2}(?:T\d+(?:[-:\/]\d+){1,2}(\.\d+)?Z?)?/.test(t) ? !1 : Boolean(Date.parse(t));
}
function T(t) {
    try {
        new URL(t, t.startsWith("/") ? "https://acme.com" : void 0);
    } catch  {
        return !1;
    }
    return !0;
}
function C(t, e, r = "auto") {
    return r === !0 || r === "auto" && (I(t) || T(t)) ? t : `${t}${E(e)}`;
}
var x = Object.fromEntries(Object.entries(c).map((t)=>t.reverse())), g = Object.fromEntries(Object.entries(s).map((t)=>t.reverse())), S = `${Object.values(s).map((t)=>`\\u{${t.toString(16)}}`).join("")}`, f = new RegExp(`[${S}]{4,}`, "gu");
function G(t) {
    let e = t.match(f);
    if (!!e) return h(e[0], !0)[0];
}
function $(t) {
    let e = t.match(f);
    if (!!e) return e.map((r)=>h(r)).flat();
}
function h(t, e = !1) {
    let r = Array.from(t);
    if (r.length % 2 === 0) {
        if (r.length % 4 || !t.startsWith(u)) return A(r, e);
    } else throw new Error("Encoded data has invalid length");
    let n = [];
    for(let o = r.length * .25; o--;){
        let p = r.slice(o * 4, o * 4 + 4).map((d)=>x[d.codePointAt(0)]).join("");
        n.unshift(String.fromCharCode(parseInt(p, 4)));
    }
    if (e) {
        n.shift();
        let o = n.indexOf(m);
        return o === -1 && (o = n.length), [
            JSON.parse(n.slice(0, o).join(""))
        ];
    }
    return n.join("").split(m).filter(Boolean).map((o)=>JSON.parse(o));
}
function A(t, e) {
    var d;
    let r = [];
    for(let i = t.length * .5; i--;){
        let a = `${g[t[i * 2].codePointAt(0)]}${g[t[i * 2 + 1].codePointAt(0)]}`;
        r.unshift(String.fromCharCode(parseInt(a, 16)));
    }
    let n = [], o = [
        r.join("")
    ], p = 10;
    for(; o.length;){
        let i = o.shift();
        try {
            if (n.push(JSON.parse(i)), e) return n;
        } catch (a) {
            if (!p--) throw a;
            let l = +((d = a.message.match(/\sposition\s(\d+)$/)) == null ? void 0 : d[1]);
            if (!l) throw a;
            o.unshift(i.substring(0, l), i.substring(l));
        }
    }
    return n;
}
function _(t) {
    var e;
    return {
        cleaned: t.replace(f, ""),
        encoded: ((e = t.match(f)) == null ? void 0 : e[0]) || ""
    };
}
function O(t) {
    return t && JSON.parse(_(JSON.stringify(t)).cleaned);
}
;
}}),
"[project]/node_modules/next-sanity/node_modules/@sanity/visual-editing/dist/_chunks-es/SharedStateContext.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "SharedStateContext": (()=>SharedStateContext),
    "createOverlayController": (()=>createOverlayController),
    "sanityNodesExistInSameArray": (()=>sanityNodesExistInSameArray),
    "useOptimistic": (()=>useOptimistic)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-compiler-runtime/dist/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/client/dist/_chunks-es/resolveEditInfo.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$effect$2d$event$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/use-effect-event/dist/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$dist$2f$_chunks$2d$es$2f$context$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next-sanity/node_modules/@sanity/visual-editing/dist/_chunks-es/context.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$dist$2f$_chunks$2d$es$2f$mutations$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next-sanity/node_modules/@sanity/visual-editing/dist/_chunks-es/mutations.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2d$csm$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/visual-editing-csm/dist/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vercel$2f$stega$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@vercel/stega/dist/index.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
function useOptimistic(passthrough, reducer) {
    const $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])(21), [pristine, setPristine] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useState"])(!0), [optimistic, setOptimistic] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useState"])(passthrough), [lastEvent, setLastEvent] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useState"])(null), [lastPassthrough, setLastPassthrough] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useState"])(passthrough), actor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$dist$2f$_chunks$2d$es$2f$mutations$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useOptimisticActor"])();
    let t0;
    $[0] !== reducer ? (t0 = (action, prevState)=>(Array.isArray(reducer) ? reducer : [
            reducer
        ]).reduce((acc, reducer_0)=>reducer_0(acc, {
                document: action.document,
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getPublishedId"])(action.id),
                originalId: action.id,
                type: action.type
            }), prevState), $[0] = reducer, $[1] = t0) : t0 = $[1];
    const reduceStateFromAction = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$effect$2d$event$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useEffectEvent"])(t0);
    let t1;
    $[2] !== passthrough ? (t1 = ()=>setLastPassthrough(passthrough), $[2] = passthrough, $[3] = t1) : t1 = $[3];
    const updateLastPassthrough = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$effect$2d$event$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useEffectEvent"])(t1);
    let t2;
    $[4] !== actor || $[5] !== reduceStateFromAction || $[6] !== updateLastPassthrough ? (t2 = ()=>{
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$dist$2f$_chunks$2d$es$2f$context$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isEmptyActor"])(actor)) return;
        let pristineTimeout;
        const rebasedSub = actor.on("rebased.local", (_event)=>{
            const event = {
                document: _event.document,
                id: _event.id,
                originalId: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getPublishedId"])(_event.id),
                type: "mutate"
            };
            setOptimistic((prevState_0)=>reduceStateFromAction(event, prevState_0)), setLastEvent(event), updateLastPassthrough(), setPristine(!1), clearTimeout(pristineTimeout);
        }), pristineSub = actor.on("pristine", ()=>{
            pristineTimeout = setTimeout(()=>{
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["startTransition"])(()=>setPristine(!0));
            }, 15e3);
        });
        return ()=>{
            rebasedSub.unsubscribe(), pristineSub.unsubscribe();
        };
    }, $[4] = actor, $[5] = reduceStateFromAction, $[6] = updateLastPassthrough, $[7] = t2) : t2 = $[7];
    let t3;
    $[8] !== actor ? (t3 = [
        actor
    ], $[8] = actor, $[9] = t3) : t3 = $[9], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useEffect"])(t2, t3);
    let t4;
    $[10] !== lastEvent || $[11] !== lastPassthrough || $[12] !== passthrough || $[13] !== pristine || $[14] !== reduceStateFromAction ? (t4 = ()=>{
        if (!pristine) {
            if (!lastEvent) throw new Error("No last event found when syncing passthrough");
            lastPassthrough !== passthrough && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["startTransition"])(()=>{
                setOptimistic(reduceStateFromAction(lastEvent, passthrough)), setLastPassthrough(passthrough);
            });
        }
    }, $[10] = lastEvent, $[11] = lastPassthrough, $[12] = passthrough, $[13] = pristine, $[14] = reduceStateFromAction, $[15] = t4) : t4 = $[15];
    let t5;
    return $[16] !== lastEvent || $[17] !== lastPassthrough || $[18] !== passthrough || $[19] !== pristine ? (t5 = [
        lastEvent,
        lastPassthrough,
        passthrough,
        pristine
    ], $[16] = lastEvent, $[17] = lastPassthrough, $[18] = passthrough, $[19] = pristine, $[20] = t5) : t5 = $[20], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useEffect"])(t4, t5), pristine ? passthrough : optimistic;
}
const byteToHex = [];
for(let i = 0; i < 256; ++i)byteToHex.push((i + 256).toString(16).slice(1));
function unsafeStringify(arr, offset = 0) {
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
    if (!getRandomValues) {
        if (typeof crypto > "u" || !crypto.getRandomValues) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
        getRandomValues = crypto.getRandomValues.bind(crypto);
    }
    return getRandomValues(rnds8);
}
const randomUUID = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native = {
    randomUUID
};
function v4(options, buf, offset) {
    if (native.randomUUID && !options) return native.randomUUID();
    options = options || {};
    const rnds = options.random ?? options.rng?.() ?? rng();
    if (rnds.length < 16) throw new Error("Random bytes length must be >= 16");
    return rnds[6] = rnds[6] & 15 | 64, rnds[8] = rnds[8] & 63 | 128, unsafeStringify(rnds);
}
function getRect(element) {
    const domRect = element.getBoundingClientRect();
    return {
        x: domRect.x + scrollX,
        y: domRect.y + scrollY,
        w: domRect.width,
        h: domRect.height
    };
}
function offsetRect(rect, px, axis) {
    return axis === "x" ? {
        x: rect.x + px,
        y: rect.y,
        w: rect.w - 2 * px,
        h: rect.h
    } : {
        x: rect.x,
        y: rect.y + px,
        w: rect.w,
        h: rect.h - 2 * px
    };
}
function rayIntersect(l1, l2) {
    const { x1, y1, x2, y2 } = l1, { x1: x3, y1: y3, x2: x4, y2: y4 } = l2;
    if (x1 === x2 && y1 === y2 || x3 === x4 && y3 === y4) return !1;
    const denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
    if (denominator === 0) return !1;
    const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator, ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;
    if (ua < 0 || ua > 1 || ub < 0 || ub > 1) return !1;
    const x = x1 + ua * (x2 - x1), y = y1 + ua * (y2 - y1);
    return {
        x,
        y
    };
}
function rectEqual(r1, r2) {
    return r1.x === r2.x && r1.y === r2.y && r1.w === r2.w && r1.h === r2.h;
}
function rayRectIntersections(line, rect) {
    const rectLines = [
        {
            x1: rect.x,
            y1: rect.y,
            x2: rect.x + rect.w,
            y2: rect.y
        },
        {
            x1: rect.x + rect.w,
            y1: rect.y,
            x2: rect.x + rect.w,
            y2: rect.y + rect.h
        },
        {
            x1: rect.x + rect.w,
            y1: rect.y + rect.h,
            x2: rect.x,
            y2: rect.y + rect.h
        },
        {
            x1: rect.x,
            y1: rect.y + rect.h,
            x2: rect.x,
            y2: rect.y
        }
    ], intersections = [];
    for(let i = 0; i < rectLines.length; i++){
        const intersection = rayIntersect(line, rectLines[i]);
        if (intersection) {
            let isDuplicate = !1;
            for(let j = 0; j < intersections.length; j++)intersections[j].x === intersection.x && intersections[j].y === intersection.y && (isDuplicate = !0);
            isDuplicate || intersections.push(intersection);
        }
    }
    return intersections.length === 0 ? !1 : intersections.sort((a, b)=>pointDist(a, {
            x: line.x1,
            y: line.y1
        }) - pointDist(b, {
            x: line.x1,
            y: line.y1
        }));
}
function pointDist(p1, p2) {
    const a = p1.x - p2.x, b = p1.y - p2.y;
    return Math.sqrt(a * a + b * b);
}
function pointInBounds(point, bounds) {
    const withinX = point.x >= bounds.x && point.x <= bounds.x + bounds.w, withinY = point.y >= bounds.y && point.y <= bounds.y + bounds.h;
    return withinX && withinY;
}
function findClosestIntersection(ray, targets, flow) {
    const rayOrigin = {
        x: ray.x1,
        y: ray.y1
    };
    if (targets.some((t)=>pointInBounds(rayOrigin, offsetRect(t, Math.min(t.w, t.h) / 10, flow === "horizontal" ? "x" : "y")))) return null;
    let closestIntersection, closestRect;
    for (const target of targets){
        const intersections = rayRectIntersections(ray, offsetRect(target, Math.min(target.w, target.h) / 10, flow === "horizontal" ? "x" : "y"));
        if (intersections) {
            const firstIntersection = intersections[0];
            closestIntersection ? pointDist(rayOrigin, firstIntersection) < pointDist(rayOrigin, closestIntersection) && (closestIntersection = firstIntersection, closestRect = target) : (closestIntersection = firstIntersection, closestRect = target);
        }
    }
    return closestRect || null;
}
function scaleRect(rect, scale, origin) {
    const { x, y, w, h } = rect, { x: originX, y: originY } = origin, newX = originX + (x - originX) * scale, newY = originY + (y - originY) * scale, newWidth = w * scale, newHeight = h * scale;
    return {
        x: newX,
        y: newY,
        w: newWidth,
        h: newHeight
    };
}
function getRectGroupXExtent(rects) {
    const minGroupX = Math.max(0, Math.min(...rects.map((r)=>r.x))), maxGroupX = Math.min(document.body.offsetWidth, Math.max(...rects.map((r)=>r.x + r.w)));
    return {
        min: minGroupX,
        max: maxGroupX,
        width: maxGroupX - minGroupX
    };
}
function getRectGroupYExtent(rects) {
    const minGroupY = Math.max(0, Math.min(...rects.map((r)=>r.y))), maxGroupY = Math.min(document.body.scrollHeight, Math.max(...rects.map((r)=>r.y + r.h)));
    return {
        min: minGroupY,
        max: maxGroupY,
        height: maxGroupY - minGroupY
    };
}
function calcTargetFlow(targets) {
    return targets.some((t1)=>targets.filter((t2)=>!rectEqual(t1, t2)).some((t2)=>t1.y === t2.y)) ? "horizontal" : "vertical";
}
function calcInsertPosition(origin, targets, flow) {
    if (flow === "horizontal") {
        const rayLeft = {
            x1: origin.x,
            y1: origin.y,
            x2: origin.x - 1e8,
            y2: origin.y
        }, rayRight = {
            x1: origin.x,
            y1: origin.y,
            x2: origin.x + 1e8,
            y2: origin.y
        };
        return {
            left: findClosestIntersection(rayLeft, targets, flow),
            right: findClosestIntersection(rayRight, targets, flow)
        };
    } else {
        const rayTop = {
            x1: origin.x,
            y1: origin.y,
            x2: origin.x,
            y2: origin.y - 1e8
        }, rayBottom = {
            x1: origin.x,
            y1: origin.y,
            x2: origin.x,
            y2: origin.y + 1e8
        };
        return {
            top: findClosestIntersection(rayTop, targets, flow),
            bottom: findClosestIntersection(rayBottom, targets, flow)
        };
    }
}
function findRectSanityData(rect, overlayGroup) {
    return overlayGroup.find((e)=>rectEqual(getRect(e.elements.element), rect))?.sanity;
}
function resolveInsertPosition(overlayGroup, insertPosition, flow) {
    return Object.values(insertPosition).every((v)=>v === null) ? null : flow === "horizontal" ? {
        left: insertPosition.left ? {
            rect: insertPosition.left,
            sanity: findRectSanityData(insertPosition.left, overlayGroup)
        } : null,
        right: insertPosition.right ? {
            rect: insertPosition.right,
            sanity: findRectSanityData(insertPosition.right, overlayGroup)
        } : null
    } : {
        top: insertPosition.top ? {
            rect: insertPosition.top,
            sanity: findRectSanityData(insertPosition.top, overlayGroup)
        } : null,
        bottom: insertPosition.bottom ? {
            rect: insertPosition.bottom,
            sanity: findRectSanityData(insertPosition.bottom, overlayGroup)
        } : null
    };
}
function calcMousePos(e) {
    const bodyBounds = document.body.getBoundingClientRect();
    return {
        x: Math.max(bodyBounds.x, Math.min(e.clientX, bodyBounds.x + bodyBounds.width)),
        y: e.clientY + window.scrollY
    };
}
function calcMousePosInverseTransform(mousePos2) {
    const body = document.body, transform = window.getComputedStyle(body).transform;
    if (transform === "none") return {
        x: mousePos2.x,
        y: mousePos2.y
    };
    const inverseMatrix = new DOMMatrix(transform).inverse(), transformedPoint = new DOMPoint(mousePos2.x, mousePos2.y).matrixTransform(inverseMatrix);
    return {
        x: transformedPoint.x,
        y: transformedPoint.y
    };
}
function buildPreviewSkeleton(mousePos2, element, scaleFactor) {
    const bounds = getRect(element), children = [
        ...element.querySelectorAll(":where(h1, h2, h3, h4, p, a, img, span, button):not(:has(*))")
    ];
    mousePos2.x <= bounds.x && (mousePos2.x = bounds.x), mousePos2.x >= bounds.x + bounds.w && (mousePos2.x = bounds.x + bounds.w), mousePos2.y >= bounds.y + bounds.h && (mousePos2.y = bounds.y + bounds.h), mousePos2.y <= bounds.y && (mousePos2.y = bounds.y);
    const childRects = children.map((child)=>{
        const rect = scaleRect(getRect(child), scaleFactor, {
            x: bounds.x,
            y: bounds.y
        });
        return {
            x: rect.x - bounds.x,
            y: rect.y - bounds.y,
            w: rect.w,
            h: rect.h,
            tagName: child.tagName
        };
    });
    return {
        offsetX: (bounds.x - mousePos2.x) * scaleFactor,
        offsetY: (bounds.y - mousePos2.y) * scaleFactor,
        w: bounds.w * scaleFactor,
        h: bounds.h * scaleFactor,
        maxWidth: bounds.w * scaleFactor * 0.75,
        childRects
    };
}
const minDragDelta = 4;
async function applyMinimapWrapperTransform(target, scaleFactor, minYScaled, handler, rectUpdateFrequency) {
    return new Promise((resolve)=>{
        target.addEventListener("transitionend", ()=>{
            setTimeout(()=>{
                handler({
                    type: "overlay/dragEndMinimapTransition"
                });
            }, rectUpdateFrequency * 2), resolve();
        }, {
            once: !0
        }), handler({
            type: "overlay/dragStartMinimapTransition"
        }), handler({
            type: "overlay/dragToggleMinimap",
            display: !0
        }), document.body.style.overflow = "hidden", document.body.style.height = "100%", document.documentElement.style.overflow = "initial", document.documentElement.style.height = "100%", setTimeout(()=>{
            target.style.transformOrigin = "50% 0px", target.style.transition = "transform 150ms ease", target.style.transform = `translate3d(0px, ${-minYScaled + scrollY}px, 0px) scale(${scaleFactor})`;
        }, 25);
    });
}
function calcMinimapTransformValues(rects, groupHeightOverride) {
    let groupHeight = groupHeightOverride || getRectGroupYExtent(rects).height;
    const padding = 100;
    groupHeight += padding * 2;
    const scaleFactor = groupHeight > window.innerHeight ? window.innerHeight / groupHeight : 1, scaledRects = rects.map((r)=>scaleRect(r, scaleFactor, {
            x: window.innerWidth / 2,
            y: 0
        })), { min: minYScaled } = getRectGroupYExtent(scaledRects);
    return {
        scaleFactor,
        minYScaled: minYScaled - padding * scaleFactor
    };
}
function calcGroupBoundsPreview(rects) {
    const groupBoundsX = getRectGroupXExtent(rects), groupBoundsY = getRectGroupYExtent(rects), offsetDist = 8, canOffsetX = groupBoundsX.min > offsetDist && groupBoundsX.min + groupBoundsX.width <= window.innerWidth - offsetDist, canOffsetY = groupBoundsY.min > offsetDist && groupBoundsY.min + groupBoundsY.height <= document.body.scrollHeight - offsetDist, canOffset = canOffsetX && canOffsetY;
    return {
        x: canOffset ? groupBoundsX.min - offsetDist : groupBoundsX.min,
        y: canOffset ? groupBoundsY.min - offsetDist : groupBoundsY.min,
        w: canOffset ? groupBoundsX.width + offsetDist * 2 : groupBoundsX.width,
        h: canOffset ? groupBoundsY.height + offsetDist * 2 : groupBoundsY.height
    };
}
async function resetMinimapWrapperTransform(endYOrigin, target, prescaleHeight2, handler, rectUpdateFrequency, previousRootStyleValues2) {
    return new Promise((resolve)=>{
        const transform = window.getComputedStyle(target).transform;
        if (new DOMMatrix(transform).a === 1) return;
        const maxScroll = prescaleHeight2 - window.innerHeight, prevScrollY = scrollY;
        endYOrigin -= window.innerHeight / 2, endYOrigin < 0 && (endYOrigin = 0), target.addEventListener("transitionend", ()=>{
            target.style.transition = "none", target.style.transform = "none", scrollTo({
                top: endYOrigin,
                behavior: "instant"
            }), setTimeout(()=>{
                handler({
                    type: "overlay/dragEndMinimapTransition"
                }), handler({
                    type: "overlay/dragToggleMinimap",
                    display: !1
                });
            }, rectUpdateFrequency * 2), resolve();
        }, {
            once: !0
        }), handler({
            type: "overlay/dragStartMinimapTransition"
        }), target.style.transform = `translateY(${Math.max(prevScrollY - endYOrigin, -maxScroll + prevScrollY)}px) scale(1)`, previousRootStyleValues2 && (document.body.style.overflow = previousRootStyleValues2.body.overflow, document.body.style.height = previousRootStyleValues2.body.height, document.documentElement.style.overflow = previousRootStyleValues2.documentElement.overflow, document.documentElement.style.height = previousRootStyleValues2.documentElement.height);
    });
}
let minimapScaleApplied = !1, mousePosInverseTransform = {
    y: 0
}, mousePos = {
    x: 0,
    y: 0
}, prescaleHeight = typeof document > "u" ? 0 : document.documentElement.scrollHeight, previousRootStyleValues = null;
function handleOverlayDrag(opts) {
    const { mouseEvent, element, overlayGroup, handler, target, onSequenceStart, onSequenceEnd } = opts;
    if (mouseEvent.button !== 0) return;
    window.focus();
    const rectUpdateFrequency = 150;
    let rects = overlayGroup.map((e)=>getRect(e.elements.element));
    const flow = element.getAttribute("data-sanity-drag-flow") || calcTargetFlow(rects), dragGroup = element.getAttribute("data-sanity-drag-group"), disableMinimap = !!element.getAttribute("data-sanity-drag-minimap-disable"), preventInsertDefault = !!element.getAttribute("data-sanity-drag-prevent-default"), documentHeightOverride = element.getAttribute("data-unstable_sanity-drag-document-height"), groupHeightOverride = element.getAttribute("data-unstable_sanity-drag-group-height");
    let insertPosition = null;
    const initialMousePos = calcMousePos(mouseEvent), scaleTarget = document.body, { minYScaled, scaleFactor } = calcMinimapTransformValues(rects, groupHeightOverride ? ~~groupHeightOverride : null);
    let sequenceStarted = !1, minimapPromptShown = !1, mousedown = !0;
    minimapScaleApplied || (previousRootStyleValues = {
        body: {
            overflow: window.getComputedStyle(document.body).overflow,
            height: window.getComputedStyle(document.body).height
        },
        documentElement: {
            overflow: window.getComputedStyle(document.documentElement).overflow,
            height: window.getComputedStyle(document.documentElement).height
        }
    }, prescaleHeight = documentHeightOverride ? ~~documentHeightOverride : document.documentElement.scrollHeight);
    const rectsInterval = setInterval(()=>{
        rects = overlayGroup.map((e)=>getRect(e.elements.element));
    }, rectUpdateFrequency), applyMinimap = ()=>{
        if (scaleFactor >= 1) return;
        const skeleton = buildPreviewSkeleton(mousePos, element, scaleFactor);
        handler({
            type: "overlay/dragUpdateSkeleton",
            skeleton
        }), handler({
            type: "overlay/dragToggleMinimapPrompt",
            display: !1
        }), applyMinimapWrapperTransform(scaleTarget, scaleFactor, minYScaled, handler, rectUpdateFrequency).then(()=>{
            setTimeout(()=>{
                handler({
                    type: "overlay/dragUpdateGroupRect",
                    groupRect: calcGroupBoundsPreview(rects)
                });
            }, rectUpdateFrequency * 2);
        });
    }, handleScroll = (e)=>{
        Math.abs(e.deltaY) >= 10 && scaleFactor < 1 && !minimapScaleApplied && !minimapPromptShown && !disableMinimap && mousedown && (handler({
            type: "overlay/dragToggleMinimapPrompt",
            display: !0
        }), minimapPromptShown = !0), e.shiftKey && !minimapScaleApplied && !disableMinimap && (window.dispatchEvent(new CustomEvent("unstable_sanity/dragApplyMinimap")), minimapScaleApplied = !0, setTimeout(()=>{
            applyMinimap();
        }, 50));
    }, handleMouseMove = (e)=>{
        if (e.preventDefault(), mousePos = calcMousePos(e), mousePosInverseTransform = calcMousePosInverseTransform(mousePos), Math.abs(pointDist(mousePos, initialMousePos)) < minDragDelta) return;
        if (!sequenceStarted) {
            const groupRect = calcGroupBoundsPreview(rects), skeleton = buildPreviewSkeleton(mousePos, element, 1);
            handler({
                type: "overlay/dragStart",
                flow
            }), handler({
                type: "overlay/dragUpdateSkeleton",
                skeleton
            }), handler({
                type: "overlay/dragUpdateGroupRect",
                groupRect
            }), sequenceStarted = !0, onSequenceStart();
        }
        handler({
            type: "overlay/dragUpdateCursorPosition",
            x: mousePos.x,
            y: mousePos.y
        }), e.shiftKey && !minimapScaleApplied && !disableMinimap && (window.dispatchEvent(new CustomEvent("unstable_sanity/dragApplyMinimap")), minimapScaleApplied = !0, setTimeout(()=>{
            applyMinimap();
        }, 50));
        const newInsertPosition = calcInsertPosition(mousePos, rects, flow);
        JSON.stringify(insertPosition) !== JSON.stringify(newInsertPosition) && (insertPosition = newInsertPosition, handler({
            type: "overlay/dragUpdateInsertPosition",
            insertPosition: resolveInsertPosition(overlayGroup, insertPosition, flow)
        }));
    }, handleMouseUp = ()=>{
        mousedown = !1, handler({
            type: "overlay/dragEnd",
            target,
            insertPosition: insertPosition ? resolveInsertPosition(overlayGroup, insertPosition, flow) : null,
            dragGroup,
            flow,
            preventInsertDefault
        }), minimapPromptShown && handler({
            type: "overlay/dragToggleMinimapPrompt",
            display: !1
        }), minimapScaleApplied || (clearInterval(rectsInterval), onSequenceEnd(), removeFrameListeners(), removeKeyListeners()), removeMouseListeners();
    }, handleKeyup = (e)=>{
        if (e.key === "Shift" && minimapScaleApplied) {
            minimapScaleApplied = !1;
            const skeleton = buildPreviewSkeleton(mousePos, element, 1 / scaleFactor);
            handler({
                type: "overlay/dragUpdateSkeleton",
                skeleton
            }), window.dispatchEvent(new CustomEvent("unstable_sanity/dragResetMinimap")), setTimeout(()=>{
                resetMinimapWrapperTransform(mousePosInverseTransform.y, scaleTarget, prescaleHeight, handler, rectUpdateFrequency, previousRootStyleValues);
            }, 50), handler({
                type: "overlay/dragUpdateGroupRect",
                groupRect: null
            }), mousedown || (clearInterval(rectsInterval), removeMouseListeners(), removeFrameListeners(), removeKeyListeners(), onSequenceEnd());
        }
    }, handleBlur = ()=>{
        handler({
            type: "overlay/dragUpdateGroupRect",
            groupRect: null
        }), window.dispatchEvent(new CustomEvent("unstable_sanity/dragResetMinimap")), setTimeout(()=>{
            resetMinimapWrapperTransform(mousePosInverseTransform.y, scaleTarget, prescaleHeight, handler, rectUpdateFrequency, previousRootStyleValues).then(()=>{
                minimapScaleApplied = !1;
            });
        }, 50), clearInterval(rectsInterval), removeMouseListeners(), removeFrameListeners(), removeKeyListeners(), onSequenceEnd();
    }, removeMouseListeners = ()=>{
        window.removeEventListener("mousemove", handleMouseMove), window.removeEventListener("wheel", handleScroll), window.removeEventListener("mouseup", handleMouseUp);
    }, removeKeyListeners = ()=>{
        window.removeEventListener("keyup", handleKeyup);
    }, removeFrameListeners = ()=>{
        window.removeEventListener("blur", handleBlur);
    };
    window.addEventListener("blur", handleBlur), window.addEventListener("keyup", handleKeyup), window.addEventListener("wheel", handleScroll), window.addEventListener("mousemove", handleMouseMove), window.addEventListener("mouseup", handleMouseUp);
}
const isElementNode$1 = (target)=>target instanceof HTMLElement || target instanceof SVGElement;
function findNonInlineElement(element) {
    const { display } = window.getComputedStyle(element);
    if (display !== "inline") return element;
    const parent = element.parentElement;
    return parent ? findNonInlineElement(parent) : null;
}
const findOverlayElement = (el)=>!el || !isElementNode$1(el) ? null : el.dataset?.sanityOverlayElement ? el : findOverlayElement(el.parentElement);
function testVercelStegaRegex(input) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vercel$2f$stega$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["VERCEL_STEGA_REGEX"].lastIndex = 0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vercel$2f$stega$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["VERCEL_STEGA_REGEX"].test(input);
}
function decodeStega(str, isAltText = !1) {
    try {
        const decoded = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vercel$2f$stega$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["vercelStegaDecode"])(str);
        return !decoded || decoded.origin !== "sanity.io" ? null : (isAltText && (decoded.href = decoded.href?.replace(".alt", "")), decoded);
    } catch (err) {
        return console.error("Failed to decode stega for string: ", str, "with the original error: ", err), null;
    }
}
function testAndDecodeStega(str, isAltText = !1) {
    return testVercelStegaRegex(str) ? decodeStega(str, isAltText) : null;
}
const isElementNode = (node)=>node.nodeType === Node.ELEMENT_NODE, isImgElement = (el)=>el.tagName === "IMG", isTimeElement = (el)=>el.tagName === "TIME", isSvgRootElement = (el)=>el.tagName.toUpperCase() === "SVG";
function isSanityNode(node) {
    return "path" in node;
}
function findCommonPath(first, second) {
    let firstParts = first.split("."), secondParts = second.split(".");
    const maxLength = Math.min(firstParts.length, secondParts.length);
    return firstParts = firstParts.slice(0, maxLength).reverse(), secondParts = secondParts.slice(0, maxLength).reverse(), firstParts.reduce((parts, part, i)=>part === secondParts[i] ? [
            ...parts,
            part
        ] : [], []).reverse().join(".");
}
function findCommonSanityData(nodes) {
    if (!nodes.length || !nodes.map((n)=>isSanityNode(n)).every((n, _i, arr)=>n === arr[0])) return;
    if (!isSanityNode(nodes[0])) return nodes[0];
    const sanityNodes = nodes.filter(isSanityNode);
    let common = nodes[0];
    const consistentValueKeys = [
        "projectId",
        "dataset",
        "id",
        "baseUrl",
        "workspace",
        "tool"
    ];
    for(let i = 1; i < sanityNodes.length; i++){
        const node = sanityNodes[i];
        if (consistentValueKeys.some((key)=>node[key] !== common?.[key])) {
            common = void 0;
            break;
        }
        common.path = findCommonPath(common.path, node.path);
    }
    return common;
}
function findSanityNodes(el) {
    const elements = [];
    function addElement(element, data) {
        const sanity = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2d$csm$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decodeSanityNodeData"])(data);
        if (!sanity) return;
        const measureElement = findNonInlineElement(element);
        measureElement && elements.push({
            elements: {
                element,
                measureElement
            },
            sanity
        });
    }
    if (el) for (const node of el.childNodes){
        const { nodeType, parentElement, textContent } = node;
        if (isElementNode(node) && node.dataset?.sanityEditTarget !== void 0) {
            const nodesInTarget = findSanityNodes(node).map(({ sanity })=>sanity);
            if (!nodesInTarget.map((n)=>isSanityNode(n)).every((n, _i, arr)=>n === arr[0])) continue;
            const commonData = findCommonSanityData(nodesInTarget);
            commonData && elements.push({
                elements: {
                    element: node,
                    measureElement: node
                },
                sanity: commonData
            });
        } else if (nodeType === Node.TEXT_NODE && parentElement && textContent) {
            const data = testAndDecodeStega(textContent);
            if (!data) continue;
            addElement(parentElement, data);
        } else if (isElementNode(node)) {
            if (node.tagName === "SCRIPT" || node.tagName === "SANITY-VISUAL-EDITING") continue;
            if (node.dataset?.sanity) addElement(node, node.dataset.sanity);
            else if (node.dataset?.sanityEditInfo) addElement(node, node.dataset.sanityEditInfo);
            else if (isImgElement(node)) {
                const data = testAndDecodeStega(node.alt, !0);
                if (!data) continue;
                addElement(node, data);
                continue;
            } else if (isTimeElement(node)) {
                const data = testAndDecodeStega(node.dateTime, !0);
                if (!data) continue;
                addElement(node, data);
            } else if (isSvgRootElement(node)) {
                if (!node.ariaLabel) continue;
                const data = testAndDecodeStega(node.ariaLabel, !0);
                if (!data) continue;
                addElement(node, data);
            }
            elements.push(...findSanityNodes(node));
        }
    }
    return elements;
}
function isSanityArrayPath(path) {
    const lastDotIndex = path.lastIndexOf(".");
    return path.substring(lastDotIndex, path.length).includes("[");
}
function getSanityNodeArrayPath(path) {
    if (!isSanityArrayPath(path)) return null;
    const split = path.split(".");
    return split[split.length - 1] = split[split.length - 1].replace(/\[.*?\]/g, "[]"), split.join(".");
}
function sanityNodesExistInSameArray(sanityNode1, sanityNode2) {
    return !isSanityArrayPath(sanityNode1.path) || !isSanityArrayPath(sanityNode2.path) ? !1 : getSanityNodeArrayPath(sanityNode1.path) === getSanityNodeArrayPath(sanityNode2.path);
}
function resolveDragAndDropGroup(element, sanity, elementSet, elementsMap) {
    if (!element.getAttribute("data-sanity") || element.getAttribute("data-sanity-drag-disable") || !sanity || !isSanityNode(sanity) || !isSanityArrayPath(sanity.path)) return null;
    const targetDragGroup = element.getAttribute("data-sanity-drag-group"), group = [
        ...elementSet
    ].reduce((acc, el)=>{
        const elData = elementsMap.get(el), elDragDisabled = el.getAttribute("data-sanity-drag-disable"), elDragGroup = el.getAttribute("data-sanity-drag-group"), elHasSanityAttribution = el.getAttribute("data-sanity") !== null, sharedDragGroup = targetDragGroup !== null ? targetDragGroup === elDragGroup : !0;
        return elData && !elDragDisabled && isSanityNode(elData.sanity) && sanityNodesExistInSameArray(sanity, elData.sanity) && sharedDragGroup && elHasSanityAttribution && acc.push(elData), acc;
    }, []);
    return group.length <= 1 ? null : group;
}
function createOverlayController({ handler, overlayElement, inFrame, inPopUp, optimisticActorReady }) {
    let activated = !1;
    const elementIdMap = /* @__PURE__ */ new Map(), elementsMap = /* @__PURE__ */ new WeakMap(), elementSet = /* @__PURE__ */ new Set(), measureElements = /* @__PURE__ */ new WeakMap(), cursorMap = /* @__PURE__ */ new WeakMap();
    let ro, io, mo, activeDragSequence = !1, hoverStack = [];
    const getHoveredElement = ()=>hoverStack[hoverStack.length - 1];
    function addEventHandlers(el, handlers) {
        el.addEventListener("click", handlers.click, {
            capture: !0
        }), el.addEventListener("contextmenu", handlers.contextmenu, {
            capture: !0
        }), el.addEventListener("mousemove", handlers.mousemove, {
            once: !0,
            capture: !0
        }), el.addEventListener("mousedown", handlers.mousedown, {
            capture: !0
        });
    }
    function removeEventHandlers(el, handlers) {
        el.removeEventListener("click", handlers.click, {
            capture: !0
        }), el.removeEventListener("contextmenu", handlers.contextmenu, {
            capture: !0
        }), el.removeEventListener("mousemove", handlers.mousemove, {
            capture: !0
        }), el.removeEventListener("mousedown", handlers.mousedown, {
            capture: !0
        }), el.removeEventListener("mouseenter", handlers.mouseenter), el.removeEventListener("mouseleave", handlers.mouseleave);
    }
    function activateElement({ id, elements, handlers }) {
        const { element, measureElement } = elements;
        addEventHandlers(element, handlers), ro.observe(measureElement), handler({
            type: "element/activate",
            id
        });
    }
    function deactivateElement({ id, elements, handlers }) {
        const { element, measureElement } = elements;
        removeEventHandlers(element, handlers), ro.unobserve(measureElement), hoverStack = hoverStack.filter((el)=>el !== element), handler({
            type: "element/deactivate",
            id
        });
    }
    function setOverlayCursor(element) {
        if (!(!inFrame && !inPopUp || !optimisticActorReady)) for (const hoverstackElement of hoverStack){
            if (element === hoverstackElement) {
                const targetSanityData = elementsMap.get(element)?.sanity;
                if (!targetSanityData || !isSanityNode(targetSanityData)) return;
                if (resolveDragAndDropGroup(element, targetSanityData, elementSet, elementsMap)) {
                    const existingCursor = element.style.cursor;
                    existingCursor && cursorMap.set(element, existingCursor), handler({
                        type: "overlay/setCursor",
                        element,
                        cursor: "move"
                    });
                    continue;
                }
            }
            restoreOverlayCursor(hoverstackElement);
        }
    }
    function restoreOverlayCursor(element) {
        const previousCursor = cursorMap.get(element);
        handler({
            type: "overlay/setCursor",
            element,
            cursor: previousCursor
        });
    }
    function registerElement({ elements, sanity }) {
        const { element, measureElement } = elements, eventHandlers = {
            click (event) {
                const target = event.target;
                if (element === getHoveredElement() && element.contains(target)) {
                    inFrame && (event.preventDefault(), event.stopPropagation());
                    const sanity2 = elementsMap.get(element)?.sanity;
                    sanity2 && !activeDragSequence && handler({
                        type: "element/click",
                        id,
                        sanity: sanity2
                    });
                }
            },
            contextmenu (event) {
                if (!("path" in sanity) || !inFrame && !inPopUp || !optimisticActorReady || !sanity.path.split(".").pop()?.includes("[_key==")) return;
                const target = event.target;
                element === getHoveredElement() && element.contains(target) && ((inFrame || inPopUp) && (event.preventDefault(), event.stopPropagation()), handler({
                    type: "element/contextmenu",
                    id,
                    position: {
                        x: event.clientX,
                        y: event.clientY
                    },
                    sanity
                }));
            },
            mousedown (event) {
                if (event.preventDefault(), event.currentTarget !== hoverStack.at(-1) || element.getAttribute("data-sanity-drag-disable") || !inFrame && !inPopUp || !optimisticActorReady) return;
                const targetSanityData = elementsMap.get(element)?.sanity;
                if (!targetSanityData || !isSanityNode(targetSanityData) || !isSanityArrayPath(targetSanityData.path)) return;
                const dragGroup = resolveDragAndDropGroup(element, sanity, elementSet, elementsMap);
                dragGroup && handleOverlayDrag({
                    element,
                    handler,
                    mouseEvent: event,
                    overlayGroup: dragGroup,
                    target: targetSanityData,
                    onSequenceStart: ()=>{
                        activeDragSequence = !0;
                    },
                    onSequenceEnd: ()=>{
                        setTimeout(()=>{
                            activeDragSequence = !1;
                        }, 250);
                    }
                });
            },
            mousemove (event) {
                eventHandlers.mouseenter(event);
                const el = event.currentTarget;
                el && (el.addEventListener("mouseenter", eventHandlers.mouseenter), el.addEventListener("mouseleave", eventHandlers.mouseleave));
            },
            mouseenter () {
                document.querySelector("vercel-live-feedback") && element.closest("[data-vercel-edit-info]") || element.closest("[data-vercel-edit-target]") || (hoverStack.push(element), handler({
                    type: "element/mouseenter",
                    id,
                    rect: getRect(element)
                }), setOverlayCursor(element));
            },
            mouseleave (e) {
                function leave() {
                    hoverStack.pop();
                    const hoveredElement = getHoveredElement();
                    if (handler({
                        type: "element/mouseleave",
                        id
                    }), hoveredElement) {
                        setOverlayCursor(hoveredElement);
                        const overlayElement2 = elementsMap.get(hoveredElement);
                        overlayElement2 && handler({
                            type: "element/mouseenter",
                            id: overlayElement2.id,
                            rect: getRect(hoveredElement)
                        });
                    }
                    restoreOverlayCursor(element);
                }
                function addDeferredLeave(el) {
                    const deferredLeave = (e2)=>{
                        const { relatedTarget: relatedTarget2 } = e2;
                        findOverlayElement(relatedTarget2) ? relatedTarget2 && isElementNode$1(relatedTarget2) && (el.removeEventListener("mouseleave", deferredLeave), addDeferredLeave(relatedTarget2)) : (el.removeEventListener("mouseleave", deferredLeave), leave());
                    };
                    el.addEventListener("mouseleave", deferredLeave);
                }
                const { relatedTarget } = e, container = findOverlayElement(relatedTarget), isInteractiveOverlayElement = overlayElement.contains(container);
                if (isElementNode$1(container) && isInteractiveOverlayElement) return addDeferredLeave(container);
                leave();
            }
        }, id = v4(), sanityNode = {
            id,
            elements,
            sanity,
            handlers: eventHandlers
        };
        elementSet.add(element), measureElements.set(measureElement, element), elementIdMap.set(id, element), elementsMap.set(element, sanityNode), io?.observe(element), handler({
            type: "element/register",
            id,
            element,
            rect: getRect(element),
            sanity,
            dragDisabled: !!element.getAttribute("data-sanity-drag-disable")
        }), activated && activateElement(sanityNode);
    }
    function updateElement({ elements, sanity }) {
        const { element } = elements, overlayElement2 = elementsMap.get(element);
        overlayElement2 && (elementsMap.set(element, {
            ...overlayElement2,
            sanity
        }), handler({
            type: "element/update",
            id: overlayElement2.id,
            rect: getRect(element),
            sanity
        }));
    }
    function parseElements(node) {
        const sanityNodes = findSanityNodes(node);
        for (const sanityNode of sanityNodes){
            const { element } = sanityNode.elements;
            elementsMap.has(element) ? updateElement(sanityNode) : registerElement(sanityNode);
        }
    }
    function unregisterElement(element) {
        const overlayElement2 = elementsMap.get(element);
        if (overlayElement2) {
            const { id, handlers } = overlayElement2;
            removeEventHandlers(element, handlers), ro.unobserve(element), elementsMap.delete(element), elementSet.delete(element), elementIdMap.delete(id), handler({
                type: "element/unregister",
                id
            });
        }
    }
    function handleMutation(mutations) {
        let mutationWasInScope = !1;
        for (const mutation of mutations){
            const { target, type } = mutation, node = type === "characterData" ? target.parentElement : target;
            node === overlayElement || overlayElement.contains(node) || (mutationWasInScope = !0, isElementNode$1(node) && parseElements({
                childNodes: [
                    node
                ]
            }));
        }
        if (mutationWasInScope) for (const element of elementSet)element.isConnected || unregisterElement(element);
    }
    function updateRect(el) {
        const overlayElement2 = elementsMap.get(el);
        overlayElement2 && handler({
            type: "element/updateRect",
            id: overlayElement2.id,
            rect: getRect(el)
        });
    }
    function handleResize(entries) {
        for (const entry of entries){
            const target = entry.target;
            if (isElementNode$1(target)) {
                const element = measureElements.get(target);
                if (!element) return;
                updateRect(element);
            }
        }
    }
    function handleIntersection(entries) {
        if (activated) for (const entry of entries){
            const { target } = entry, match = isElementNode$1(target) && elementsMap.get(target);
            match && (entry.isIntersecting ? activateElement(match) : deactivateElement(match));
        }
    }
    function handleBlur(event) {
        const element = findOverlayElement(event.target);
        if (element) {
            element.dataset.sanityOverlayElement === "capture" && (event.preventDefault(), event.stopPropagation());
            return;
        }
        hoverStack = [], handler({
            type: "overlay/blur"
        });
    }
    function handleWindowResize() {
        for (const element of elementSet)updateRect(element);
    }
    function handleKeydown(event) {
        event.key === "Escape" && (hoverStack = [], handler({
            type: "overlay/blur"
        }));
    }
    function handleWindowScroll(event) {
        const { target } = event;
        if (!(target === window.document || !isElementNode$1(target))) for (const element of elementSet)target.contains(element) && updateRect(element);
    }
    function activate() {
        activated || (io = new IntersectionObserver(handleIntersection, {
            threshold: 0.3
        }), elementSet.forEach((element)=>io.observe(element)), handler({
            type: "overlay/activate"
        }), activated = !0);
    }
    function deactivate() {
        activated && (io?.disconnect(), elementSet.forEach((element)=>{
            const overlayElement2 = elementsMap.get(element);
            overlayElement2 && deactivateElement(overlayElement2);
        }), handler({
            type: "overlay/deactivate"
        }), activated = !1);
    }
    function destroy() {
        window.removeEventListener("click", handleBlur), window.removeEventListener("contextmenu", handleBlur), window.removeEventListener("keydown", handleKeydown), window.removeEventListener("resize", handleWindowResize), window.removeEventListener("scroll", handleWindowScroll), mo.disconnect(), ro.disconnect(), elementSet.forEach((element)=>{
            unregisterElement(element);
        }), elementIdMap.clear(), elementSet.clear(), hoverStack = [], deactivate();
    }
    function create() {
        window.addEventListener("click", handleBlur), window.addEventListener("contextmenu", handleBlur), window.addEventListener("keydown", handleKeydown), window.addEventListener("resize", handleWindowResize), window.addEventListener("scroll", handleWindowScroll, {
            capture: !0,
            passive: !0
        }), ro = new ResizeObserver(handleResize), mo = new MutationObserver(handleMutation), mo.observe(document.body, {
            attributes: !0,
            characterData: !0,
            childList: !0,
            subtree: !0
        }), parseElements(document.body), activate();
    }
    return window.document.fonts.ready.then(()=>{
        for (const element of elementSet)updateRect(element);
    }), create(), {
        activate,
        deactivate,
        destroy
    };
}
const SharedStateContext = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createContext"])(null);
;
 //# sourceMappingURL=SharedStateContext.js.map
}}),
"[project]/node_modules/enquire.js/src/QueryHandler.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Delegate to handle a media query being matched and unmatched.
 *
 * @param {object} options
 * @param {function} options.match callback for when the media query is matched
 * @param {function} [options.unmatch] callback for when the media query is unmatched
 * @param {function} [options.setup] one-time callback triggered the first time a query is matched
 * @param {boolean} [options.deferSetup=false] should the setup callback be run immediately, rather than first time query is matched?
 * @constructor
 */ function QueryHandler(options) {
    this.options = options;
    !options.deferSetup && this.setup();
}
QueryHandler.prototype = {
    constructor: QueryHandler,
    /**
     * coordinates setup of the handler
     *
     * @function
     */ setup: function() {
        if (this.options.setup) {
            this.options.setup();
        }
        this.initialised = true;
    },
    /**
     * coordinates setup and triggering of the handler
     *
     * @function
     */ on: function() {
        !this.initialised && this.setup();
        this.options.match && this.options.match();
    },
    /**
     * coordinates the unmatch event for the handler
     *
     * @function
     */ off: function() {
        this.options.unmatch && this.options.unmatch();
    },
    /**
     * called when a handler is to be destroyed.
     * delegates to the destroy or unmatch callbacks, depending on availability.
     *
     * @function
     */ destroy: function() {
        this.options.destroy ? this.options.destroy() : this.off();
    },
    /**
     * determines equality by reference.
     * if object is supplied compare options, if function, compare match callback
     *
     * @function
     * @param {object || function} [target] the target for comparison
     */ equals: function(target) {
        return this.options === target || this.options.match === target;
    }
};
module.exports = QueryHandler;
}}),
"[project]/node_modules/enquire.js/src/Util.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Helper function for iterating over a collection
 *
 * @param collection
 * @param fn
 */ function each(collection, fn) {
    var i = 0, length = collection.length, cont;
    for(i; i < length; i++){
        cont = fn(collection[i], i);
        if (cont === false) {
            break; //allow early exit
        }
    }
}
/**
 * Helper function for determining whether target object is an array
 *
 * @param target the object under test
 * @return {Boolean} true if array, false otherwise
 */ function isArray(target) {
    return Object.prototype.toString.apply(target) === '[object Array]';
}
/**
 * Helper function for determining whether target object is a function
 *
 * @param target the object under test
 * @return {Boolean} true if function, false otherwise
 */ function isFunction(target) {
    return typeof target === 'function';
}
module.exports = {
    isFunction: isFunction,
    isArray: isArray,
    each: each
};
}}),
"[project]/node_modules/enquire.js/src/MediaQuery.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var QueryHandler = __turbopack_context__.r("[project]/node_modules/enquire.js/src/QueryHandler.js [app-ssr] (ecmascript)");
var each = __turbopack_context__.r("[project]/node_modules/enquire.js/src/Util.js [app-ssr] (ecmascript)").each;
/**
 * Represents a single media query, manages it's state and registered handlers for this query
 *
 * @constructor
 * @param {string} query the media query string
 * @param {boolean} [isUnconditional=false] whether the media query should run regardless of whether the conditions are met. Primarily for helping older browsers deal with mobile-first design
 */ function MediaQuery(query, isUnconditional) {
    this.query = query;
    this.isUnconditional = isUnconditional;
    this.handlers = [];
    this.mql = window.matchMedia(query);
    var self = this;
    this.listener = function(mql) {
        // Chrome passes an MediaQueryListEvent object, while other browsers pass MediaQueryList directly
        self.mql = mql.currentTarget || mql;
        self.assess();
    };
    this.mql.addListener(this.listener);
}
MediaQuery.prototype = {
    constuctor: MediaQuery,
    /**
     * add a handler for this query, triggering if already active
     *
     * @param {object} handler
     * @param {function} handler.match callback for when query is activated
     * @param {function} [handler.unmatch] callback for when query is deactivated
     * @param {function} [handler.setup] callback for immediate execution when a query handler is registered
     * @param {boolean} [handler.deferSetup=false] should the setup callback be deferred until the first time the handler is matched?
     */ addHandler: function(handler) {
        var qh = new QueryHandler(handler);
        this.handlers.push(qh);
        this.matches() && qh.on();
    },
    /**
     * removes the given handler from the collection, and calls it's destroy methods
     *
     * @param {object || function} handler the handler to remove
     */ removeHandler: function(handler) {
        var handlers = this.handlers;
        each(handlers, function(h, i) {
            if (h.equals(handler)) {
                h.destroy();
                return !handlers.splice(i, 1); //remove from array and exit each early
            }
        });
    },
    /**
     * Determine whether the media query should be considered a match
     *
     * @return {Boolean} true if media query can be considered a match, false otherwise
     */ matches: function() {
        return this.mql.matches || this.isUnconditional;
    },
    /**
     * Clears all handlers and unbinds events
     */ clear: function() {
        each(this.handlers, function(handler) {
            handler.destroy();
        });
        this.mql.removeListener(this.listener);
        this.handlers.length = 0; //clear array
    },
    /*
        * Assesses the query, turning on all handlers if it matches, turning them off if it doesn't match
        */ assess: function() {
        var action = this.matches() ? 'on' : 'off';
        each(this.handlers, function(handler) {
            handler[action]();
        });
    }
};
module.exports = MediaQuery;
}}),
"[project]/node_modules/enquire.js/src/MediaQueryDispatch.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var MediaQuery = __turbopack_context__.r("[project]/node_modules/enquire.js/src/MediaQuery.js [app-ssr] (ecmascript)");
var Util = __turbopack_context__.r("[project]/node_modules/enquire.js/src/Util.js [app-ssr] (ecmascript)");
var each = Util.each;
var isFunction = Util.isFunction;
var isArray = Util.isArray;
/**
 * Allows for registration of query handlers.
 * Manages the query handler's state and is responsible for wiring up browser events
 *
 * @constructor
 */ function MediaQueryDispatch() {
    if (!window.matchMedia) {
        throw new Error('matchMedia not present, legacy browsers require a polyfill');
    }
    this.queries = {};
    this.browserIsIncapable = !window.matchMedia('only all').matches;
}
MediaQueryDispatch.prototype = {
    constructor: MediaQueryDispatch,
    /**
     * Registers a handler for the given media query
     *
     * @param {string} q the media query
     * @param {object || Array || Function} options either a single query handler object, a function, or an array of query handlers
     * @param {function} options.match fired when query matched
     * @param {function} [options.unmatch] fired when a query is no longer matched
     * @param {function} [options.setup] fired when handler first triggered
     * @param {boolean} [options.deferSetup=false] whether setup should be run immediately or deferred until query is first matched
     * @param {boolean} [shouldDegrade=false] whether this particular media query should always run on incapable browsers
     */ register: function(q, options, shouldDegrade) {
        var queries = this.queries, isUnconditional = shouldDegrade && this.browserIsIncapable;
        if (!queries[q]) {
            queries[q] = new MediaQuery(q, isUnconditional);
        }
        //normalise to object in an array
        if (isFunction(options)) {
            options = {
                match: options
            };
        }
        if (!isArray(options)) {
            options = [
                options
            ];
        }
        each(options, function(handler) {
            if (isFunction(handler)) {
                handler = {
                    match: handler
                };
            }
            queries[q].addHandler(handler);
        });
        return this;
    },
    /**
     * unregisters a query and all it's handlers, or a specific handler for a query
     *
     * @param {string} q the media query to target
     * @param {object || function} [handler] specific handler to unregister
     */ unregister: function(q, handler) {
        var query = this.queries[q];
        if (query) {
            if (handler) {
                query.removeHandler(handler);
            } else {
                query.clear();
                delete this.queries[q];
            }
        }
        return this;
    }
};
module.exports = MediaQueryDispatch;
}}),
"[project]/node_modules/enquire.js/src/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var MediaQueryDispatch = __turbopack_context__.r("[project]/node_modules/enquire.js/src/MediaQueryDispatch.js [app-ssr] (ecmascript)");
module.exports = new MediaQueryDispatch();
}}),
"[project]/node_modules/react-slick/lib/initial-state.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports["default"] = void 0;
var initialState = {
    animating: false,
    autoplaying: null,
    currentDirection: 0,
    currentLeft: null,
    currentSlide: 0,
    direction: 1,
    dragging: false,
    edgeDragged: false,
    initialized: false,
    lazyLoadedList: [],
    listHeight: null,
    listWidth: null,
    scrolling: false,
    slideCount: null,
    slideHeight: null,
    slideWidth: null,
    swipeLeft: null,
    swiped: false,
    // used by swipeEvent. differentites between touch and swipe.
    swiping: false,
    touchObject: {
        startX: 0,
        startY: 0,
        curX: 0,
        curY: 0
    },
    trackStyle: {},
    trackWidth: 0,
    targetSlide: 0
};
var _default = exports["default"] = initialState;
}}),
"[project]/node_modules/lodash.debounce/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as the `TypeError` message for "Functions" methods. */ var FUNC_ERROR_TEXT = 'Expected a function';
/** Used as references for various `Number` constants. */ var NAN = 0 / 0;
/** `Object#toString` result references. */ var symbolTag = '[object Symbol]';
/** Used to match leading and trailing whitespace. */ var reTrim = /^\s+|\s+$/g;
/** Used to detect bad signed hexadecimal string values. */ var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */ var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */ var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */ var freeParseInt = parseInt;
/** Detect free variable `global` from Node.js. */ var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
/** Detect free variable `self`. */ var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function('return this')();
/** Used for built-in method references. */ var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeMax = Math.max, nativeMin = Math.min;
/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */ var now = function() {
    return root.Date.now();
};
/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */ function debounce(func, wait, options) {
    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
    }
    wait = toNumber(wait) || 0;
    if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
    }
    function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
    }
    function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result = wait - timeSinceLastCall;
        return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
    }
    function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
            return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
        timerId = undefined;
        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
            return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
    }
    function cancel() {
        if (timerId !== undefined) {
            clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
    }
    function flush() {
        return timerId === undefined ? result : trailingEdge(now());
    }
    function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
            if (timerId === undefined) {
                return leadingEdge(lastCallTime);
            }
            if (maxing) {
                // Handle invocations in a tight loop.
                timerId = setTimeout(timerExpired, wait);
                return invokeFunc(lastCallTime);
            }
        }
        if (timerId === undefined) {
            timerId = setTimeout(timerExpired, wait);
        }
        return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return !!value && typeof value == 'object';
}
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */ function isSymbol(value) {
    return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */ function toNumber(value) {
    if (typeof value == 'number') {
        return value;
    }
    if (isSymbol(value)) {
        return NAN;
    }
    if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? other + '' : other;
    }
    if (typeof value != 'string') {
        return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, '');
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
module.exports = debounce;
}}),
"[project]/node_modules/classnames/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/ /* global define */ (function() {
    'use strict';
    var hasOwn = {}.hasOwnProperty;
    function classNames() {
        var classes = '';
        for(var i = 0; i < arguments.length; i++){
            var arg = arguments[i];
            if (arg) {
                classes = appendClass(classes, parseValue(arg));
            }
        }
        return classes;
    }
    function parseValue(arg) {
        if (typeof arg === 'string' || typeof arg === 'number') {
            return arg;
        }
        if (typeof arg !== 'object') {
            return '';
        }
        if (Array.isArray(arg)) {
            return classNames.apply(null, arg);
        }
        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {
            return arg.toString();
        }
        var classes = '';
        for(var key in arg){
            if (hasOwn.call(arg, key) && arg[key]) {
                classes = appendClass(classes, key);
            }
        }
        return classes;
    }
    function appendClass(value, newClass) {
        if (!newClass) {
            return value;
        }
        if (value) {
            return value + ' ' + newClass;
        }
        return value + newClass;
    }
    if (("TURBOPACK compile-time value", "object") !== 'undefined' && module.exports) {
        classNames.default = classNames;
        module.exports = classNames;
    } else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
        // register as 'classnames', consistent with npm package name
        ((r)=>r !== undefined && __turbopack_context__.v(r))(function() {
            return classNames;
        }());
    } else {
        window.classNames = classNames;
    }
})();
}}),
"[project]/node_modules/react-slick/lib/default-props.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports["default"] = void 0;
var _react = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    };
}
var defaultProps = {
    accessibility: true,
    adaptiveHeight: false,
    afterChange: null,
    appendDots: function appendDots(dots) {
        return /*#__PURE__*/ _react["default"].createElement("ul", {
            style: {
                display: "block"
            }
        }, dots);
    },
    arrows: true,
    autoplay: false,
    autoplaySpeed: 3000,
    beforeChange: null,
    centerMode: false,
    centerPadding: "50px",
    className: "",
    cssEase: "ease",
    customPaging: function customPaging(i) {
        return /*#__PURE__*/ _react["default"].createElement("button", null, i + 1);
    },
    dots: false,
    dotsClass: "slick-dots",
    draggable: true,
    easing: "linear",
    edgeFriction: 0.35,
    fade: false,
    focusOnSelect: false,
    infinite: true,
    initialSlide: 0,
    lazyLoad: null,
    nextArrow: null,
    onEdge: null,
    onInit: null,
    onLazyLoadError: null,
    onReInit: null,
    pauseOnDotsHover: false,
    pauseOnFocus: false,
    pauseOnHover: true,
    prevArrow: null,
    responsive: null,
    rows: 1,
    rtl: false,
    slide: "div",
    slidesPerRow: 1,
    slidesToScroll: 1,
    slidesToShow: 1,
    speed: 500,
    swipe: true,
    swipeEvent: null,
    swipeToSlide: false,
    touchMove: true,
    touchThreshold: 5,
    useCSS: true,
    useTransform: true,
    variableWidth: false,
    vertical: false,
    waitForAnimate: true,
    asNavFor: null,
    unslick: false
};
var _default = exports["default"] = defaultProps;
}}),
"[project]/node_modules/react-slick/lib/utils/innerSliderUtils.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.checkSpecKeys = exports.checkNavigable = exports.changeSlide = exports.canUseDOM = exports.canGoNext = void 0;
exports.clamp = clamp;
exports.extractObject = void 0;
exports.filterSettings = filterSettings;
exports.validSettings = exports.swipeStart = exports.swipeMove = exports.swipeEnd = exports.slidesOnRight = exports.slidesOnLeft = exports.slideHandler = exports.siblingDirection = exports.safePreventDefault = exports.lazyStartIndex = exports.lazySlidesOnRight = exports.lazySlidesOnLeft = exports.lazyEndIndex = exports.keyHandler = exports.initializedState = exports.getWidth = exports.getTrackLeft = exports.getTrackCSS = exports.getTrackAnimateCSS = exports.getTotalSlides = exports.getSwipeDirection = exports.getSlideCount = exports.getRequiredLazySlides = exports.getPreClones = exports.getPostClones = exports.getOnDemandLazySlides = exports.getNavigableIndexes = exports.getHeight = void 0;
var _react = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"));
var _defaultProps = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/react-slick/lib/default-props.js [app-ssr] (ecmascript)"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    };
}
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : String(i);
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
function clamp(number, lowerBound, upperBound) {
    return Math.max(lowerBound, Math.min(number, upperBound));
}
var safePreventDefault = exports.safePreventDefault = function safePreventDefault(event) {
    var passiveEvents = [
        "onTouchStart",
        "onTouchMove",
        "onWheel"
    ];
    if (!passiveEvents.includes(event._reactName)) {
        event.preventDefault();
    }
};
var getOnDemandLazySlides = exports.getOnDemandLazySlides = function getOnDemandLazySlides(spec) {
    var onDemandSlides = [];
    var startIndex = lazyStartIndex(spec);
    var endIndex = lazyEndIndex(spec);
    for(var slideIndex = startIndex; slideIndex < endIndex; slideIndex++){
        if (spec.lazyLoadedList.indexOf(slideIndex) < 0) {
            onDemandSlides.push(slideIndex);
        }
    }
    return onDemandSlides;
};
// return list of slides that need to be present
var getRequiredLazySlides = exports.getRequiredLazySlides = function getRequiredLazySlides(spec) {
    var requiredSlides = [];
    var startIndex = lazyStartIndex(spec);
    var endIndex = lazyEndIndex(spec);
    for(var slideIndex = startIndex; slideIndex < endIndex; slideIndex++){
        requiredSlides.push(slideIndex);
    }
    return requiredSlides;
};
// startIndex that needs to be present
var lazyStartIndex = exports.lazyStartIndex = function lazyStartIndex(spec) {
    return spec.currentSlide - lazySlidesOnLeft(spec);
};
var lazyEndIndex = exports.lazyEndIndex = function lazyEndIndex(spec) {
    return spec.currentSlide + lazySlidesOnRight(spec);
};
var lazySlidesOnLeft = exports.lazySlidesOnLeft = function lazySlidesOnLeft(spec) {
    return spec.centerMode ? Math.floor(spec.slidesToShow / 2) + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : 0;
};
var lazySlidesOnRight = exports.lazySlidesOnRight = function lazySlidesOnRight(spec) {
    return spec.centerMode ? Math.floor((spec.slidesToShow - 1) / 2) + 1 + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : spec.slidesToShow;
};
// get width of an element
var getWidth = exports.getWidth = function getWidth(elem) {
    return elem && elem.offsetWidth || 0;
};
var getHeight = exports.getHeight = function getHeight(elem) {
    return elem && elem.offsetHeight || 0;
};
var getSwipeDirection = exports.getSwipeDirection = function getSwipeDirection(touchObject) {
    var verticalSwiping = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var xDist, yDist, r, swipeAngle;
    xDist = touchObject.startX - touchObject.curX;
    yDist = touchObject.startY - touchObject.curY;
    r = Math.atan2(yDist, xDist);
    swipeAngle = Math.round(r * 180 / Math.PI);
    if (swipeAngle < 0) {
        swipeAngle = 360 - Math.abs(swipeAngle);
    }
    if (swipeAngle <= 45 && swipeAngle >= 0 || swipeAngle <= 360 && swipeAngle >= 315) {
        return "left";
    }
    if (swipeAngle >= 135 && swipeAngle <= 225) {
        return "right";
    }
    if (verticalSwiping === true) {
        if (swipeAngle >= 35 && swipeAngle <= 135) {
            return "up";
        } else {
            return "down";
        }
    }
    return "vertical";
};
// whether or not we can go next
var canGoNext = exports.canGoNext = function canGoNext(spec) {
    var canGo = true;
    if (!spec.infinite) {
        if (spec.centerMode && spec.currentSlide >= spec.slideCount - 1) {
            canGo = false;
        } else if (spec.slideCount <= spec.slidesToShow || spec.currentSlide >= spec.slideCount - spec.slidesToShow) {
            canGo = false;
        }
    }
    return canGo;
};
// given an object and a list of keys, return new object with given keys
var extractObject = exports.extractObject = function extractObject(spec, keys) {
    var newObject = {};
    keys.forEach(function(key) {
        return newObject[key] = spec[key];
    });
    return newObject;
};
// get initialized state
var initializedState = exports.initializedState = function initializedState(spec) {
    // spec also contains listRef, trackRef
    var slideCount = _react["default"].Children.count(spec.children);
    var listNode = spec.listRef;
    var listWidth = Math.ceil(getWidth(listNode));
    var trackNode = spec.trackRef && spec.trackRef.node;
    var trackWidth = Math.ceil(getWidth(trackNode));
    var slideWidth;
    if (!spec.vertical) {
        var centerPaddingAdj = spec.centerMode && parseInt(spec.centerPadding) * 2;
        if (typeof spec.centerPadding === "string" && spec.centerPadding.slice(-1) === "%") {
            centerPaddingAdj *= listWidth / 100;
        }
        slideWidth = Math.ceil((listWidth - centerPaddingAdj) / spec.slidesToShow);
    } else {
        slideWidth = listWidth;
    }
    var slideHeight = listNode && getHeight(listNode.querySelector('[data-index="0"]'));
    var listHeight = slideHeight * spec.slidesToShow;
    var currentSlide = spec.currentSlide === undefined ? spec.initialSlide : spec.currentSlide;
    if (spec.rtl && spec.currentSlide === undefined) {
        currentSlide = slideCount - 1 - spec.initialSlide;
    }
    var lazyLoadedList = spec.lazyLoadedList || [];
    var slidesToLoad = getOnDemandLazySlides(_objectSpread(_objectSpread({}, spec), {}, {
        currentSlide: currentSlide,
        lazyLoadedList: lazyLoadedList
    }));
    lazyLoadedList = lazyLoadedList.concat(slidesToLoad);
    var state = {
        slideCount: slideCount,
        slideWidth: slideWidth,
        listWidth: listWidth,
        trackWidth: trackWidth,
        currentSlide: currentSlide,
        slideHeight: slideHeight,
        listHeight: listHeight,
        lazyLoadedList: lazyLoadedList
    };
    if (spec.autoplaying === null && spec.autoplay) {
        state["autoplaying"] = "playing";
    }
    return state;
};
var slideHandler = exports.slideHandler = function slideHandler(spec) {
    var waitForAnimate = spec.waitForAnimate, animating = spec.animating, fade = spec.fade, infinite = spec.infinite, index = spec.index, slideCount = spec.slideCount, lazyLoad = spec.lazyLoad, currentSlide = spec.currentSlide, centerMode = spec.centerMode, slidesToScroll = spec.slidesToScroll, slidesToShow = spec.slidesToShow, useCSS = spec.useCSS;
    var lazyLoadedList = spec.lazyLoadedList;
    if (waitForAnimate && animating) return {};
    var animationSlide = index, finalSlide, animationLeft, finalLeft;
    var state = {}, nextState = {};
    var targetSlide = infinite ? index : clamp(index, 0, slideCount - 1);
    if (fade) {
        if (!infinite && (index < 0 || index >= slideCount)) return {};
        if (index < 0) {
            animationSlide = index + slideCount;
        } else if (index >= slideCount) {
            animationSlide = index - slideCount;
        }
        if (lazyLoad && lazyLoadedList.indexOf(animationSlide) < 0) {
            lazyLoadedList = lazyLoadedList.concat(animationSlide);
        }
        state = {
            animating: true,
            currentSlide: animationSlide,
            lazyLoadedList: lazyLoadedList,
            targetSlide: animationSlide
        };
        nextState = {
            animating: false,
            targetSlide: animationSlide
        };
    } else {
        finalSlide = animationSlide;
        if (animationSlide < 0) {
            finalSlide = animationSlide + slideCount;
            if (!infinite) finalSlide = 0;
            else if (slideCount % slidesToScroll !== 0) finalSlide = slideCount - slideCount % slidesToScroll;
        } else if (!canGoNext(spec) && animationSlide > currentSlide) {
            animationSlide = finalSlide = currentSlide;
        } else if (centerMode && animationSlide >= slideCount) {
            animationSlide = infinite ? slideCount : slideCount - 1;
            finalSlide = infinite ? 0 : slideCount - 1;
        } else if (animationSlide >= slideCount) {
            finalSlide = animationSlide - slideCount;
            if (!infinite) finalSlide = slideCount - slidesToShow;
            else if (slideCount % slidesToScroll !== 0) finalSlide = 0;
        }
        if (!infinite && animationSlide + slidesToShow >= slideCount) {
            finalSlide = slideCount - slidesToShow;
        }
        animationLeft = getTrackLeft(_objectSpread(_objectSpread({}, spec), {}, {
            slideIndex: animationSlide
        }));
        finalLeft = getTrackLeft(_objectSpread(_objectSpread({}, spec), {}, {
            slideIndex: finalSlide
        }));
        if (!infinite) {
            if (animationLeft === finalLeft) animationSlide = finalSlide;
            animationLeft = finalLeft;
        }
        if (lazyLoad) {
            lazyLoadedList = lazyLoadedList.concat(getOnDemandLazySlides(_objectSpread(_objectSpread({}, spec), {}, {
                currentSlide: animationSlide
            })));
        }
        if (!useCSS) {
            state = {
                currentSlide: finalSlide,
                trackStyle: getTrackCSS(_objectSpread(_objectSpread({}, spec), {}, {
                    left: finalLeft
                })),
                lazyLoadedList: lazyLoadedList,
                targetSlide: targetSlide
            };
        } else {
            state = {
                animating: true,
                currentSlide: finalSlide,
                trackStyle: getTrackAnimateCSS(_objectSpread(_objectSpread({}, spec), {}, {
                    left: animationLeft
                })),
                lazyLoadedList: lazyLoadedList,
                targetSlide: targetSlide
            };
            nextState = {
                animating: false,
                currentSlide: finalSlide,
                trackStyle: getTrackCSS(_objectSpread(_objectSpread({}, spec), {}, {
                    left: finalLeft
                })),
                swipeLeft: null,
                targetSlide: targetSlide
            };
        }
    }
    return {
        state: state,
        nextState: nextState
    };
};
var changeSlide = exports.changeSlide = function changeSlide(spec, options) {
    var indexOffset, previousInt, slideOffset, unevenOffset, targetSlide;
    var slidesToScroll = spec.slidesToScroll, slidesToShow = spec.slidesToShow, slideCount = spec.slideCount, currentSlide = spec.currentSlide, previousTargetSlide = spec.targetSlide, lazyLoad = spec.lazyLoad, infinite = spec.infinite;
    unevenOffset = slideCount % slidesToScroll !== 0;
    indexOffset = unevenOffset ? 0 : (slideCount - currentSlide) % slidesToScroll;
    if (options.message === "previous") {
        slideOffset = indexOffset === 0 ? slidesToScroll : slidesToShow - indexOffset;
        targetSlide = currentSlide - slideOffset;
        if (lazyLoad && !infinite) {
            previousInt = currentSlide - slideOffset;
            targetSlide = previousInt === -1 ? slideCount - 1 : previousInt;
        }
        if (!infinite) {
            targetSlide = previousTargetSlide - slidesToScroll;
        }
    } else if (options.message === "next") {
        slideOffset = indexOffset === 0 ? slidesToScroll : indexOffset;
        targetSlide = currentSlide + slideOffset;
        if (lazyLoad && !infinite) {
            targetSlide = (currentSlide + slidesToScroll) % slideCount + indexOffset;
        }
        if (!infinite) {
            targetSlide = previousTargetSlide + slidesToScroll;
        }
    } else if (options.message === "dots") {
        // Click on dots
        targetSlide = options.index * options.slidesToScroll;
    } else if (options.message === "children") {
        // Click on the slides
        targetSlide = options.index;
        if (infinite) {
            var direction = siblingDirection(_objectSpread(_objectSpread({}, spec), {}, {
                targetSlide: targetSlide
            }));
            if (targetSlide > options.currentSlide && direction === "left") {
                targetSlide = targetSlide - slideCount;
            } else if (targetSlide < options.currentSlide && direction === "right") {
                targetSlide = targetSlide + slideCount;
            }
        }
    } else if (options.message === "index") {
        targetSlide = Number(options.index);
    }
    return targetSlide;
};
var keyHandler = exports.keyHandler = function keyHandler(e, accessibility, rtl) {
    if (e.target.tagName.match("TEXTAREA|INPUT|SELECT") || !accessibility) return "";
    if (e.keyCode === 37) return rtl ? "next" : "previous";
    if (e.keyCode === 39) return rtl ? "previous" : "next";
    return "";
};
var swipeStart = exports.swipeStart = function swipeStart(e, swipe, draggable) {
    e.target.tagName === "IMG" && safePreventDefault(e);
    if (!swipe || !draggable && e.type.indexOf("mouse") !== -1) return "";
    return {
        dragging: true,
        touchObject: {
            startX: e.touches ? e.touches[0].pageX : e.clientX,
            startY: e.touches ? e.touches[0].pageY : e.clientY,
            curX: e.touches ? e.touches[0].pageX : e.clientX,
            curY: e.touches ? e.touches[0].pageY : e.clientY
        }
    };
};
var swipeMove = exports.swipeMove = function swipeMove(e, spec) {
    // spec also contains, trackRef and slideIndex
    var scrolling = spec.scrolling, animating = spec.animating, vertical = spec.vertical, swipeToSlide = spec.swipeToSlide, verticalSwiping = spec.verticalSwiping, rtl = spec.rtl, currentSlide = spec.currentSlide, edgeFriction = spec.edgeFriction, edgeDragged = spec.edgeDragged, onEdge = spec.onEdge, swiped = spec.swiped, swiping = spec.swiping, slideCount = spec.slideCount, slidesToScroll = spec.slidesToScroll, infinite = spec.infinite, touchObject = spec.touchObject, swipeEvent = spec.swipeEvent, listHeight = spec.listHeight, listWidth = spec.listWidth;
    if (scrolling) return;
    if (animating) return safePreventDefault(e);
    if (vertical && swipeToSlide && verticalSwiping) safePreventDefault(e);
    var swipeLeft, state = {};
    var curLeft = getTrackLeft(spec);
    touchObject.curX = e.touches ? e.touches[0].pageX : e.clientX;
    touchObject.curY = e.touches ? e.touches[0].pageY : e.clientY;
    touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curX - touchObject.startX, 2)));
    var verticalSwipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curY - touchObject.startY, 2)));
    if (!verticalSwiping && !swiping && verticalSwipeLength > 10) {
        return {
            scrolling: true
        };
    }
    if (verticalSwiping) touchObject.swipeLength = verticalSwipeLength;
    var positionOffset = (!rtl ? 1 : -1) * (touchObject.curX > touchObject.startX ? 1 : -1);
    if (verticalSwiping) positionOffset = touchObject.curY > touchObject.startY ? 1 : -1;
    var dotCount = Math.ceil(slideCount / slidesToScroll);
    var swipeDirection = getSwipeDirection(spec.touchObject, verticalSwiping);
    var touchSwipeLength = touchObject.swipeLength;
    if (!infinite) {
        if (currentSlide === 0 && (swipeDirection === "right" || swipeDirection === "down") || currentSlide + 1 >= dotCount && (swipeDirection === "left" || swipeDirection === "up") || !canGoNext(spec) && (swipeDirection === "left" || swipeDirection === "up")) {
            touchSwipeLength = touchObject.swipeLength * edgeFriction;
            if (edgeDragged === false && onEdge) {
                onEdge(swipeDirection);
                state["edgeDragged"] = true;
            }
        }
    }
    if (!swiped && swipeEvent) {
        swipeEvent(swipeDirection);
        state["swiped"] = true;
    }
    if (!vertical) {
        if (!rtl) {
            swipeLeft = curLeft + touchSwipeLength * positionOffset;
        } else {
            swipeLeft = curLeft - touchSwipeLength * positionOffset;
        }
    } else {
        swipeLeft = curLeft + touchSwipeLength * (listHeight / listWidth) * positionOffset;
    }
    if (verticalSwiping) {
        swipeLeft = curLeft + touchSwipeLength * positionOffset;
    }
    state = _objectSpread(_objectSpread({}, state), {}, {
        touchObject: touchObject,
        swipeLeft: swipeLeft,
        trackStyle: getTrackCSS(_objectSpread(_objectSpread({}, spec), {}, {
            left: swipeLeft
        }))
    });
    if (Math.abs(touchObject.curX - touchObject.startX) < Math.abs(touchObject.curY - touchObject.startY) * 0.8) {
        return state;
    }
    if (touchObject.swipeLength > 10) {
        state["swiping"] = true;
        safePreventDefault(e);
    }
    return state;
};
var swipeEnd = exports.swipeEnd = function swipeEnd(e, spec) {
    var dragging = spec.dragging, swipe = spec.swipe, touchObject = spec.touchObject, listWidth = spec.listWidth, touchThreshold = spec.touchThreshold, verticalSwiping = spec.verticalSwiping, listHeight = spec.listHeight, swipeToSlide = spec.swipeToSlide, scrolling = spec.scrolling, onSwipe = spec.onSwipe, targetSlide = spec.targetSlide, currentSlide = spec.currentSlide, infinite = spec.infinite;
    if (!dragging) {
        if (swipe) safePreventDefault(e);
        return {};
    }
    var minSwipe = verticalSwiping ? listHeight / touchThreshold : listWidth / touchThreshold;
    var swipeDirection = getSwipeDirection(touchObject, verticalSwiping);
    // reset the state of touch related state variables.
    var state = {
        dragging: false,
        edgeDragged: false,
        scrolling: false,
        swiping: false,
        swiped: false,
        swipeLeft: null,
        touchObject: {}
    };
    if (scrolling) {
        return state;
    }
    if (!touchObject.swipeLength) {
        return state;
    }
    if (touchObject.swipeLength > minSwipe) {
        safePreventDefault(e);
        if (onSwipe) {
            onSwipe(swipeDirection);
        }
        var slideCount, newSlide;
        var activeSlide = infinite ? currentSlide : targetSlide;
        switch(swipeDirection){
            case "left":
            case "up":
                newSlide = activeSlide + getSlideCount(spec);
                slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;
                state["currentDirection"] = 0;
                break;
            case "right":
            case "down":
                newSlide = activeSlide - getSlideCount(spec);
                slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;
                state["currentDirection"] = 1;
                break;
            default:
                slideCount = activeSlide;
        }
        state["triggerSlideHandler"] = slideCount;
    } else {
        // Adjust the track back to it's original position.
        var currentLeft = getTrackLeft(spec);
        state["trackStyle"] = getTrackAnimateCSS(_objectSpread(_objectSpread({}, spec), {}, {
            left: currentLeft
        }));
    }
    return state;
};
var getNavigableIndexes = exports.getNavigableIndexes = function getNavigableIndexes(spec) {
    var max = spec.infinite ? spec.slideCount * 2 : spec.slideCount;
    var breakpoint = spec.infinite ? spec.slidesToShow * -1 : 0;
    var counter = spec.infinite ? spec.slidesToShow * -1 : 0;
    var indexes = [];
    while(breakpoint < max){
        indexes.push(breakpoint);
        breakpoint = counter + spec.slidesToScroll;
        counter += Math.min(spec.slidesToScroll, spec.slidesToShow);
    }
    return indexes;
};
var checkNavigable = exports.checkNavigable = function checkNavigable(spec, index) {
    var navigables = getNavigableIndexes(spec);
    var prevNavigable = 0;
    if (index > navigables[navigables.length - 1]) {
        index = navigables[navigables.length - 1];
    } else {
        for(var n in navigables){
            if (index < navigables[n]) {
                index = prevNavigable;
                break;
            }
            prevNavigable = navigables[n];
        }
    }
    return index;
};
var getSlideCount = exports.getSlideCount = function getSlideCount(spec) {
    var centerOffset = spec.centerMode ? spec.slideWidth * Math.floor(spec.slidesToShow / 2) : 0;
    if (spec.swipeToSlide) {
        var swipedSlide;
        var slickList = spec.listRef;
        var slides = slickList.querySelectorAll && slickList.querySelectorAll(".slick-slide") || [];
        Array.from(slides).every(function(slide) {
            if (!spec.vertical) {
                if (slide.offsetLeft - centerOffset + getWidth(slide) / 2 > spec.swipeLeft * -1) {
                    swipedSlide = slide;
                    return false;
                }
            } else {
                if (slide.offsetTop + getHeight(slide) / 2 > spec.swipeLeft * -1) {
                    swipedSlide = slide;
                    return false;
                }
            }
            return true;
        });
        if (!swipedSlide) {
            return 0;
        }
        var currentIndex = spec.rtl === true ? spec.slideCount - spec.currentSlide : spec.currentSlide;
        var slidesTraversed = Math.abs(swipedSlide.dataset.index - currentIndex) || 1;
        return slidesTraversed;
    } else {
        return spec.slidesToScroll;
    }
};
var checkSpecKeys = exports.checkSpecKeys = function checkSpecKeys(spec, keysArray) {
    return keysArray.reduce(function(value, key) {
        return value && spec.hasOwnProperty(key);
    }, true) ? null : console.error("Keys Missing:", spec);
};
var getTrackCSS = exports.getTrackCSS = function getTrackCSS(spec) {
    checkSpecKeys(spec, [
        "left",
        "variableWidth",
        "slideCount",
        "slidesToShow",
        "slideWidth"
    ]);
    var trackWidth, trackHeight;
    var trackChildren = spec.slideCount + 2 * spec.slidesToShow;
    if (!spec.vertical) {
        trackWidth = getTotalSlides(spec) * spec.slideWidth;
    } else {
        trackHeight = trackChildren * spec.slideHeight;
    }
    var style = {
        opacity: 1,
        transition: "",
        WebkitTransition: ""
    };
    if (spec.useTransform) {
        var WebkitTransform = !spec.vertical ? "translate3d(" + spec.left + "px, 0px, 0px)" : "translate3d(0px, " + spec.left + "px, 0px)";
        var transform = !spec.vertical ? "translate3d(" + spec.left + "px, 0px, 0px)" : "translate3d(0px, " + spec.left + "px, 0px)";
        var msTransform = !spec.vertical ? "translateX(" + spec.left + "px)" : "translateY(" + spec.left + "px)";
        style = _objectSpread(_objectSpread({}, style), {}, {
            WebkitTransform: WebkitTransform,
            transform: transform,
            msTransform: msTransform
        });
    } else {
        if (spec.vertical) {
            style["top"] = spec.left;
        } else {
            style["left"] = spec.left;
        }
    }
    if (spec.fade) style = {
        opacity: 1
    };
    if (trackWidth) style.width = trackWidth;
    if (trackHeight) style.height = trackHeight;
    // Fallback for IE8
    if (window && !window.addEventListener && window.attachEvent) {
        if (!spec.vertical) {
            style.marginLeft = spec.left + "px";
        } else {
            style.marginTop = spec.left + "px";
        }
    }
    return style;
};
var getTrackAnimateCSS = exports.getTrackAnimateCSS = function getTrackAnimateCSS(spec) {
    checkSpecKeys(spec, [
        "left",
        "variableWidth",
        "slideCount",
        "slidesToShow",
        "slideWidth",
        "speed",
        "cssEase"
    ]);
    var style = getTrackCSS(spec);
    // useCSS is true by default so it can be undefined
    if (spec.useTransform) {
        style.WebkitTransition = "-webkit-transform " + spec.speed + "ms " + spec.cssEase;
        style.transition = "transform " + spec.speed + "ms " + spec.cssEase;
    } else {
        if (spec.vertical) {
            style.transition = "top " + spec.speed + "ms " + spec.cssEase;
        } else {
            style.transition = "left " + spec.speed + "ms " + spec.cssEase;
        }
    }
    return style;
};
var getTrackLeft = exports.getTrackLeft = function getTrackLeft(spec) {
    if (spec.unslick) {
        return 0;
    }
    checkSpecKeys(spec, [
        "slideIndex",
        "trackRef",
        "infinite",
        "centerMode",
        "slideCount",
        "slidesToShow",
        "slidesToScroll",
        "slideWidth",
        "listWidth",
        "variableWidth",
        "slideHeight"
    ]);
    var slideIndex = spec.slideIndex, trackRef = spec.trackRef, infinite = spec.infinite, centerMode = spec.centerMode, slideCount = spec.slideCount, slidesToShow = spec.slidesToShow, slidesToScroll = spec.slidesToScroll, slideWidth = spec.slideWidth, listWidth = spec.listWidth, variableWidth = spec.variableWidth, slideHeight = spec.slideHeight, fade = spec.fade, vertical = spec.vertical;
    var slideOffset = 0;
    var targetLeft;
    var targetSlide;
    var verticalOffset = 0;
    if (fade || spec.slideCount === 1) {
        return 0;
    }
    var slidesToOffset = 0;
    if (infinite) {
        slidesToOffset = -getPreClones(spec); // bring active slide to the beginning of visual area
        // if next scroll doesn't have enough children, just reach till the end of original slides instead of shifting slidesToScroll children
        if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {
            slidesToOffset = -(slideIndex > slideCount ? slidesToShow - (slideIndex - slideCount) : slideCount % slidesToScroll);
        }
        // shift current slide to center of the frame
        if (centerMode) {
            slidesToOffset += parseInt(slidesToShow / 2);
        }
    } else {
        if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {
            slidesToOffset = slidesToShow - slideCount % slidesToScroll;
        }
        if (centerMode) {
            slidesToOffset = parseInt(slidesToShow / 2);
        }
    }
    slideOffset = slidesToOffset * slideWidth;
    verticalOffset = slidesToOffset * slideHeight;
    if (!vertical) {
        targetLeft = slideIndex * slideWidth * -1 + slideOffset;
    } else {
        targetLeft = slideIndex * slideHeight * -1 + verticalOffset;
    }
    if (variableWidth === true) {
        var targetSlideIndex;
        var trackElem = trackRef && trackRef.node;
        targetSlideIndex = slideIndex + getPreClones(spec);
        targetSlide = trackElem && trackElem.childNodes[targetSlideIndex];
        targetLeft = targetSlide ? targetSlide.offsetLeft * -1 : 0;
        if (centerMode === true) {
            targetSlideIndex = infinite ? slideIndex + getPreClones(spec) : slideIndex;
            targetSlide = trackElem && trackElem.children[targetSlideIndex];
            targetLeft = 0;
            for(var slide = 0; slide < targetSlideIndex; slide++){
                targetLeft -= trackElem && trackElem.children[slide] && trackElem.children[slide].offsetWidth;
            }
            targetLeft -= parseInt(spec.centerPadding);
            targetLeft += targetSlide && (listWidth - targetSlide.offsetWidth) / 2;
        }
    }
    return targetLeft;
};
var getPreClones = exports.getPreClones = function getPreClones(spec) {
    if (spec.unslick || !spec.infinite) {
        return 0;
    }
    if (spec.variableWidth) {
        return spec.slideCount;
    }
    return spec.slidesToShow + (spec.centerMode ? 1 : 0);
};
var getPostClones = exports.getPostClones = function getPostClones(spec) {
    if (spec.unslick || !spec.infinite) {
        return 0;
    }
    return spec.slideCount;
};
var getTotalSlides = exports.getTotalSlides = function getTotalSlides(spec) {
    return spec.slideCount === 1 ? 1 : getPreClones(spec) + spec.slideCount + getPostClones(spec);
};
var siblingDirection = exports.siblingDirection = function siblingDirection(spec) {
    if (spec.targetSlide > spec.currentSlide) {
        if (spec.targetSlide > spec.currentSlide + slidesOnRight(spec)) {
            return "left";
        }
        return "right";
    } else {
        if (spec.targetSlide < spec.currentSlide - slidesOnLeft(spec)) {
            return "right";
        }
        return "left";
    }
};
var slidesOnRight = exports.slidesOnRight = function slidesOnRight(_ref) {
    var slidesToShow = _ref.slidesToShow, centerMode = _ref.centerMode, rtl = _ref.rtl, centerPadding = _ref.centerPadding;
    // returns no of slides on the right of active slide
    if (centerMode) {
        var right = (slidesToShow - 1) / 2 + 1;
        if (parseInt(centerPadding) > 0) right += 1;
        if (rtl && slidesToShow % 2 === 0) right += 1;
        return right;
    }
    if (rtl) {
        return 0;
    }
    return slidesToShow - 1;
};
var slidesOnLeft = exports.slidesOnLeft = function slidesOnLeft(_ref2) {
    var slidesToShow = _ref2.slidesToShow, centerMode = _ref2.centerMode, rtl = _ref2.rtl, centerPadding = _ref2.centerPadding;
    // returns no of slides on the left of active slide
    if (centerMode) {
        var left = (slidesToShow - 1) / 2 + 1;
        if (parseInt(centerPadding) > 0) left += 1;
        if (!rtl && slidesToShow % 2 === 0) left += 1;
        return left;
    }
    if (rtl) {
        return slidesToShow - 1;
    }
    return 0;
};
var canUseDOM = exports.canUseDOM = function canUseDOM() {
    return !!(typeof window !== "undefined" && window.document && window.document.createElement);
};
var validSettings = exports.validSettings = Object.keys(_defaultProps["default"]);
function filterSettings(settings) {
    return validSettings.reduce(function(acc, settingName) {
        if (settings.hasOwnProperty(settingName)) {
            acc[settingName] = settings[settingName];
        }
        return acc;
    }, {});
}
}}),
"[project]/node_modules/react-slick/lib/track.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Track = void 0;
var _react = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"));
var _classnames = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/classnames/index.js [app-ssr] (ecmascript)"));
var _innerSliderUtils = __turbopack_context__.r("[project]/node_modules/react-slick/lib/utils/innerSliderUtils.js [app-ssr] (ecmascript)");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    };
}
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function _extends() {
    _extends = ("TURBOPACK compile-time truthy", 1) ? Object.assign.bind() : ("TURBOPACK unreachable", undefined);
    return _extends.apply(this, arguments);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    Object.defineProperty(subClass, "prototype", {
        writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
    } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
    }
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct() {
    try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (t) {}
    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
        return !!t;
    })();
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : String(i);
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
// given specifications/props for a slide, fetch all the classes that need to be applied to the slide
var getSlideClasses = function getSlideClasses(spec) {
    var slickActive, slickCenter, slickCloned;
    var centerOffset, index;
    if (spec.rtl) {
        index = spec.slideCount - 1 - spec.index;
    } else {
        index = spec.index;
    }
    slickCloned = index < 0 || index >= spec.slideCount;
    if (spec.centerMode) {
        centerOffset = Math.floor(spec.slidesToShow / 2);
        slickCenter = (index - spec.currentSlide) % spec.slideCount === 0;
        if (index > spec.currentSlide - centerOffset - 1 && index <= spec.currentSlide + centerOffset) {
            slickActive = true;
        }
    } else {
        slickActive = spec.currentSlide <= index && index < spec.currentSlide + spec.slidesToShow;
    }
    var focusedSlide;
    if (spec.targetSlide < 0) {
        focusedSlide = spec.targetSlide + spec.slideCount;
    } else if (spec.targetSlide >= spec.slideCount) {
        focusedSlide = spec.targetSlide - spec.slideCount;
    } else {
        focusedSlide = spec.targetSlide;
    }
    var slickCurrent = index === focusedSlide;
    return {
        "slick-slide": true,
        "slick-active": slickActive,
        "slick-center": slickCenter,
        "slick-cloned": slickCloned,
        "slick-current": slickCurrent // dubious in case of RTL
    };
};
var getSlideStyle = function getSlideStyle(spec) {
    var style = {};
    if (spec.variableWidth === undefined || spec.variableWidth === false) {
        style.width = spec.slideWidth;
    }
    if (spec.fade) {
        style.position = "relative";
        if (spec.vertical) {
            style.top = -spec.index * parseInt(spec.slideHeight);
        } else {
            style.left = -spec.index * parseInt(spec.slideWidth);
        }
        style.opacity = spec.currentSlide === spec.index ? 1 : 0;
        style.zIndex = spec.currentSlide === spec.index ? 999 : 998;
        if (spec.useCSS) {
            style.transition = "opacity " + spec.speed + "ms " + spec.cssEase + ", " + "visibility " + spec.speed + "ms " + spec.cssEase;
        }
    }
    return style;
};
var getKey = function getKey(child, fallbackKey) {
    return child.key || fallbackKey;
};
var renderSlides = function renderSlides(spec) {
    var key;
    var slides = [];
    var preCloneSlides = [];
    var postCloneSlides = [];
    var childrenCount = _react["default"].Children.count(spec.children);
    var startIndex = (0, _innerSliderUtils.lazyStartIndex)(spec);
    var endIndex = (0, _innerSliderUtils.lazyEndIndex)(spec);
    _react["default"].Children.forEach(spec.children, function(elem, index) {
        var child;
        var childOnClickOptions = {
            message: "children",
            index: index,
            slidesToScroll: spec.slidesToScroll,
            currentSlide: spec.currentSlide
        };
        // in case of lazyLoad, whether or not we want to fetch the slide
        if (!spec.lazyLoad || spec.lazyLoad && spec.lazyLoadedList.indexOf(index) >= 0) {
            child = elem;
        } else {
            child = /*#__PURE__*/ _react["default"].createElement("div", null);
        }
        var childStyle = getSlideStyle(_objectSpread(_objectSpread({}, spec), {}, {
            index: index
        }));
        var slideClass = child.props.className || "";
        var slideClasses = getSlideClasses(_objectSpread(_objectSpread({}, spec), {}, {
            index: index
        }));
        // push a cloned element of the desired slide
        slides.push(/*#__PURE__*/ _react["default"].cloneElement(child, {
            key: "original" + getKey(child, index),
            "data-index": index,
            className: (0, _classnames["default"])(slideClasses, slideClass),
            tabIndex: "-1",
            "aria-hidden": !slideClasses["slick-active"],
            style: _objectSpread(_objectSpread({
                outline: "none"
            }, child.props.style || {}), childStyle),
            onClick: function onClick(e) {
                child.props && child.props.onClick && child.props.onClick(e);
                if (spec.focusOnSelect) {
                    spec.focusOnSelect(childOnClickOptions);
                }
            }
        }));
        // if slide needs to be precloned or postcloned
        if (spec.infinite && spec.fade === false) {
            var preCloneNo = childrenCount - index;
            if (preCloneNo <= (0, _innerSliderUtils.getPreClones)(spec)) {
                key = -preCloneNo;
                if (key >= startIndex) {
                    child = elem;
                }
                slideClasses = getSlideClasses(_objectSpread(_objectSpread({}, spec), {}, {
                    index: key
                }));
                preCloneSlides.push(/*#__PURE__*/ _react["default"].cloneElement(child, {
                    key: "precloned" + getKey(child, key),
                    "data-index": key,
                    tabIndex: "-1",
                    className: (0, _classnames["default"])(slideClasses, slideClass),
                    "aria-hidden": !slideClasses["slick-active"],
                    style: _objectSpread(_objectSpread({}, child.props.style || {}), childStyle),
                    onClick: function onClick(e) {
                        child.props && child.props.onClick && child.props.onClick(e);
                        if (spec.focusOnSelect) {
                            spec.focusOnSelect(childOnClickOptions);
                        }
                    }
                }));
            }
            key = childrenCount + index;
            if (key < endIndex) {
                child = elem;
            }
            slideClasses = getSlideClasses(_objectSpread(_objectSpread({}, spec), {}, {
                index: key
            }));
            postCloneSlides.push(/*#__PURE__*/ _react["default"].cloneElement(child, {
                key: "postcloned" + getKey(child, key),
                "data-index": key,
                tabIndex: "-1",
                className: (0, _classnames["default"])(slideClasses, slideClass),
                "aria-hidden": !slideClasses["slick-active"],
                style: _objectSpread(_objectSpread({}, child.props.style || {}), childStyle),
                onClick: function onClick(e) {
                    child.props && child.props.onClick && child.props.onClick(e);
                    if (spec.focusOnSelect) {
                        spec.focusOnSelect(childOnClickOptions);
                    }
                }
            }));
        }
    });
    if (spec.rtl) {
        return preCloneSlides.concat(slides, postCloneSlides).reverse();
    } else {
        return preCloneSlides.concat(slides, postCloneSlides);
    }
};
var Track = exports.Track = /*#__PURE__*/ function(_React$PureComponent) {
    _inherits(Track, _React$PureComponent);
    var _super = _createSuper(Track);
    function Track() {
        var _this;
        _classCallCheck(this, Track);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty(_assertThisInitialized(_this), "node", null);
        _defineProperty(_assertThisInitialized(_this), "handleRef", function(ref) {
            _this.node = ref;
        });
        return _this;
    }
    _createClass(Track, [
        {
            key: "render",
            value: function render() {
                var slides = renderSlides(this.props);
                var _this$props = this.props, onMouseEnter = _this$props.onMouseEnter, onMouseOver = _this$props.onMouseOver, onMouseLeave = _this$props.onMouseLeave;
                var mouseEvents = {
                    onMouseEnter: onMouseEnter,
                    onMouseOver: onMouseOver,
                    onMouseLeave: onMouseLeave
                };
                return /*#__PURE__*/ _react["default"].createElement("div", _extends({
                    ref: this.handleRef,
                    className: "slick-track",
                    style: this.props.trackStyle
                }, mouseEvents), slides);
            }
        }
    ]);
    return Track;
}(_react["default"].PureComponent);
}}),
"[project]/node_modules/react-slick/lib/dots.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Dots = void 0;
var _react = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"));
var _classnames = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/classnames/index.js [app-ssr] (ecmascript)"));
var _innerSliderUtils = __turbopack_context__.r("[project]/node_modules/react-slick/lib/utils/innerSliderUtils.js [app-ssr] (ecmascript)");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    };
}
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : String(i);
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    Object.defineProperty(subClass, "prototype", {
        writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
    } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
    }
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct() {
    try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (t) {}
    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
        return !!t;
    })();
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
var getDotCount = function getDotCount(spec) {
    var dots;
    if (spec.infinite) {
        dots = Math.ceil(spec.slideCount / spec.slidesToScroll);
    } else {
        dots = Math.ceil((spec.slideCount - spec.slidesToShow) / spec.slidesToScroll) + 1;
    }
    return dots;
};
var Dots = exports.Dots = /*#__PURE__*/ function(_React$PureComponent) {
    _inherits(Dots, _React$PureComponent);
    var _super = _createSuper(Dots);
    function Dots() {
        _classCallCheck(this, Dots);
        return _super.apply(this, arguments);
    }
    _createClass(Dots, [
        {
            key: "clickHandler",
            value: function clickHandler(options, e) {
                // In Autoplay the focus stays on clicked button even after transition
                // to next slide. That only goes away by click somewhere outside
                e.preventDefault();
                this.props.clickHandler(options);
            }
        },
        {
            key: "render",
            value: function render() {
                var _this$props = this.props, onMouseEnter = _this$props.onMouseEnter, onMouseOver = _this$props.onMouseOver, onMouseLeave = _this$props.onMouseLeave, infinite = _this$props.infinite, slidesToScroll = _this$props.slidesToScroll, slidesToShow = _this$props.slidesToShow, slideCount = _this$props.slideCount, currentSlide = _this$props.currentSlide;
                var dotCount = getDotCount({
                    slideCount: slideCount,
                    slidesToScroll: slidesToScroll,
                    slidesToShow: slidesToShow,
                    infinite: infinite
                });
                var mouseEvents = {
                    onMouseEnter: onMouseEnter,
                    onMouseOver: onMouseOver,
                    onMouseLeave: onMouseLeave
                };
                var dots = [];
                for(var i = 0; i < dotCount; i++){
                    var _rightBound = (i + 1) * slidesToScroll - 1;
                    var rightBound = infinite ? _rightBound : (0, _innerSliderUtils.clamp)(_rightBound, 0, slideCount - 1);
                    var _leftBound = rightBound - (slidesToScroll - 1);
                    var leftBound = infinite ? _leftBound : (0, _innerSliderUtils.clamp)(_leftBound, 0, slideCount - 1);
                    var className = (0, _classnames["default"])({
                        "slick-active": infinite ? currentSlide >= leftBound && currentSlide <= rightBound : currentSlide === leftBound
                    });
                    var dotOptions = {
                        message: "dots",
                        index: i,
                        slidesToScroll: slidesToScroll,
                        currentSlide: currentSlide
                    };
                    var onClick = this.clickHandler.bind(this, dotOptions);
                    dots = dots.concat(/*#__PURE__*/ _react["default"].createElement("li", {
                        key: i,
                        className: className
                    }, /*#__PURE__*/ _react["default"].cloneElement(this.props.customPaging(i), {
                        onClick: onClick
                    })));
                }
                return /*#__PURE__*/ _react["default"].cloneElement(this.props.appendDots(dots), _objectSpread({
                    className: this.props.dotsClass
                }, mouseEvents));
            }
        }
    ]);
    return Dots;
}(_react["default"].PureComponent);
}}),
"[project]/node_modules/react-slick/lib/arrows.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PrevArrow = exports.NextArrow = void 0;
var _react = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"));
var _classnames = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/classnames/index.js [app-ssr] (ecmascript)"));
var _innerSliderUtils = __turbopack_context__.r("[project]/node_modules/react-slick/lib/utils/innerSliderUtils.js [app-ssr] (ecmascript)");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    };
}
function _extends() {
    _extends = ("TURBOPACK compile-time truthy", 1) ? Object.assign.bind() : ("TURBOPACK unreachable", undefined);
    return _extends.apply(this, arguments);
}
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : String(i);
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    Object.defineProperty(subClass, "prototype", {
        writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
    } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
    }
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct() {
    try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (t) {}
    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
        return !!t;
    })();
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
var PrevArrow = exports.PrevArrow = /*#__PURE__*/ function(_React$PureComponent) {
    _inherits(PrevArrow, _React$PureComponent);
    var _super = _createSuper(PrevArrow);
    function PrevArrow() {
        _classCallCheck(this, PrevArrow);
        return _super.apply(this, arguments);
    }
    _createClass(PrevArrow, [
        {
            key: "clickHandler",
            value: function clickHandler(options, e) {
                if (e) {
                    e.preventDefault();
                }
                this.props.clickHandler(options, e);
            }
        },
        {
            key: "render",
            value: function render() {
                var prevClasses = {
                    "slick-arrow": true,
                    "slick-prev": true
                };
                var prevHandler = this.clickHandler.bind(this, {
                    message: "previous"
                });
                if (!this.props.infinite && (this.props.currentSlide === 0 || this.props.slideCount <= this.props.slidesToShow)) {
                    prevClasses["slick-disabled"] = true;
                    prevHandler = null;
                }
                var prevArrowProps = {
                    key: "0",
                    "data-role": "none",
                    className: (0, _classnames["default"])(prevClasses),
                    style: {
                        display: "block"
                    },
                    onClick: prevHandler
                };
                var customProps = {
                    currentSlide: this.props.currentSlide,
                    slideCount: this.props.slideCount
                };
                var prevArrow;
                if (this.props.prevArrow) {
                    prevArrow = /*#__PURE__*/ _react["default"].cloneElement(this.props.prevArrow, _objectSpread(_objectSpread({}, prevArrowProps), customProps));
                } else {
                    prevArrow = /*#__PURE__*/ _react["default"].createElement("button", _extends({
                        key: "0",
                        type: "button"
                    }, prevArrowProps), " ", "Previous");
                }
                return prevArrow;
            }
        }
    ]);
    return PrevArrow;
}(_react["default"].PureComponent);
var NextArrow = exports.NextArrow = /*#__PURE__*/ function(_React$PureComponent2) {
    _inherits(NextArrow, _React$PureComponent2);
    var _super2 = _createSuper(NextArrow);
    function NextArrow() {
        _classCallCheck(this, NextArrow);
        return _super2.apply(this, arguments);
    }
    _createClass(NextArrow, [
        {
            key: "clickHandler",
            value: function clickHandler(options, e) {
                if (e) {
                    e.preventDefault();
                }
                this.props.clickHandler(options, e);
            }
        },
        {
            key: "render",
            value: function render() {
                var nextClasses = {
                    "slick-arrow": true,
                    "slick-next": true
                };
                var nextHandler = this.clickHandler.bind(this, {
                    message: "next"
                });
                if (!(0, _innerSliderUtils.canGoNext)(this.props)) {
                    nextClasses["slick-disabled"] = true;
                    nextHandler = null;
                }
                var nextArrowProps = {
                    key: "1",
                    "data-role": "none",
                    className: (0, _classnames["default"])(nextClasses),
                    style: {
                        display: "block"
                    },
                    onClick: nextHandler
                };
                var customProps = {
                    currentSlide: this.props.currentSlide,
                    slideCount: this.props.slideCount
                };
                var nextArrow;
                if (this.props.nextArrow) {
                    nextArrow = /*#__PURE__*/ _react["default"].cloneElement(this.props.nextArrow, _objectSpread(_objectSpread({}, nextArrowProps), customProps));
                } else {
                    nextArrow = /*#__PURE__*/ _react["default"].createElement("button", _extends({
                        key: "1",
                        type: "button"
                    }, nextArrowProps), " ", "Next");
                }
                return nextArrow;
            }
        }
    ]);
    return NextArrow;
}(_react["default"].PureComponent);
}}),
"[project]/node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * A collection of shims that provide minimal functionality of the ES6 collections.
 *
 * These implementations are not meant to be used outside of the ResizeObserver
 * modules as they cover only a limited range of use cases.
 */ /* eslint-disable require-jsdoc, valid-jsdoc */ __turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var MapShim = function() {
    if (typeof Map !== 'undefined') {
        return Map;
    }
    /**
     * Returns index in provided array that matches the specified key.
     *
     * @param {Array<Array>} arr
     * @param {*} key
     * @returns {number}
     */ function getIndex(arr, key) {
        var result = -1;
        arr.some(function(entry, index) {
            if (entry[0] === key) {
                result = index;
                return true;
            }
            return false;
        });
        return result;
    }
    return function() {
        function class_1() {
            this.__entries__ = [];
        }
        Object.defineProperty(class_1.prototype, "size", {
            /**
             * @returns {boolean}
             */ get: function() {
                return this.__entries__.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {*} key
         * @returns {*}
         */ class_1.prototype.get = function(key) {
            var index = getIndex(this.__entries__, key);
            var entry = this.__entries__[index];
            return entry && entry[1];
        };
        /**
         * @param {*} key
         * @param {*} value
         * @returns {void}
         */ class_1.prototype.set = function(key, value) {
            var index = getIndex(this.__entries__, key);
            if (~index) {
                this.__entries__[index][1] = value;
            } else {
                this.__entries__.push([
                    key,
                    value
                ]);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */ class_1.prototype.delete = function(key) {
            var entries = this.__entries__;
            var index = getIndex(entries, key);
            if (~index) {
                entries.splice(index, 1);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */ class_1.prototype.has = function(key) {
            return !!~getIndex(this.__entries__, key);
        };
        /**
         * @returns {void}
         */ class_1.prototype.clear = function() {
            this.__entries__.splice(0);
        };
        /**
         * @param {Function} callback
         * @param {*} [ctx=null]
         * @returns {void}
         */ class_1.prototype.forEach = function(callback, ctx) {
            if (ctx === void 0) {
                ctx = null;
            }
            for(var _i = 0, _a = this.__entries__; _i < _a.length; _i++){
                var entry = _a[_i];
                callback.call(ctx, entry[1], entry[0]);
            }
        };
        return class_1;
    }();
}();
/**
 * Detects whether window and document objects are available in current environment.
 */ var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;
// Returns global object of a current environment.
var global$1 = function() {
    if (typeof global !== 'undefined' && global.Math === Math) {
        return global;
    }
    if (typeof self !== 'undefined' && self.Math === Math) {
        return self;
    }
    if (typeof window !== 'undefined' && window.Math === Math) {
        return window;
    }
    // eslint-disable-next-line no-new-func
    return Function('return this')();
}();
/**
 * A shim for the requestAnimationFrame which falls back to the setTimeout if
 * first one is not supported.
 *
 * @returns {number} Requests' identifier.
 */ var requestAnimationFrame$1 = function() {
    if (typeof requestAnimationFrame === 'function') {
        // It's required to use a bounded function because IE sometimes throws
        // an "Invalid calling object" error if rAF is invoked without the global
        // object on the left hand side.
        return requestAnimationFrame.bind(global$1);
    }
    return function(callback) {
        return setTimeout(function() {
            return callback(Date.now());
        }, 1000 / 60);
    };
}();
// Defines minimum timeout before adding a trailing call.
var trailingTimeout = 2;
/**
 * Creates a wrapper function which ensures that provided callback will be
 * invoked only once during the specified delay period.
 *
 * @param {Function} callback - Function to be invoked after the delay period.
 * @param {number} delay - Delay after which to invoke callback.
 * @returns {Function}
 */ function throttle(callback, delay) {
    var leadingCall = false, trailingCall = false, lastCallTime = 0;
    /**
     * Invokes the original callback function and schedules new invocation if
     * the "proxy" was called during current request.
     *
     * @returns {void}
     */ function resolvePending() {
        if (leadingCall) {
            leadingCall = false;
            callback();
        }
        if (trailingCall) {
            proxy();
        }
    }
    /**
     * Callback invoked after the specified delay. It will further postpone
     * invocation of the original function delegating it to the
     * requestAnimationFrame.
     *
     * @returns {void}
     */ function timeoutCallback() {
        requestAnimationFrame$1(resolvePending);
    }
    /**
     * Schedules invocation of the original function.
     *
     * @returns {void}
     */ function proxy() {
        var timeStamp = Date.now();
        if (leadingCall) {
            // Reject immediately following calls.
            if (timeStamp - lastCallTime < trailingTimeout) {
                return;
            }
            // Schedule new call to be in invoked when the pending one is resolved.
            // This is important for "transitions" which never actually start
            // immediately so there is a chance that we might miss one if change
            // happens amids the pending invocation.
            trailingCall = true;
        } else {
            leadingCall = true;
            trailingCall = false;
            setTimeout(timeoutCallback, delay);
        }
        lastCallTime = timeStamp;
    }
    return proxy;
}
// Minimum delay before invoking the update of observers.
var REFRESH_DELAY = 20;
// A list of substrings of CSS properties used to find transition events that
// might affect dimensions of observed elements.
var transitionKeys = [
    'top',
    'right',
    'bottom',
    'left',
    'width',
    'height',
    'size',
    'weight'
];
// Check if MutationObserver is available.
var mutationObserverSupported = typeof MutationObserver !== 'undefined';
/**
 * Singleton controller class which handles updates of ResizeObserver instances.
 */ var ResizeObserverController = function() {
    /**
     * Creates a new instance of ResizeObserverController.
     *
     * @private
     */ function ResizeObserverController() {
        /**
         * Indicates whether DOM listeners have been added.
         *
         * @private {boolean}
         */ this.connected_ = false;
        /**
         * Tells that controller has subscribed for Mutation Events.
         *
         * @private {boolean}
         */ this.mutationEventsAdded_ = false;
        /**
         * Keeps reference to the instance of MutationObserver.
         *
         * @private {MutationObserver}
         */ this.mutationsObserver_ = null;
        /**
         * A list of connected observers.
         *
         * @private {Array<ResizeObserverSPI>}
         */ this.observers_ = [];
        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    /**
     * Adds observer to observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be added.
     * @returns {void}
     */ ResizeObserverController.prototype.addObserver = function(observer) {
        if (!~this.observers_.indexOf(observer)) {
            this.observers_.push(observer);
        }
        // Add listeners if they haven't been added yet.
        if (!this.connected_) {
            this.connect_();
        }
    };
    /**
     * Removes observer from observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be removed.
     * @returns {void}
     */ ResizeObserverController.prototype.removeObserver = function(observer) {
        var observers = this.observers_;
        var index = observers.indexOf(observer);
        // Remove observer if it's present in registry.
        if (~index) {
            observers.splice(index, 1);
        }
        // Remove listeners if controller has no connected observers.
        if (!observers.length && this.connected_) {
            this.disconnect_();
        }
    };
    /**
     * Invokes the update of observers. It will continue running updates insofar
     * it detects changes.
     *
     * @returns {void}
     */ ResizeObserverController.prototype.refresh = function() {
        var changesDetected = this.updateObservers_();
        // Continue running updates if changes have been detected as there might
        // be future ones caused by CSS transitions.
        if (changesDetected) {
            this.refresh();
        }
    };
    /**
     * Updates every observer from observers list and notifies them of queued
     * entries.
     *
     * @private
     * @returns {boolean} Returns "true" if any observer has detected changes in
     *      dimensions of it's elements.
     */ ResizeObserverController.prototype.updateObservers_ = function() {
        // Collect observers that have active observations.
        var activeObservers = this.observers_.filter(function(observer) {
            return observer.gatherActive(), observer.hasActive();
        });
        // Deliver notifications in a separate cycle in order to avoid any
        // collisions between observers, e.g. when multiple instances of
        // ResizeObserver are tracking the same element and the callback of one
        // of them changes content dimensions of the observed target. Sometimes
        // this may result in notifications being blocked for the rest of observers.
        activeObservers.forEach(function(observer) {
            return observer.broadcastActive();
        });
        return activeObservers.length > 0;
    };
    /**
     * Initializes DOM listeners.
     *
     * @private
     * @returns {void}
     */ ResizeObserverController.prototype.connect_ = function() {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already added.
        if (!isBrowser || this.connected_) {
            return;
        }
        // Subscription to the "Transitionend" event is used as a workaround for
        // delayed transitions. This way it's possible to capture at least the
        // final state of an element.
        document.addEventListener('transitionend', this.onTransitionEnd_);
        window.addEventListener('resize', this.refresh);
        if (mutationObserverSupported) {
            this.mutationsObserver_ = new MutationObserver(this.refresh);
            this.mutationsObserver_.observe(document, {
                attributes: true,
                childList: true,
                characterData: true,
                subtree: true
            });
        } else {
            document.addEventListener('DOMSubtreeModified', this.refresh);
            this.mutationEventsAdded_ = true;
        }
        this.connected_ = true;
    };
    /**
     * Removes DOM listeners.
     *
     * @private
     * @returns {void}
     */ ResizeObserverController.prototype.disconnect_ = function() {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already removed.
        if (!isBrowser || !this.connected_) {
            return;
        }
        document.removeEventListener('transitionend', this.onTransitionEnd_);
        window.removeEventListener('resize', this.refresh);
        if (this.mutationsObserver_) {
            this.mutationsObserver_.disconnect();
        }
        if (this.mutationEventsAdded_) {
            document.removeEventListener('DOMSubtreeModified', this.refresh);
        }
        this.mutationsObserver_ = null;
        this.mutationEventsAdded_ = false;
        this.connected_ = false;
    };
    /**
     * "Transitionend" event handler.
     *
     * @private
     * @param {TransitionEvent} event
     * @returns {void}
     */ ResizeObserverController.prototype.onTransitionEnd_ = function(_a) {
        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;
        // Detect whether transition may affect dimensions of an element.
        var isReflowProperty = transitionKeys.some(function(key) {
            return !!~propertyName.indexOf(key);
        });
        if (isReflowProperty) {
            this.refresh();
        }
    };
    /**
     * Returns instance of the ResizeObserverController.
     *
     * @returns {ResizeObserverController}
     */ ResizeObserverController.getInstance = function() {
        if (!this.instance_) {
            this.instance_ = new ResizeObserverController();
        }
        return this.instance_;
    };
    /**
     * Holds reference to the controller's instance.
     *
     * @private {ResizeObserverController}
     */ ResizeObserverController.instance_ = null;
    return ResizeObserverController;
}();
/**
 * Defines non-writable/enumerable properties of the provided target object.
 *
 * @param {Object} target - Object for which to define properties.
 * @param {Object} props - Properties to be defined.
 * @returns {Object} Target object.
 */ var defineConfigurable = function(target, props) {
    for(var _i = 0, _a = Object.keys(props); _i < _a.length; _i++){
        var key = _a[_i];
        Object.defineProperty(target, key, {
            value: props[key],
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    return target;
};
/**
 * Returns the global object associated with provided element.
 *
 * @param {Object} target
 * @returns {Object}
 */ var getWindowOf = function(target) {
    // Assume that the element is an instance of Node, which means that it
    // has the "ownerDocument" property from which we can retrieve a
    // corresponding global object.
    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
    // Return the local global object if it's not possible extract one from
    // provided element.
    return ownerGlobal || global$1;
};
// Placeholder of an empty content rectangle.
var emptyRect = createRectInit(0, 0, 0, 0);
/**
 * Converts provided string to a number.
 *
 * @param {number|string} value
 * @returns {number}
 */ function toFloat(value) {
    return parseFloat(value) || 0;
}
/**
 * Extracts borders size from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @param {...string} positions - Borders positions (top, right, ...)
 * @returns {number}
 */ function getBordersSize(styles) {
    var positions = [];
    for(var _i = 1; _i < arguments.length; _i++){
        positions[_i - 1] = arguments[_i];
    }
    return positions.reduce(function(size, position) {
        var value = styles['border-' + position + '-width'];
        return size + toFloat(value);
    }, 0);
}
/**
 * Extracts paddings sizes from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @returns {Object} Paddings box.
 */ function getPaddings(styles) {
    var positions = [
        'top',
        'right',
        'bottom',
        'left'
    ];
    var paddings = {};
    for(var _i = 0, positions_1 = positions; _i < positions_1.length; _i++){
        var position = positions_1[_i];
        var value = styles['padding-' + position];
        paddings[position] = toFloat(value);
    }
    return paddings;
}
/**
 * Calculates content rectangle of provided SVG element.
 *
 * @param {SVGGraphicsElement} target - Element content rectangle of which needs
 *      to be calculated.
 * @returns {DOMRectInit}
 */ function getSVGContentRect(target) {
    var bbox = target.getBBox();
    return createRectInit(0, 0, bbox.width, bbox.height);
}
/**
 * Calculates content rectangle of provided HTMLElement.
 *
 * @param {HTMLElement} target - Element for which to calculate the content rectangle.
 * @returns {DOMRectInit}
 */ function getHTMLElementContentRect(target) {
    // Client width & height properties can't be
    // used exclusively as they provide rounded values.
    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
    // By this condition we can catch all non-replaced inline, hidden and
    // detached elements. Though elements with width & height properties less
    // than 0.5 will be discarded as well.
    //
    // Without it we would need to implement separate methods for each of
    // those cases and it's not possible to perform a precise and performance
    // effective test for hidden elements. E.g. even jQuery's ':visible' filter
    // gives wrong results for elements with width & height less than 0.5.
    if (!clientWidth && !clientHeight) {
        return emptyRect;
    }
    var styles = getWindowOf(target).getComputedStyle(target);
    var paddings = getPaddings(styles);
    var horizPad = paddings.left + paddings.right;
    var vertPad = paddings.top + paddings.bottom;
    // Computed styles of width & height are being used because they are the
    // only dimensions available to JS that contain non-rounded values. It could
    // be possible to utilize the getBoundingClientRect if only it's data wasn't
    // affected by CSS transformations let alone paddings, borders and scroll bars.
    var width = toFloat(styles.width), height = toFloat(styles.height);
    // Width & height include paddings and borders when the 'border-box' box
    // model is applied (except for IE).
    if (styles.boxSizing === 'border-box') {
        // Following conditions are required to handle Internet Explorer which
        // doesn't include paddings and borders to computed CSS dimensions.
        //
        // We can say that if CSS dimensions + paddings are equal to the "client"
        // properties then it's either IE, and thus we don't need to subtract
        // anything, or an element merely doesn't have paddings/borders styles.
        if (Math.round(width + horizPad) !== clientWidth) {
            width -= getBordersSize(styles, 'left', 'right') + horizPad;
        }
        if (Math.round(height + vertPad) !== clientHeight) {
            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
        }
    }
    // Following steps can't be applied to the document's root element as its
    // client[Width/Height] properties represent viewport area of the window.
    // Besides, it's as well not necessary as the <html> itself neither has
    // rendered scroll bars nor it can be clipped.
    if (!isDocumentElement(target)) {
        // In some browsers (only in Firefox, actually) CSS width & height
        // include scroll bars size which can be removed at this step as scroll
        // bars are the only difference between rounded dimensions + paddings
        // and "client" properties, though that is not always true in Chrome.
        var vertScrollbar = Math.round(width + horizPad) - clientWidth;
        var horizScrollbar = Math.round(height + vertPad) - clientHeight;
        // Chrome has a rather weird rounding of "client" properties.
        // E.g. for an element with content width of 314.2px it sometimes gives
        // the client width of 315px and for the width of 314.7px it may give
        // 314px. And it doesn't happen all the time. So just ignore this delta
        // as a non-relevant.
        if (Math.abs(vertScrollbar) !== 1) {
            width -= vertScrollbar;
        }
        if (Math.abs(horizScrollbar) !== 1) {
            height -= horizScrollbar;
        }
    }
    return createRectInit(paddings.left, paddings.top, width, height);
}
/**
 * Checks whether provided element is an instance of the SVGGraphicsElement.
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */ var isSVGGraphicsElement = function() {
    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
    // interface.
    if (typeof SVGGraphicsElement !== 'undefined') {
        return function(target) {
            return target instanceof getWindowOf(target).SVGGraphicsElement;
        };
    }
    // If it's so, then check that element is at least an instance of the
    // SVGElement and that it has the "getBBox" method.
    // eslint-disable-next-line no-extra-parens
    return function(target) {
        return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === 'function';
    };
}();
/**
 * Checks whether provided element is a document element (<html>).
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */ function isDocumentElement(target) {
    return target === getWindowOf(target).document.documentElement;
}
/**
 * Calculates an appropriate content rectangle for provided html or svg element.
 *
 * @param {Element} target - Element content rectangle of which needs to be calculated.
 * @returns {DOMRectInit}
 */ function getContentRect(target) {
    if (!isBrowser) {
        return emptyRect;
    }
    if (isSVGGraphicsElement(target)) {
        return getSVGContentRect(target);
    }
    return getHTMLElementContentRect(target);
}
/**
 * Creates rectangle with an interface of the DOMRectReadOnly.
 * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
 *
 * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
 * @returns {DOMRectReadOnly}
 */ function createReadOnlyRect(_a) {
    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
    // If DOMRectReadOnly is available use it as a prototype for the rectangle.
    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
    var rect = Object.create(Constr.prototype);
    // Rectangle's properties are not writable and non-enumerable.
    defineConfigurable(rect, {
        x: x,
        y: y,
        width: width,
        height: height,
        top: y,
        right: x + width,
        bottom: height + y,
        left: x
    });
    return rect;
}
/**
 * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
 * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
 *
 * @param {number} x - X coordinate.
 * @param {number} y - Y coordinate.
 * @param {number} width - Rectangle's width.
 * @param {number} height - Rectangle's height.
 * @returns {DOMRectInit}
 */ function createRectInit(x, y, width, height) {
    return {
        x: x,
        y: y,
        width: width,
        height: height
    };
}
/**
 * Class that is responsible for computations of the content rectangle of
 * provided DOM element and for keeping track of it's changes.
 */ var ResizeObservation = function() {
    /**
     * Creates an instance of ResizeObservation.
     *
     * @param {Element} target - Element to be observed.
     */ function ResizeObservation(target) {
        /**
         * Broadcasted width of content rectangle.
         *
         * @type {number}
         */ this.broadcastWidth = 0;
        /**
         * Broadcasted height of content rectangle.
         *
         * @type {number}
         */ this.broadcastHeight = 0;
        /**
         * Reference to the last observed content rectangle.
         *
         * @private {DOMRectInit}
         */ this.contentRect_ = createRectInit(0, 0, 0, 0);
        this.target = target;
    }
    /**
     * Updates content rectangle and tells whether it's width or height properties
     * have changed since the last broadcast.
     *
     * @returns {boolean}
     */ ResizeObservation.prototype.isActive = function() {
        var rect = getContentRect(this.target);
        this.contentRect_ = rect;
        return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
    };
    /**
     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
     * from the corresponding properties of the last observed content rectangle.
     *
     * @returns {DOMRectInit} Last observed content rectangle.
     */ ResizeObservation.prototype.broadcastRect = function() {
        var rect = this.contentRect_;
        this.broadcastWidth = rect.width;
        this.broadcastHeight = rect.height;
        return rect;
    };
    return ResizeObservation;
}();
var ResizeObserverEntry = function() {
    /**
     * Creates an instance of ResizeObserverEntry.
     *
     * @param {Element} target - Element that is being observed.
     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
     */ function ResizeObserverEntry(target, rectInit) {
        var contentRect = createReadOnlyRect(rectInit);
        // According to the specification following properties are not writable
        // and are also not enumerable in the native implementation.
        //
        // Property accessors are not being used as they'd require to define a
        // private WeakMap storage which may cause memory leaks in browsers that
        // don't support this type of collections.
        defineConfigurable(this, {
            target: target,
            contentRect: contentRect
        });
    }
    return ResizeObserverEntry;
}();
var ResizeObserverSPI = function() {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback function that is invoked
     *      when one of the observed elements changes it's content dimensions.
     * @param {ResizeObserverController} controller - Controller instance which
     *      is responsible for the updates of observer.
     * @param {ResizeObserver} callbackCtx - Reference to the public
     *      ResizeObserver instance which will be passed to callback function.
     */ function ResizeObserverSPI(callback, controller, callbackCtx) {
        /**
         * Collection of resize observations that have detected changes in dimensions
         * of elements.
         *
         * @private {Array<ResizeObservation>}
         */ this.activeObservations_ = [];
        /**
         * Registry of the ResizeObservation instances.
         *
         * @private {Map<Element, ResizeObservation>}
         */ this.observations_ = new MapShim();
        if (typeof callback !== 'function') {
            throw new TypeError('The callback provided as parameter 1 is not a function.');
        }
        this.callback_ = callback;
        this.controller_ = controller;
        this.callbackCtx_ = callbackCtx;
    }
    /**
     * Starts observing provided element.
     *
     * @param {Element} target - Element to be observed.
     * @returns {void}
     */ ResizeObserverSPI.prototype.observe = function(target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is already being observed.
        if (observations.has(target)) {
            return;
        }
        observations.set(target, new ResizeObservation(target));
        this.controller_.addObserver(this);
        // Force the update of observations.
        this.controller_.refresh();
    };
    /**
     * Stops observing provided element.
     *
     * @param {Element} target - Element to stop observing.
     * @returns {void}
     */ ResizeObserverSPI.prototype.unobserve = function(target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is not being observed.
        if (!observations.has(target)) {
            return;
        }
        observations.delete(target);
        if (!observations.size) {
            this.controller_.removeObserver(this);
        }
    };
    /**
     * Stops observing all elements.
     *
     * @returns {void}
     */ ResizeObserverSPI.prototype.disconnect = function() {
        this.clearActive();
        this.observations_.clear();
        this.controller_.removeObserver(this);
    };
    /**
     * Collects observation instances the associated element of which has changed
     * it's content rectangle.
     *
     * @returns {void}
     */ ResizeObserverSPI.prototype.gatherActive = function() {
        var _this = this;
        this.clearActive();
        this.observations_.forEach(function(observation) {
            if (observation.isActive()) {
                _this.activeObservations_.push(observation);
            }
        });
    };
    /**
     * Invokes initial callback function with a list of ResizeObserverEntry
     * instances collected from active resize observations.
     *
     * @returns {void}
     */ ResizeObserverSPI.prototype.broadcastActive = function() {
        // Do nothing if observer doesn't have active observations.
        if (!this.hasActive()) {
            return;
        }
        var ctx = this.callbackCtx_;
        // Create ResizeObserverEntry instance for every active observation.
        var entries = this.activeObservations_.map(function(observation) {
            return new ResizeObserverEntry(observation.target, observation.broadcastRect());
        });
        this.callback_.call(ctx, entries, ctx);
        this.clearActive();
    };
    /**
     * Clears the collection of active observations.
     *
     * @returns {void}
     */ ResizeObserverSPI.prototype.clearActive = function() {
        this.activeObservations_.splice(0);
    };
    /**
     * Tells whether observer has active observations.
     *
     * @returns {boolean}
     */ ResizeObserverSPI.prototype.hasActive = function() {
        return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI;
}();
// Registry of internal observers. If WeakMap is not available use current shim
// for the Map collection as it has all required methods and because WeakMap
// can't be fully polyfilled anyway.
var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
/**
 * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
 * exposing only those methods and properties that are defined in the spec.
 */ var ResizeObserver = function() {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback that is invoked when
     *      dimensions of the observed elements change.
     */ function ResizeObserver(callback) {
        if (!(this instanceof ResizeObserver)) {
            throw new TypeError('Cannot call a class as a function.');
        }
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        var controller = ResizeObserverController.getInstance();
        var observer = new ResizeObserverSPI(callback, controller, this);
        observers.set(this, observer);
    }
    return ResizeObserver;
}();
// Expose public methods of ResizeObserver.
[
    'observe',
    'unobserve',
    'disconnect'
].forEach(function(method) {
    ResizeObserver.prototype[method] = function() {
        var _a;
        return (_a = observers.get(this))[method].apply(_a, arguments);
    };
});
var index = function() {
    // Export existing implementation if available.
    if (typeof global$1.ResizeObserver !== 'undefined') {
        return global$1.ResizeObserver;
    }
    return ResizeObserver;
}();
const __TURBOPACK__default__export__ = index;
}}),
"[project]/node_modules/react-slick/lib/inner-slider.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InnerSlider = void 0;
var _react = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"));
var _initialState = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/react-slick/lib/initial-state.js [app-ssr] (ecmascript)"));
var _lodash = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/lodash.debounce/index.js [app-ssr] (ecmascript)"));
var _classnames = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/classnames/index.js [app-ssr] (ecmascript)"));
var _innerSliderUtils = __turbopack_context__.r("[project]/node_modules/react-slick/lib/utils/innerSliderUtils.js [app-ssr] (ecmascript)");
var _track = __turbopack_context__.r("[project]/node_modules/react-slick/lib/track.js [app-ssr] (ecmascript)");
var _dots = __turbopack_context__.r("[project]/node_modules/react-slick/lib/dots.js [app-ssr] (ecmascript)");
var _arrows = __turbopack_context__.r("[project]/node_modules/react-slick/lib/arrows.js [app-ssr] (ecmascript)");
var _resizeObserverPolyfill = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js [app-ssr] (ecmascript)"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    };
}
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function _extends() {
    _extends = ("TURBOPACK compile-time truthy", 1) ? Object.assign.bind() : ("TURBOPACK unreachable", undefined);
    return _extends.apply(this, arguments);
}
function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for(i = 0; i < sourceSymbolKeys.length; i++){
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
        }
    }
    return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    Object.defineProperty(subClass, "prototype", {
        writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
    } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
    }
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct() {
    try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (t) {}
    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
        return !!t;
    })();
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : String(i);
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var InnerSlider = exports.InnerSlider = /*#__PURE__*/ function(_React$Component) {
    _inherits(InnerSlider, _React$Component);
    var _super = _createSuper(InnerSlider);
    function InnerSlider(props) {
        var _this;
        _classCallCheck(this, InnerSlider);
        _this = _super.call(this, props);
        _defineProperty(_assertThisInitialized(_this), "listRefHandler", function(ref) {
            return _this.list = ref;
        });
        _defineProperty(_assertThisInitialized(_this), "trackRefHandler", function(ref) {
            return _this.track = ref;
        });
        _defineProperty(_assertThisInitialized(_this), "adaptHeight", function() {
            if (_this.props.adaptiveHeight && _this.list) {
                var elem = _this.list.querySelector("[data-index=\"".concat(_this.state.currentSlide, "\"]"));
                _this.list.style.height = (0, _innerSliderUtils.getHeight)(elem) + "px";
            }
        });
        _defineProperty(_assertThisInitialized(_this), "componentDidMount", function() {
            _this.props.onInit && _this.props.onInit();
            if (_this.props.lazyLoad) {
                var slidesToLoad = (0, _innerSliderUtils.getOnDemandLazySlides)(_objectSpread(_objectSpread({}, _this.props), _this.state));
                if (slidesToLoad.length > 0) {
                    _this.setState(function(prevState) {
                        return {
                            lazyLoadedList: prevState.lazyLoadedList.concat(slidesToLoad)
                        };
                    });
                    if (_this.props.onLazyLoad) {
                        _this.props.onLazyLoad(slidesToLoad);
                    }
                }
            }
            var spec = _objectSpread({
                listRef: _this.list,
                trackRef: _this.track
            }, _this.props);
            _this.updateState(spec, true, function() {
                _this.adaptHeight();
                _this.props.autoplay && _this.autoPlay("update");
            });
            if (_this.props.lazyLoad === "progressive") {
                _this.lazyLoadTimer = setInterval(_this.progressiveLazyLoad, 1000);
            }
            _this.ro = new _resizeObserverPolyfill["default"](function() {
                if (_this.state.animating) {
                    _this.onWindowResized(false); // don't set trackStyle hence don't break animation
                    _this.callbackTimers.push(setTimeout(function() {
                        return _this.onWindowResized();
                    }, _this.props.speed));
                } else {
                    _this.onWindowResized();
                }
            });
            _this.ro.observe(_this.list);
            document.querySelectorAll && Array.prototype.forEach.call(document.querySelectorAll(".slick-slide"), function(slide) {
                slide.onfocus = _this.props.pauseOnFocus ? _this.onSlideFocus : null;
                slide.onblur = _this.props.pauseOnFocus ? _this.onSlideBlur : null;
            });
            if (window.addEventListener) {
                window.addEventListener("resize", _this.onWindowResized);
            } else {
                window.attachEvent("onresize", _this.onWindowResized);
            }
        });
        _defineProperty(_assertThisInitialized(_this), "componentWillUnmount", function() {
            if (_this.animationEndCallback) {
                clearTimeout(_this.animationEndCallback);
            }
            if (_this.lazyLoadTimer) {
                clearInterval(_this.lazyLoadTimer);
            }
            if (_this.callbackTimers.length) {
                _this.callbackTimers.forEach(function(timer) {
                    return clearTimeout(timer);
                });
                _this.callbackTimers = [];
            }
            if (window.addEventListener) {
                window.removeEventListener("resize", _this.onWindowResized);
            } else {
                window.detachEvent("onresize", _this.onWindowResized);
            }
            if (_this.autoplayTimer) {
                clearInterval(_this.autoplayTimer);
            }
            _this.ro.disconnect();
        });
        _defineProperty(_assertThisInitialized(_this), "componentDidUpdate", function(prevProps) {
            _this.checkImagesLoad();
            _this.props.onReInit && _this.props.onReInit();
            if (_this.props.lazyLoad) {
                var slidesToLoad = (0, _innerSliderUtils.getOnDemandLazySlides)(_objectSpread(_objectSpread({}, _this.props), _this.state));
                if (slidesToLoad.length > 0) {
                    _this.setState(function(prevState) {
                        return {
                            lazyLoadedList: prevState.lazyLoadedList.concat(slidesToLoad)
                        };
                    });
                    if (_this.props.onLazyLoad) {
                        _this.props.onLazyLoad(slidesToLoad);
                    }
                }
            }
            // if (this.props.onLazyLoad) {
            //   this.props.onLazyLoad([leftMostSlide])
            // }
            _this.adaptHeight();
            var spec = _objectSpread(_objectSpread({
                listRef: _this.list,
                trackRef: _this.track
            }, _this.props), _this.state);
            var setTrackStyle = _this.didPropsChange(prevProps);
            setTrackStyle && _this.updateState(spec, setTrackStyle, function() {
                if (_this.state.currentSlide >= _react["default"].Children.count(_this.props.children)) {
                    _this.changeSlide({
                        message: "index",
                        index: _react["default"].Children.count(_this.props.children) - _this.props.slidesToShow,
                        currentSlide: _this.state.currentSlide
                    });
                }
                if (_this.props.autoplay) {
                    _this.autoPlay("update");
                } else {
                    _this.pause("paused");
                }
            });
        });
        _defineProperty(_assertThisInitialized(_this), "onWindowResized", function(setTrackStyle) {
            if (_this.debouncedResize) _this.debouncedResize.cancel();
            _this.debouncedResize = (0, _lodash["default"])(function() {
                return _this.resizeWindow(setTrackStyle);
            }, 50);
            _this.debouncedResize();
        });
        _defineProperty(_assertThisInitialized(_this), "resizeWindow", function() {
            var setTrackStyle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
            var isTrackMounted = Boolean(_this.track && _this.track.node);
            // prevent warning: setting state on unmounted component (server side rendering)
            if (!isTrackMounted) return;
            var spec = _objectSpread(_objectSpread({
                listRef: _this.list,
                trackRef: _this.track
            }, _this.props), _this.state);
            _this.updateState(spec, setTrackStyle, function() {
                if (_this.props.autoplay) _this.autoPlay("update");
                else _this.pause("paused");
            });
            // animating state should be cleared while resizing, otherwise autoplay stops working
            _this.setState({
                animating: false
            });
            clearTimeout(_this.animationEndCallback);
            delete _this.animationEndCallback;
        });
        _defineProperty(_assertThisInitialized(_this), "updateState", function(spec, setTrackStyle, callback) {
            var updatedState = (0, _innerSliderUtils.initializedState)(spec);
            spec = _objectSpread(_objectSpread(_objectSpread({}, spec), updatedState), {}, {
                slideIndex: updatedState.currentSlide
            });
            var targetLeft = (0, _innerSliderUtils.getTrackLeft)(spec);
            spec = _objectSpread(_objectSpread({}, spec), {}, {
                left: targetLeft
            });
            var trackStyle = (0, _innerSliderUtils.getTrackCSS)(spec);
            if (setTrackStyle || _react["default"].Children.count(_this.props.children) !== _react["default"].Children.count(spec.children)) {
                updatedState["trackStyle"] = trackStyle;
            }
            _this.setState(updatedState, callback);
        });
        _defineProperty(_assertThisInitialized(_this), "ssrInit", function() {
            if (_this.props.variableWidth) {
                var _trackWidth = 0, _trackLeft = 0;
                var childrenWidths = [];
                var preClones = (0, _innerSliderUtils.getPreClones)(_objectSpread(_objectSpread(_objectSpread({}, _this.props), _this.state), {}, {
                    slideCount: _this.props.children.length
                }));
                var postClones = (0, _innerSliderUtils.getPostClones)(_objectSpread(_objectSpread(_objectSpread({}, _this.props), _this.state), {}, {
                    slideCount: _this.props.children.length
                }));
                _this.props.children.forEach(function(child) {
                    childrenWidths.push(child.props.style.width);
                    _trackWidth += child.props.style.width;
                });
                for(var i = 0; i < preClones; i++){
                    _trackLeft += childrenWidths[childrenWidths.length - 1 - i];
                    _trackWidth += childrenWidths[childrenWidths.length - 1 - i];
                }
                for(var _i = 0; _i < postClones; _i++){
                    _trackWidth += childrenWidths[_i];
                }
                for(var _i2 = 0; _i2 < _this.state.currentSlide; _i2++){
                    _trackLeft += childrenWidths[_i2];
                }
                var _trackStyle = {
                    width: _trackWidth + "px",
                    left: -_trackLeft + "px"
                };
                if (_this.props.centerMode) {
                    var currentWidth = "".concat(childrenWidths[_this.state.currentSlide], "px");
                    _trackStyle.left = "calc(".concat(_trackStyle.left, " + (100% - ").concat(currentWidth, ") / 2 ) ");
                }
                return {
                    trackStyle: _trackStyle
                };
            }
            var childrenCount = _react["default"].Children.count(_this.props.children);
            var spec = _objectSpread(_objectSpread(_objectSpread({}, _this.props), _this.state), {}, {
                slideCount: childrenCount
            });
            var slideCount = (0, _innerSliderUtils.getPreClones)(spec) + (0, _innerSliderUtils.getPostClones)(spec) + childrenCount;
            var trackWidth = 100 / _this.props.slidesToShow * slideCount;
            var slideWidth = 100 / slideCount;
            var trackLeft = -slideWidth * ((0, _innerSliderUtils.getPreClones)(spec) + _this.state.currentSlide) * trackWidth / 100;
            if (_this.props.centerMode) {
                trackLeft += (100 - slideWidth * trackWidth / 100) / 2;
            }
            var trackStyle = {
                width: trackWidth + "%",
                left: trackLeft + "%"
            };
            return {
                slideWidth: slideWidth + "%",
                trackStyle: trackStyle
            };
        });
        _defineProperty(_assertThisInitialized(_this), "checkImagesLoad", function() {
            var images = _this.list && _this.list.querySelectorAll && _this.list.querySelectorAll(".slick-slide img") || [];
            var imagesCount = images.length, loadedCount = 0;
            Array.prototype.forEach.call(images, function(image) {
                var handler = function handler() {
                    return ++loadedCount && loadedCount >= imagesCount && _this.onWindowResized();
                };
                if (!image.onclick) {
                    image.onclick = function() {
                        return image.parentNode.focus();
                    };
                } else {
                    var prevClickHandler = image.onclick;
                    image.onclick = function(e) {
                        prevClickHandler(e);
                        image.parentNode.focus();
                    };
                }
                if (!image.onload) {
                    if (_this.props.lazyLoad) {
                        image.onload = function() {
                            _this.adaptHeight();
                            _this.callbackTimers.push(setTimeout(_this.onWindowResized, _this.props.speed));
                        };
                    } else {
                        image.onload = handler;
                        image.onerror = function() {
                            handler();
                            _this.props.onLazyLoadError && _this.props.onLazyLoadError();
                        };
                    }
                }
            });
        });
        _defineProperty(_assertThisInitialized(_this), "progressiveLazyLoad", function() {
            var slidesToLoad = [];
            var spec = _objectSpread(_objectSpread({}, _this.props), _this.state);
            for(var index = _this.state.currentSlide; index < _this.state.slideCount + (0, _innerSliderUtils.getPostClones)(spec); index++){
                if (_this.state.lazyLoadedList.indexOf(index) < 0) {
                    slidesToLoad.push(index);
                    break;
                }
            }
            for(var _index = _this.state.currentSlide - 1; _index >= -(0, _innerSliderUtils.getPreClones)(spec); _index--){
                if (_this.state.lazyLoadedList.indexOf(_index) < 0) {
                    slidesToLoad.push(_index);
                    break;
                }
            }
            if (slidesToLoad.length > 0) {
                _this.setState(function(state) {
                    return {
                        lazyLoadedList: state.lazyLoadedList.concat(slidesToLoad)
                    };
                });
                if (_this.props.onLazyLoad) {
                    _this.props.onLazyLoad(slidesToLoad);
                }
            } else {
                if (_this.lazyLoadTimer) {
                    clearInterval(_this.lazyLoadTimer);
                    delete _this.lazyLoadTimer;
                }
            }
        });
        _defineProperty(_assertThisInitialized(_this), "slideHandler", function(index) {
            var dontAnimate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            var _this$props = _this.props, asNavFor = _this$props.asNavFor, beforeChange = _this$props.beforeChange, onLazyLoad = _this$props.onLazyLoad, speed = _this$props.speed, afterChange = _this$props.afterChange; // capture currentslide before state is updated
            var currentSlide = _this.state.currentSlide;
            var _slideHandler = (0, _innerSliderUtils.slideHandler)(_objectSpread(_objectSpread(_objectSpread({
                index: index
            }, _this.props), _this.state), {}, {
                trackRef: _this.track,
                useCSS: _this.props.useCSS && !dontAnimate
            })), state = _slideHandler.state, nextState = _slideHandler.nextState;
            if (!state) return;
            beforeChange && beforeChange(currentSlide, state.currentSlide);
            var slidesToLoad = state.lazyLoadedList.filter(function(value) {
                return _this.state.lazyLoadedList.indexOf(value) < 0;
            });
            onLazyLoad && slidesToLoad.length > 0 && onLazyLoad(slidesToLoad);
            if (!_this.props.waitForAnimate && _this.animationEndCallback) {
                clearTimeout(_this.animationEndCallback);
                afterChange && afterChange(currentSlide);
                delete _this.animationEndCallback;
            }
            _this.setState(state, function() {
                // asNavForIndex check is to avoid recursive calls of slideHandler in waitForAnimate=false mode
                if (asNavFor && _this.asNavForIndex !== index) {
                    _this.asNavForIndex = index;
                    asNavFor.innerSlider.slideHandler(index);
                }
                if (!nextState) return;
                _this.animationEndCallback = setTimeout(function() {
                    var animating = nextState.animating, firstBatch = _objectWithoutProperties(nextState, [
                        "animating"
                    ]);
                    _this.setState(firstBatch, function() {
                        _this.callbackTimers.push(setTimeout(function() {
                            return _this.setState({
                                animating: animating
                            });
                        }, 10));
                        afterChange && afterChange(state.currentSlide);
                        delete _this.animationEndCallback;
                    });
                }, speed);
            });
        });
        _defineProperty(_assertThisInitialized(_this), "changeSlide", function(options) {
            var dontAnimate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            var spec = _objectSpread(_objectSpread({}, _this.props), _this.state);
            var targetSlide = (0, _innerSliderUtils.changeSlide)(spec, options);
            if (targetSlide !== 0 && !targetSlide) return;
            if (dontAnimate === true) {
                _this.slideHandler(targetSlide, dontAnimate);
            } else {
                _this.slideHandler(targetSlide);
            }
            _this.props.autoplay && _this.autoPlay("update");
            if (_this.props.focusOnSelect) {
                var nodes = _this.list.querySelectorAll(".slick-current");
                nodes[0] && nodes[0].focus();
            }
        });
        _defineProperty(_assertThisInitialized(_this), "clickHandler", function(e) {
            if (_this.clickable === false) {
                e.stopPropagation();
                e.preventDefault();
            }
            _this.clickable = true;
        });
        _defineProperty(_assertThisInitialized(_this), "keyHandler", function(e) {
            var dir = (0, _innerSliderUtils.keyHandler)(e, _this.props.accessibility, _this.props.rtl);
            dir !== "" && _this.changeSlide({
                message: dir
            });
        });
        _defineProperty(_assertThisInitialized(_this), "selectHandler", function(options) {
            _this.changeSlide(options);
        });
        _defineProperty(_assertThisInitialized(_this), "disableBodyScroll", function() {
            var preventDefault = function preventDefault(e) {
                e = e || window.event;
                if (e.preventDefault) e.preventDefault();
                e.returnValue = false;
            };
            window.ontouchmove = preventDefault;
        });
        _defineProperty(_assertThisInitialized(_this), "enableBodyScroll", function() {
            window.ontouchmove = null;
        });
        _defineProperty(_assertThisInitialized(_this), "swipeStart", function(e) {
            if (_this.props.verticalSwiping) {
                _this.disableBodyScroll();
            }
            var state = (0, _innerSliderUtils.swipeStart)(e, _this.props.swipe, _this.props.draggable);
            state !== "" && _this.setState(state);
        });
        _defineProperty(_assertThisInitialized(_this), "swipeMove", function(e) {
            var state = (0, _innerSliderUtils.swipeMove)(e, _objectSpread(_objectSpread(_objectSpread({}, _this.props), _this.state), {}, {
                trackRef: _this.track,
                listRef: _this.list,
                slideIndex: _this.state.currentSlide
            }));
            if (!state) return;
            if (state["swiping"]) {
                _this.clickable = false;
            }
            _this.setState(state);
        });
        _defineProperty(_assertThisInitialized(_this), "swipeEnd", function(e) {
            var state = (0, _innerSliderUtils.swipeEnd)(e, _objectSpread(_objectSpread(_objectSpread({}, _this.props), _this.state), {}, {
                trackRef: _this.track,
                listRef: _this.list,
                slideIndex: _this.state.currentSlide
            }));
            if (!state) return;
            var triggerSlideHandler = state["triggerSlideHandler"];
            delete state["triggerSlideHandler"];
            _this.setState(state);
            if (triggerSlideHandler === undefined) return;
            _this.slideHandler(triggerSlideHandler);
            if (_this.props.verticalSwiping) {
                _this.enableBodyScroll();
            }
        });
        _defineProperty(_assertThisInitialized(_this), "touchEnd", function(e) {
            _this.swipeEnd(e);
            _this.clickable = true;
        });
        _defineProperty(_assertThisInitialized(_this), "slickPrev", function() {
            // this and fellow methods are wrapped in setTimeout
            // to make sure initialize setState has happened before
            // any of such methods are called
            _this.callbackTimers.push(setTimeout(function() {
                return _this.changeSlide({
                    message: "previous"
                });
            }, 0));
        });
        _defineProperty(_assertThisInitialized(_this), "slickNext", function() {
            _this.callbackTimers.push(setTimeout(function() {
                return _this.changeSlide({
                    message: "next"
                });
            }, 0));
        });
        _defineProperty(_assertThisInitialized(_this), "slickGoTo", function(slide) {
            var dontAnimate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            slide = Number(slide);
            if (isNaN(slide)) return "";
            _this.callbackTimers.push(setTimeout(function() {
                return _this.changeSlide({
                    message: "index",
                    index: slide,
                    currentSlide: _this.state.currentSlide
                }, dontAnimate);
            }, 0));
        });
        _defineProperty(_assertThisInitialized(_this), "play", function() {
            var nextIndex;
            if (_this.props.rtl) {
                nextIndex = _this.state.currentSlide - _this.props.slidesToScroll;
            } else {
                if ((0, _innerSliderUtils.canGoNext)(_objectSpread(_objectSpread({}, _this.props), _this.state))) {
                    nextIndex = _this.state.currentSlide + _this.props.slidesToScroll;
                } else {
                    return false;
                }
            }
            _this.slideHandler(nextIndex);
        });
        _defineProperty(_assertThisInitialized(_this), "autoPlay", function(playType) {
            if (_this.autoplayTimer) {
                clearInterval(_this.autoplayTimer);
            }
            var autoplaying = _this.state.autoplaying;
            if (playType === "update") {
                if (autoplaying === "hovered" || autoplaying === "focused" || autoplaying === "paused") {
                    return;
                }
            } else if (playType === "leave") {
                if (autoplaying === "paused" || autoplaying === "focused") {
                    return;
                }
            } else if (playType === "blur") {
                if (autoplaying === "paused" || autoplaying === "hovered") {
                    return;
                }
            }
            _this.autoplayTimer = setInterval(_this.play, _this.props.autoplaySpeed + 50);
            _this.setState({
                autoplaying: "playing"
            });
        });
        _defineProperty(_assertThisInitialized(_this), "pause", function(pauseType) {
            if (_this.autoplayTimer) {
                clearInterval(_this.autoplayTimer);
                _this.autoplayTimer = null;
            }
            var autoplaying = _this.state.autoplaying;
            if (pauseType === "paused") {
                _this.setState({
                    autoplaying: "paused"
                });
            } else if (pauseType === "focused") {
                if (autoplaying === "hovered" || autoplaying === "playing") {
                    _this.setState({
                        autoplaying: "focused"
                    });
                }
            } else {
                // pauseType  is 'hovered'
                if (autoplaying === "playing") {
                    _this.setState({
                        autoplaying: "hovered"
                    });
                }
            }
        });
        _defineProperty(_assertThisInitialized(_this), "onDotsOver", function() {
            return _this.props.autoplay && _this.pause("hovered");
        });
        _defineProperty(_assertThisInitialized(_this), "onDotsLeave", function() {
            return _this.props.autoplay && _this.state.autoplaying === "hovered" && _this.autoPlay("leave");
        });
        _defineProperty(_assertThisInitialized(_this), "onTrackOver", function() {
            return _this.props.autoplay && _this.pause("hovered");
        });
        _defineProperty(_assertThisInitialized(_this), "onTrackLeave", function() {
            return _this.props.autoplay && _this.state.autoplaying === "hovered" && _this.autoPlay("leave");
        });
        _defineProperty(_assertThisInitialized(_this), "onSlideFocus", function() {
            return _this.props.autoplay && _this.pause("focused");
        });
        _defineProperty(_assertThisInitialized(_this), "onSlideBlur", function() {
            return _this.props.autoplay && _this.state.autoplaying === "focused" && _this.autoPlay("blur");
        });
        _defineProperty(_assertThisInitialized(_this), "render", function() {
            var className = (0, _classnames["default"])("slick-slider", _this.props.className, {
                "slick-vertical": _this.props.vertical,
                "slick-initialized": true
            });
            var spec = _objectSpread(_objectSpread({}, _this.props), _this.state);
            var trackProps = (0, _innerSliderUtils.extractObject)(spec, [
                "fade",
                "cssEase",
                "speed",
                "infinite",
                "centerMode",
                "focusOnSelect",
                "currentSlide",
                "lazyLoad",
                "lazyLoadedList",
                "rtl",
                "slideWidth",
                "slideHeight",
                "listHeight",
                "vertical",
                "slidesToShow",
                "slidesToScroll",
                "slideCount",
                "trackStyle",
                "variableWidth",
                "unslick",
                "centerPadding",
                "targetSlide",
                "useCSS"
            ]);
            var pauseOnHover = _this.props.pauseOnHover;
            trackProps = _objectSpread(_objectSpread({}, trackProps), {}, {
                onMouseEnter: pauseOnHover ? _this.onTrackOver : null,
                onMouseLeave: pauseOnHover ? _this.onTrackLeave : null,
                onMouseOver: pauseOnHover ? _this.onTrackOver : null,
                focusOnSelect: _this.props.focusOnSelect && _this.clickable ? _this.selectHandler : null
            });
            var dots;
            if (_this.props.dots === true && _this.state.slideCount >= _this.props.slidesToShow) {
                var dotProps = (0, _innerSliderUtils.extractObject)(spec, [
                    "dotsClass",
                    "slideCount",
                    "slidesToShow",
                    "currentSlide",
                    "slidesToScroll",
                    "clickHandler",
                    "children",
                    "customPaging",
                    "infinite",
                    "appendDots"
                ]);
                var pauseOnDotsHover = _this.props.pauseOnDotsHover;
                dotProps = _objectSpread(_objectSpread({}, dotProps), {}, {
                    clickHandler: _this.changeSlide,
                    onMouseEnter: pauseOnDotsHover ? _this.onDotsLeave : null,
                    onMouseOver: pauseOnDotsHover ? _this.onDotsOver : null,
                    onMouseLeave: pauseOnDotsHover ? _this.onDotsLeave : null
                });
                dots = /*#__PURE__*/ _react["default"].createElement(_dots.Dots, dotProps);
            }
            var prevArrow, nextArrow;
            var arrowProps = (0, _innerSliderUtils.extractObject)(spec, [
                "infinite",
                "centerMode",
                "currentSlide",
                "slideCount",
                "slidesToShow",
                "prevArrow",
                "nextArrow"
            ]);
            arrowProps.clickHandler = _this.changeSlide;
            if (_this.props.arrows) {
                prevArrow = /*#__PURE__*/ _react["default"].createElement(_arrows.PrevArrow, arrowProps);
                nextArrow = /*#__PURE__*/ _react["default"].createElement(_arrows.NextArrow, arrowProps);
            }
            var verticalHeightStyle = null;
            if (_this.props.vertical) {
                verticalHeightStyle = {
                    height: _this.state.listHeight
                };
            }
            var centerPaddingStyle = null;
            if (_this.props.vertical === false) {
                if (_this.props.centerMode === true) {
                    centerPaddingStyle = {
                        padding: "0px " + _this.props.centerPadding
                    };
                }
            } else {
                if (_this.props.centerMode === true) {
                    centerPaddingStyle = {
                        padding: _this.props.centerPadding + " 0px"
                    };
                }
            }
            var listStyle = _objectSpread(_objectSpread({}, verticalHeightStyle), centerPaddingStyle);
            var touchMove = _this.props.touchMove;
            var listProps = {
                className: "slick-list",
                style: listStyle,
                onClick: _this.clickHandler,
                onMouseDown: touchMove ? _this.swipeStart : null,
                onMouseMove: _this.state.dragging && touchMove ? _this.swipeMove : null,
                onMouseUp: touchMove ? _this.swipeEnd : null,
                onMouseLeave: _this.state.dragging && touchMove ? _this.swipeEnd : null,
                onTouchStart: touchMove ? _this.swipeStart : null,
                onTouchMove: _this.state.dragging && touchMove ? _this.swipeMove : null,
                onTouchEnd: touchMove ? _this.touchEnd : null,
                onTouchCancel: _this.state.dragging && touchMove ? _this.swipeEnd : null,
                onKeyDown: _this.props.accessibility ? _this.keyHandler : null
            };
            var innerSliderProps = {
                className: className,
                dir: "ltr",
                style: _this.props.style
            };
            if (_this.props.unslick) {
                listProps = {
                    className: "slick-list"
                };
                innerSliderProps = {
                    className: className
                };
            }
            return /*#__PURE__*/ _react["default"].createElement("div", innerSliderProps, !_this.props.unslick ? prevArrow : "", /*#__PURE__*/ _react["default"].createElement("div", _extends({
                ref: _this.listRefHandler
            }, listProps), /*#__PURE__*/ _react["default"].createElement(_track.Track, _extends({
                ref: _this.trackRefHandler
            }, trackProps), _this.props.children)), !_this.props.unslick ? nextArrow : "", !_this.props.unslick ? dots : "");
        });
        _this.list = null;
        _this.track = null;
        _this.state = _objectSpread(_objectSpread({}, _initialState["default"]), {}, {
            currentSlide: _this.props.initialSlide,
            targetSlide: _this.props.initialSlide ? _this.props.initialSlide : 0,
            slideCount: _react["default"].Children.count(_this.props.children)
        });
        _this.callbackTimers = [];
        _this.clickable = true;
        _this.debouncedResize = null;
        var ssrState = _this.ssrInit();
        _this.state = _objectSpread(_objectSpread({}, _this.state), ssrState);
        return _this;
    }
    _createClass(InnerSlider, [
        {
            key: "didPropsChange",
            value: function didPropsChange(prevProps) {
                var setTrackStyle = false;
                for(var _i3 = 0, _Object$keys = Object.keys(this.props); _i3 < _Object$keys.length; _i3++){
                    var key = _Object$keys[_i3];
                    if (!prevProps.hasOwnProperty(key)) {
                        setTrackStyle = true;
                        break;
                    }
                    if (_typeof(prevProps[key]) === "object" || typeof prevProps[key] === "function" || isNaN(prevProps[key])) {
                        continue;
                    }
                    if (prevProps[key] !== this.props[key]) {
                        setTrackStyle = true;
                        break;
                    }
                }
                return setTrackStyle || _react["default"].Children.count(this.props.children) !== _react["default"].Children.count(prevProps.children);
            }
        }
    ]);
    return InnerSlider;
}(_react["default"].Component);
}}),
"[project]/node_modules/string-convert/camel2hyphen.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var camel2hyphen = function(str) {
    return str.replace(/[A-Z]/g, function(match) {
        return '-' + match.toLowerCase();
    }).toLowerCase();
};
module.exports = camel2hyphen;
}}),
"[project]/node_modules/json2mq/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var camel2hyphen = __turbopack_context__.r("[project]/node_modules/string-convert/camel2hyphen.js [app-ssr] (ecmascript)");
var isDimension = function(feature) {
    var re = /[height|width]$/;
    return re.test(feature);
};
var obj2mq = function(obj) {
    var mq = '';
    var features = Object.keys(obj);
    features.forEach(function(feature, index) {
        var value = obj[feature];
        feature = camel2hyphen(feature);
        // Add px to dimension features
        if (isDimension(feature) && typeof value === 'number') {
            value = value + 'px';
        }
        if (value === true) {
            mq += feature;
        } else if (value === false) {
            mq += 'not ' + feature;
        } else {
            mq += '(' + feature + ': ' + value + ')';
        }
        if (index < features.length - 1) {
            mq += ' and ';
        }
    });
    return mq;
};
var json2mq = function(query) {
    var mq = '';
    if (typeof query === 'string') {
        return query;
    }
    // Handling array of media queries
    if (query instanceof Array) {
        query.forEach(function(q, index) {
            mq += obj2mq(q);
            if (index < query.length - 1) {
                mq += ', ';
            }
        });
        return mq;
    }
    // Handling single media query
    return obj2mq(query);
};
module.exports = json2mq;
}}),
"[project]/node_modules/react-slick/lib/slider.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports["default"] = void 0;
var _react = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"));
var _innerSlider = __turbopack_context__.r("[project]/node_modules/react-slick/lib/inner-slider.js [app-ssr] (ecmascript)");
var _json2mq = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/json2mq/index.js [app-ssr] (ecmascript)"));
var _defaultProps = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/react-slick/lib/default-props.js [app-ssr] (ecmascript)"));
var _innerSliderUtils = __turbopack_context__.r("[project]/node_modules/react-slick/lib/utils/innerSliderUtils.js [app-ssr] (ecmascript)");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    };
}
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function _extends() {
    _extends = ("TURBOPACK compile-time truthy", 1) ? Object.assign.bind() : ("TURBOPACK unreachable", undefined);
    return _extends.apply(this, arguments);
}
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    Object.defineProperty(subClass, "prototype", {
        writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
    } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
    }
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct() {
    try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (t) {}
    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
        return !!t;
    })();
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : String(i);
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var enquire = (0, _innerSliderUtils.canUseDOM)() && __turbopack_context__.r("[project]/node_modules/enquire.js/src/index.js [app-ssr] (ecmascript)");
var Slider = exports["default"] = /*#__PURE__*/ function(_React$Component) {
    _inherits(Slider, _React$Component);
    var _super = _createSuper(Slider);
    function Slider(props) {
        var _this;
        _classCallCheck(this, Slider);
        _this = _super.call(this, props);
        _defineProperty(_assertThisInitialized(_this), "innerSliderRefHandler", function(ref) {
            return _this.innerSlider = ref;
        });
        _defineProperty(_assertThisInitialized(_this), "slickPrev", function() {
            return _this.innerSlider.slickPrev();
        });
        _defineProperty(_assertThisInitialized(_this), "slickNext", function() {
            return _this.innerSlider.slickNext();
        });
        _defineProperty(_assertThisInitialized(_this), "slickGoTo", function(slide) {
            var dontAnimate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            return _this.innerSlider.slickGoTo(slide, dontAnimate);
        });
        _defineProperty(_assertThisInitialized(_this), "slickPause", function() {
            return _this.innerSlider.pause("paused");
        });
        _defineProperty(_assertThisInitialized(_this), "slickPlay", function() {
            return _this.innerSlider.autoPlay("play");
        });
        _this.state = {
            breakpoint: null
        };
        _this._responsiveMediaHandlers = [];
        return _this;
    }
    _createClass(Slider, [
        {
            key: "media",
            value: function media(query, handler) {
                // javascript handler for  css media query
                enquire.register(query, handler);
                this._responsiveMediaHandlers.push({
                    query: query,
                    handler: handler
                });
            } // handles responsive breakpoints
        },
        {
            key: "componentDidMount",
            value: function componentDidMount() {
                var _this2 = this;
                // performance monitoring
                //if (process.env.NODE_ENV !== 'production') {
                //const { whyDidYouUpdate } = require('why-did-you-update')
                //whyDidYouUpdate(React)
                //}
                if (this.props.responsive) {
                    var breakpoints = this.props.responsive.map(function(breakpt) {
                        return breakpt.breakpoint;
                    });
                    // sort them in increasing order of their numerical value
                    breakpoints.sort(function(x, y) {
                        return x - y;
                    });
                    breakpoints.forEach(function(breakpoint, index) {
                        // media query for each breakpoint
                        var bQuery;
                        if (index === 0) {
                            bQuery = (0, _json2mq["default"])({
                                minWidth: 0,
                                maxWidth: breakpoint
                            });
                        } else {
                            bQuery = (0, _json2mq["default"])({
                                minWidth: breakpoints[index - 1] + 1,
                                maxWidth: breakpoint
                            });
                        }
                        // when not using server side rendering
                        (0, _innerSliderUtils.canUseDOM)() && _this2.media(bQuery, function() {
                            _this2.setState({
                                breakpoint: breakpoint
                            });
                        });
                    });
                    // Register media query for full screen. Need to support resize from small to large
                    // convert javascript object to media query string
                    var query = (0, _json2mq["default"])({
                        minWidth: breakpoints.slice(-1)[0]
                    });
                    (0, _innerSliderUtils.canUseDOM)() && this.media(query, function() {
                        _this2.setState({
                            breakpoint: null
                        });
                    });
                }
            }
        },
        {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                this._responsiveMediaHandlers.forEach(function(obj) {
                    enquire.unregister(obj.query, obj.handler);
                });
            }
        },
        {
            key: "render",
            value: function render() {
                var _this3 = this;
                var settings;
                var newProps;
                if (this.state.breakpoint) {
                    newProps = this.props.responsive.filter(function(resp) {
                        return resp.breakpoint === _this3.state.breakpoint;
                    });
                    settings = newProps[0].settings === "unslick" ? "unslick" : _objectSpread(_objectSpread(_objectSpread({}, _defaultProps["default"]), this.props), newProps[0].settings);
                } else {
                    settings = _objectSpread(_objectSpread({}, _defaultProps["default"]), this.props);
                }
                // force scrolling by one if centerMode is on
                if (settings.centerMode) {
                    if (settings.slidesToScroll > 1 && ("TURBOPACK compile-time value", "development") !== "production") {
                        console.warn("slidesToScroll should be equal to 1 in centerMode, you are using ".concat(settings.slidesToScroll));
                    }
                    settings.slidesToScroll = 1;
                }
                // force showing one slide and scrolling by one if the fade mode is on
                if (settings.fade) {
                    if (settings.slidesToShow > 1 && ("TURBOPACK compile-time value", "development") !== "production") {
                        console.warn("slidesToShow should be equal to 1 when fade is true, you're using ".concat(settings.slidesToShow));
                    }
                    if (settings.slidesToScroll > 1 && ("TURBOPACK compile-time value", "development") !== "production") {
                        console.warn("slidesToScroll should be equal to 1 when fade is true, you're using ".concat(settings.slidesToScroll));
                    }
                    settings.slidesToShow = 1;
                    settings.slidesToScroll = 1;
                }
                // makes sure that children is an array, even when there is only 1 child
                var children = _react["default"].Children.toArray(this.props.children);
                // Children may contain false or null, so we should filter them
                // children may also contain string filled with spaces (in certain cases where we use jsx strings)
                children = children.filter(function(child) {
                    if (typeof child === "string") {
                        return !!child.trim();
                    }
                    return !!child;
                });
                // rows and slidesPerRow logic is handled here
                if (settings.variableWidth && (settings.rows > 1 || settings.slidesPerRow > 1)) {
                    console.warn("variableWidth is not supported in case of rows > 1 or slidesPerRow > 1");
                    settings.variableWidth = false;
                }
                var newChildren = [];
                var currentWidth = null;
                for(var i = 0; i < children.length; i += settings.rows * settings.slidesPerRow){
                    var newSlide = [];
                    for(var j = i; j < i + settings.rows * settings.slidesPerRow; j += settings.slidesPerRow){
                        var row = [];
                        for(var k = j; k < j + settings.slidesPerRow; k += 1){
                            if (settings.variableWidth && children[k].props.style) {
                                currentWidth = children[k].props.style.width;
                            }
                            if (k >= children.length) break;
                            row.push(/*#__PURE__*/ _react["default"].cloneElement(children[k], {
                                key: 100 * i + 10 * j + k,
                                tabIndex: -1,
                                style: {
                                    width: "".concat(100 / settings.slidesPerRow, "%"),
                                    display: "inline-block"
                                }
                            }));
                        }
                        newSlide.push(/*#__PURE__*/ _react["default"].createElement("div", {
                            key: 10 * i + j
                        }, row));
                    }
                    if (settings.variableWidth) {
                        newChildren.push(/*#__PURE__*/ _react["default"].createElement("div", {
                            key: i,
                            style: {
                                width: currentWidth
                            }
                        }, newSlide));
                    } else {
                        newChildren.push(/*#__PURE__*/ _react["default"].createElement("div", {
                            key: i
                        }, newSlide));
                    }
                }
                if (settings === "unslick") {
                    var className = "regular slider " + (this.props.className || "");
                    return /*#__PURE__*/ _react["default"].createElement("div", {
                        className: className
                    }, children);
                } else if (newChildren.length <= settings.slidesToShow && !settings.infinite) {
                    settings.unslick = true;
                }
                return /*#__PURE__*/ _react["default"].createElement(_innerSlider.InnerSlider, _extends({
                    style: this.props.style,
                    ref: this.innerSliderRefHandler
                }, (0, _innerSliderUtils.filterSettings)(settings)), newChildren);
            }
        }
    ]);
    return Slider;
}(_react["default"].Component);
}}),
"[project]/node_modules/react-slick/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports["default"] = void 0;
var _slider = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/react-slick/lib/slider.js [app-ssr] (ecmascript)"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    };
}
var _default = exports["default"] = _slider["default"];
}}),
"[project]/node_modules/next/dist/compiled/client-only/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
}}),
"[project]/node_modules/styled-jsx/dist/index/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
__turbopack_context__.r("[project]/node_modules/next/dist/compiled/client-only/index.js [app-ssr] (ecmascript)");
var React = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
function _interopDefaultLegacy(e) {
    return e && typeof e === 'object' && 'default' in e ? e : {
        'default': e
    };
}
var React__default = /*#__PURE__*/ _interopDefaultLegacy(React);
/*
Based on Glamor's sheet
https://github.com/threepointone/glamor/blob/667b480d31b3721a905021b26e1290ce92ca2879/src/sheet.js
*/ function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
var isProd = typeof process !== "undefined" && process.env && ("TURBOPACK compile-time value", "development") === "production";
var isString = function(o) {
    return Object.prototype.toString.call(o) === "[object String]";
};
var StyleSheet = /*#__PURE__*/ function() {
    function StyleSheet(param) {
        var ref = param === void 0 ? {} : param, _name = ref.name, name = _name === void 0 ? "stylesheet" : _name, _optimizeForSpeed = ref.optimizeForSpeed, optimizeForSpeed = _optimizeForSpeed === void 0 ? isProd : _optimizeForSpeed;
        invariant$1(isString(name), "`name` must be a string");
        this._name = name;
        this._deletedRulePlaceholder = "#" + name + "-deleted-rule____{}";
        invariant$1(typeof optimizeForSpeed === "boolean", "`optimizeForSpeed` must be a boolean");
        this._optimizeForSpeed = optimizeForSpeed;
        this._serverSheet = undefined;
        this._tags = [];
        this._injected = false;
        this._rulesCount = 0;
        var node = typeof window !== "undefined" && document.querySelector('meta[property="csp-nonce"]');
        this._nonce = node ? node.getAttribute("content") : null;
    }
    var _proto = StyleSheet.prototype;
    _proto.setOptimizeForSpeed = function setOptimizeForSpeed(bool) {
        invariant$1(typeof bool === "boolean", "`setOptimizeForSpeed` accepts a boolean");
        invariant$1(this._rulesCount === 0, "optimizeForSpeed cannot be when rules have already been inserted");
        this.flush();
        this._optimizeForSpeed = bool;
        this.inject();
    };
    _proto.isOptimizeForSpeed = function isOptimizeForSpeed() {
        return this._optimizeForSpeed;
    };
    _proto.inject = function inject() {
        var _this = this;
        invariant$1(!this._injected, "sheet already injected");
        this._injected = true;
        if (typeof window !== "undefined" && this._optimizeForSpeed) {
            this._tags[0] = this.makeStyleTag(this._name);
            this._optimizeForSpeed = "insertRule" in this.getSheet();
            if (!this._optimizeForSpeed) {
                if ("TURBOPACK compile-time truthy", 1) {
                    console.warn("StyleSheet: optimizeForSpeed mode not supported falling back to standard mode.");
                }
                this.flush();
                this._injected = true;
            }
            return;
        }
        this._serverSheet = {
            cssRules: [],
            insertRule: function(rule, index) {
                if (typeof index === "number") {
                    _this._serverSheet.cssRules[index] = {
                        cssText: rule
                    };
                } else {
                    _this._serverSheet.cssRules.push({
                        cssText: rule
                    });
                }
                return index;
            },
            deleteRule: function(index) {
                _this._serverSheet.cssRules[index] = null;
            }
        };
    };
    _proto.getSheetForTag = function getSheetForTag(tag) {
        if (tag.sheet) {
            return tag.sheet;
        }
        // this weirdness brought to you by firefox
        for(var i = 0; i < document.styleSheets.length; i++){
            if (document.styleSheets[i].ownerNode === tag) {
                return document.styleSheets[i];
            }
        }
    };
    _proto.getSheet = function getSheet() {
        return this.getSheetForTag(this._tags[this._tags.length - 1]);
    };
    _proto.insertRule = function insertRule(rule, index) {
        invariant$1(isString(rule), "`insertRule` accepts only strings");
        if (typeof window === "undefined") {
            if (typeof index !== "number") {
                index = this._serverSheet.cssRules.length;
            }
            this._serverSheet.insertRule(rule, index);
            return this._rulesCount++;
        }
        if (this._optimizeForSpeed) {
            var sheet = this.getSheet();
            if (typeof index !== "number") {
                index = sheet.cssRules.length;
            }
            // this weirdness for perf, and chrome's weird bug
            // https://stackoverflow.com/questions/20007992/chrome-suddenly-stopped-accepting-insertrule
            try {
                sheet.insertRule(rule, index);
            } catch (error) {
                if ("TURBOPACK compile-time truthy", 1) {
                    console.warn("StyleSheet: illegal rule: \n\n" + rule + "\n\nSee https://stackoverflow.com/q/20007992 for more info");
                }
                return -1;
            }
        } else {
            var insertionPoint = this._tags[index];
            this._tags.push(this.makeStyleTag(this._name, rule, insertionPoint));
        }
        return this._rulesCount++;
    };
    _proto.replaceRule = function replaceRule(index, rule) {
        if (this._optimizeForSpeed || typeof window === "undefined") {
            var sheet = typeof window !== "undefined" ? this.getSheet() : this._serverSheet;
            if (!rule.trim()) {
                rule = this._deletedRulePlaceholder;
            }
            if (!sheet.cssRules[index]) {
                // @TBD Should we throw an error?
                return index;
            }
            sheet.deleteRule(index);
            try {
                sheet.insertRule(rule, index);
            } catch (error) {
                if ("TURBOPACK compile-time truthy", 1) {
                    console.warn("StyleSheet: illegal rule: \n\n" + rule + "\n\nSee https://stackoverflow.com/q/20007992 for more info");
                }
                // In order to preserve the indices we insert a deleteRulePlaceholder
                sheet.insertRule(this._deletedRulePlaceholder, index);
            }
        } else {
            var tag = this._tags[index];
            invariant$1(tag, "old rule at index `" + index + "` not found");
            tag.textContent = rule;
        }
        return index;
    };
    _proto.deleteRule = function deleteRule(index) {
        if (typeof window === "undefined") {
            this._serverSheet.deleteRule(index);
            return;
        }
        if (this._optimizeForSpeed) {
            this.replaceRule(index, "");
        } else {
            var tag = this._tags[index];
            invariant$1(tag, "rule at index `" + index + "` not found");
            tag.parentNode.removeChild(tag);
            this._tags[index] = null;
        }
    };
    _proto.flush = function flush() {
        this._injected = false;
        this._rulesCount = 0;
        if (typeof window !== "undefined") {
            this._tags.forEach(function(tag) {
                return tag && tag.parentNode.removeChild(tag);
            });
            this._tags = [];
        } else {
            // simpler on server
            this._serverSheet.cssRules = [];
        }
    };
    _proto.cssRules = function cssRules() {
        var _this = this;
        if (typeof window === "undefined") {
            return this._serverSheet.cssRules;
        }
        return this._tags.reduce(function(rules, tag) {
            if (tag) {
                rules = rules.concat(Array.prototype.map.call(_this.getSheetForTag(tag).cssRules, function(rule) {
                    return rule.cssText === _this._deletedRulePlaceholder ? null : rule;
                }));
            } else {
                rules.push(null);
            }
            return rules;
        }, []);
    };
    _proto.makeStyleTag = function makeStyleTag(name, cssString, relativeToTag) {
        if (cssString) {
            invariant$1(isString(cssString), "makeStyleTag accepts only strings as second parameter");
        }
        var tag = document.createElement("style");
        if (this._nonce) tag.setAttribute("nonce", this._nonce);
        tag.type = "text/css";
        tag.setAttribute("data-" + name, "");
        if (cssString) {
            tag.appendChild(document.createTextNode(cssString));
        }
        var head = document.head || document.getElementsByTagName("head")[0];
        if (relativeToTag) {
            head.insertBefore(tag, relativeToTag);
        } else {
            head.appendChild(tag);
        }
        return tag;
    };
    _createClass(StyleSheet, [
        {
            key: "length",
            get: function get() {
                return this._rulesCount;
            }
        }
    ]);
    return StyleSheet;
}();
function invariant$1(condition, message) {
    if (!condition) {
        throw new Error("StyleSheet: " + message + ".");
    }
}
function hash(str) {
    var _$hash = 5381, i = str.length;
    while(i){
        _$hash = _$hash * 33 ^ str.charCodeAt(--i);
    }
    /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed
   * integers. Since we want the results to be always positive, convert the
   * signed int to an unsigned by doing an unsigned bitshift. */ return _$hash >>> 0;
}
var stringHash = hash;
var sanitize = function(rule) {
    return rule.replace(/\/style/gi, "\\/style");
};
var cache = {};
/**
 * computeId
 *
 * Compute and memoize a jsx id from a basedId and optionally props.
 */ function computeId(baseId, props) {
    if (!props) {
        return "jsx-" + baseId;
    }
    var propsToString = String(props);
    var key = baseId + propsToString;
    if (!cache[key]) {
        cache[key] = "jsx-" + stringHash(baseId + "-" + propsToString);
    }
    return cache[key];
}
/**
 * computeSelector
 *
 * Compute and memoize dynamic selectors.
 */ function computeSelector(id, css) {
    var selectoPlaceholderRegexp = /__jsx-style-dynamic-selector/g;
    // Sanitize SSR-ed CSS.
    // Client side code doesn't need to be sanitized since we use
    // document.createTextNode (dev) and the CSSOM api sheet.insertRule (prod).
    if (typeof window === "undefined") {
        css = sanitize(css);
    }
    var idcss = id + css;
    if (!cache[idcss]) {
        cache[idcss] = css.replace(selectoPlaceholderRegexp, id);
    }
    return cache[idcss];
}
function mapRulesToStyle(cssRules, options) {
    if (options === void 0) options = {};
    return cssRules.map(function(args) {
        var id = args[0];
        var css = args[1];
        return /*#__PURE__*/ React__default["default"].createElement("style", {
            id: "__" + id,
            // Avoid warnings upon render with a key
            key: "__" + id,
            nonce: options.nonce ? options.nonce : undefined,
            dangerouslySetInnerHTML: {
                __html: css
            }
        });
    });
}
var StyleSheetRegistry = /*#__PURE__*/ function() {
    function StyleSheetRegistry(param) {
        var ref = param === void 0 ? {} : param, _styleSheet = ref.styleSheet, styleSheet = _styleSheet === void 0 ? null : _styleSheet, _optimizeForSpeed = ref.optimizeForSpeed, optimizeForSpeed = _optimizeForSpeed === void 0 ? false : _optimizeForSpeed;
        this._sheet = styleSheet || new StyleSheet({
            name: "styled-jsx",
            optimizeForSpeed: optimizeForSpeed
        });
        this._sheet.inject();
        if (styleSheet && typeof optimizeForSpeed === "boolean") {
            this._sheet.setOptimizeForSpeed(optimizeForSpeed);
            this._optimizeForSpeed = this._sheet.isOptimizeForSpeed();
        }
        this._fromServer = undefined;
        this._indices = {};
        this._instancesCounts = {};
    }
    var _proto = StyleSheetRegistry.prototype;
    _proto.add = function add(props) {
        var _this = this;
        if (undefined === this._optimizeForSpeed) {
            this._optimizeForSpeed = Array.isArray(props.children);
            this._sheet.setOptimizeForSpeed(this._optimizeForSpeed);
            this._optimizeForSpeed = this._sheet.isOptimizeForSpeed();
        }
        if (typeof window !== "undefined" && !this._fromServer) {
            this._fromServer = this.selectFromServer();
            this._instancesCounts = Object.keys(this._fromServer).reduce(function(acc, tagName) {
                acc[tagName] = 0;
                return acc;
            }, {});
        }
        var ref = this.getIdAndRules(props), styleId = ref.styleId, rules = ref.rules;
        // Deduping: just increase the instances count.
        if (styleId in this._instancesCounts) {
            this._instancesCounts[styleId] += 1;
            return;
        }
        var indices = rules.map(function(rule) {
            return _this._sheet.insertRule(rule);
        }) // Filter out invalid rules
        .filter(function(index) {
            return index !== -1;
        });
        this._indices[styleId] = indices;
        this._instancesCounts[styleId] = 1;
    };
    _proto.remove = function remove(props) {
        var _this = this;
        var styleId = this.getIdAndRules(props).styleId;
        invariant(styleId in this._instancesCounts, "styleId: `" + styleId + "` not found");
        this._instancesCounts[styleId] -= 1;
        if (this._instancesCounts[styleId] < 1) {
            var tagFromServer = this._fromServer && this._fromServer[styleId];
            if (tagFromServer) {
                tagFromServer.parentNode.removeChild(tagFromServer);
                delete this._fromServer[styleId];
            } else {
                this._indices[styleId].forEach(function(index) {
                    return _this._sheet.deleteRule(index);
                });
                delete this._indices[styleId];
            }
            delete this._instancesCounts[styleId];
        }
    };
    _proto.update = function update(props, nextProps) {
        this.add(nextProps);
        this.remove(props);
    };
    _proto.flush = function flush() {
        this._sheet.flush();
        this._sheet.inject();
        this._fromServer = undefined;
        this._indices = {};
        this._instancesCounts = {};
    };
    _proto.cssRules = function cssRules() {
        var _this = this;
        var fromServer = this._fromServer ? Object.keys(this._fromServer).map(function(styleId) {
            return [
                styleId,
                _this._fromServer[styleId]
            ];
        }) : [];
        var cssRules = this._sheet.cssRules();
        return fromServer.concat(Object.keys(this._indices).map(function(styleId) {
            return [
                styleId,
                _this._indices[styleId].map(function(index) {
                    return cssRules[index].cssText;
                }).join(_this._optimizeForSpeed ? "" : "\n")
            ];
        }) // filter out empty rules
        .filter(function(rule) {
            return Boolean(rule[1]);
        }));
    };
    _proto.styles = function styles(options) {
        return mapRulesToStyle(this.cssRules(), options);
    };
    _proto.getIdAndRules = function getIdAndRules(props) {
        var css = props.children, dynamic = props.dynamic, id = props.id;
        if (dynamic) {
            var styleId = computeId(id, dynamic);
            return {
                styleId: styleId,
                rules: Array.isArray(css) ? css.map(function(rule) {
                    return computeSelector(styleId, rule);
                }) : [
                    computeSelector(styleId, css)
                ]
            };
        }
        return {
            styleId: computeId(id),
            rules: Array.isArray(css) ? css : [
                css
            ]
        };
    };
    /**
   * selectFromServer
   *
   * Collects style tags from the document with id __jsx-XXX
   */ _proto.selectFromServer = function selectFromServer() {
        var elements = Array.prototype.slice.call(document.querySelectorAll('[id^="__jsx-"]'));
        return elements.reduce(function(acc, element) {
            var id = element.id.slice(2);
            acc[id] = element;
            return acc;
        }, {});
    };
    return StyleSheetRegistry;
}();
function invariant(condition, message) {
    if (!condition) {
        throw new Error("StyleSheetRegistry: " + message + ".");
    }
}
var StyleSheetContext = /*#__PURE__*/ React.createContext(null);
StyleSheetContext.displayName = "StyleSheetContext";
function createStyleRegistry() {
    return new StyleSheetRegistry();
}
function StyleRegistry(param) {
    var configuredRegistry = param.registry, children = param.children;
    var rootRegistry = React.useContext(StyleSheetContext);
    var ref = React.useState(function() {
        return rootRegistry || configuredRegistry || createStyleRegistry();
    }), registry = ref[0];
    return /*#__PURE__*/ React__default["default"].createElement(StyleSheetContext.Provider, {
        value: registry
    }, children);
}
function useStyleRegistry() {
    return React.useContext(StyleSheetContext);
}
// Opt-into the new `useInsertionEffect` API in React 18, fallback to `useLayoutEffect`.
// https://github.com/reactwg/react-18/discussions/110
var useInsertionEffect = React__default["default"].useInsertionEffect || React__default["default"].useLayoutEffect;
var defaultRegistry = typeof window !== "undefined" ? createStyleRegistry() : undefined;
function JSXStyle(props) {
    var registry = defaultRegistry ? defaultRegistry : useStyleRegistry();
    // If `registry` does not exist, we do nothing here.
    if (!registry) {
        return null;
    }
    if (typeof window === "undefined") {
        registry.add(props);
        return null;
    }
    useInsertionEffect(function() {
        registry.add(props);
        return function() {
            registry.remove(props);
        };
    // props.children can be string[], will be striped since id is identical
    }, [
        props.id,
        String(props.dynamic)
    ]);
    return null;
}
JSXStyle.dynamic = function(info) {
    return info.map(function(tagInfo) {
        var baseId = tagInfo[0];
        var props = tagInfo[1];
        return computeId(baseId, props);
    }).join(" ");
};
exports.StyleRegistry = StyleRegistry;
exports.createStyleRegistry = createStyleRegistry;
exports.style = JSXStyle;
exports.useStyleRegistry = useStyleRegistry;
}}),
"[project]/node_modules/styled-jsx/style.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
module.exports = __turbopack_context__.r("[project]/node_modules/styled-jsx/dist/index/index.js [app-ssr] (ecmascript)").style;
}}),
"[project]/node_modules/groq/lib/groq.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>groq),
    "defineQuery": (()=>defineQuery)
});
function defineQuery(query) {
    return query;
}
function groq(strings, ...keys) {
    const lastIndex = strings.length - 1;
    return strings.slice(0, lastIndex).reduce((acc, str, i)=>acc + str + keys[i], "") + strings[lastIndex];
}
;
 //# sourceMappingURL=groq.js.map
}}),

};

//# sourceMappingURL=node_modules_2eda5455._.js.map