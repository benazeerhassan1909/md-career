module.exports = {

"[project]/node_modules/@portabletext/toolkit/dist/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "LIST_NEST_MODE_DIRECT": (()=>LIST_NEST_MODE_DIRECT),
    "LIST_NEST_MODE_HTML": (()=>LIST_NEST_MODE_HTML),
    "buildMarksTree": (()=>buildMarksTree),
    "isPortableTextBlock": (()=>isPortableTextBlock),
    "isPortableTextListItemBlock": (()=>isPortableTextListItemBlock),
    "isPortableTextSpan": (()=>isPortableTextSpan),
    "isPortableTextToolkitList": (()=>isPortableTextToolkitList),
    "isPortableTextToolkitSpan": (()=>isPortableTextToolkitSpan),
    "isPortableTextToolkitTextNode": (()=>isPortableTextToolkitTextNode),
    "nestLists": (()=>nestLists),
    "sortMarksByOccurences": (()=>sortMarksByOccurences),
    "spanToPlainText": (()=>spanToPlainText),
    "toPlainText": (()=>toPlainText)
});
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
function isPortableTextSpan(node) {
    return node._type === "span" && "text" in node && typeof node.text == "string" && (typeof node.marks > "u" || Array.isArray(node.marks) && node.marks.every((mark)=>typeof mark == "string"));
}
function isPortableTextBlock(node) {
    return(// A block doesn't _have_ to be named 'block' - to differentiate between
    // allowed child types and marks, one might name them differently
    typeof node._type == "string" && // Toolkit-types like nested spans are @-prefixed
    node._type[0] !== "@" && (// `markDefs` isn't _required_ per say, but if it's there, it needs to be an array
    !("markDefs" in node) || !node.markDefs || Array.isArray(node.markDefs) && // Every mark definition needs to have an `_key` to be mappable in child spans
    node.markDefs.every((def)=>typeof def._key == "string")) && // `children` is required and needs to be an array
    "children" in node && Array.isArray(node.children) && // All children are objects with `_type` (usually spans, but can contain other stuff)
    node.children.every((child)=>typeof child == "object" && "_type" in child));
}
function isPortableTextListItemBlock(block) {
    return isPortableTextBlock(block) && "listItem" in block && typeof block.listItem == "string" && (typeof block.level > "u" || typeof block.level == "number");
}
function isPortableTextToolkitList(block) {
    return block._type === "@list";
}
function isPortableTextToolkitSpan(span) {
    return span._type === "@span";
}
function isPortableTextToolkitTextNode(node) {
    return node._type === "@text";
}
const knownDecorators = [
    "strong",
    "em",
    "code",
    "underline",
    "strike-through"
];
function sortMarksByOccurences(span, index, blockChildren) {
    if (!isPortableTextSpan(span) || !span.marks) return [];
    if (!span.marks.length) return [];
    const marks = span.marks.slice(), occurences = {};
    return marks.forEach((mark)=>{
        occurences[mark] = 1;
        for(let siblingIndex = index + 1; siblingIndex < blockChildren.length; siblingIndex++){
            const sibling = blockChildren[siblingIndex];
            if (sibling && isPortableTextSpan(sibling) && Array.isArray(sibling.marks) && sibling.marks.indexOf(mark) !== -1) occurences[mark]++;
            else break;
        }
    }), marks.sort((markA, markB)=>sortMarks(occurences, markA, markB));
}
function sortMarks(occurences, markA, markB) {
    const aOccurences = occurences[markA], bOccurences = occurences[markB];
    if (aOccurences !== bOccurences) return bOccurences - aOccurences;
    const aKnownPos = knownDecorators.indexOf(markA), bKnownPos = knownDecorators.indexOf(markB);
    return aKnownPos !== bKnownPos ? aKnownPos - bKnownPos : markA.localeCompare(markB);
}
function buildMarksTree(block) {
    var _a, _b;
    const { children } = block, markDefs = (_a = block.markDefs) != null ? _a : [];
    if (!children || !children.length) return [];
    const sortedMarks = children.map(sortMarksByOccurences), rootNode = {
        _type: "@span",
        children: [],
        markType: "<unknown>"
    };
    let nodeStack = [
        rootNode
    ];
    for(let i = 0; i < children.length; i++){
        const span = children[i];
        if (!span) continue;
        const marksNeeded = sortedMarks[i] || [];
        let pos = 1;
        if (nodeStack.length > 1) for(pos; pos < nodeStack.length; pos++){
            const mark = ((_b = nodeStack[pos]) == null ? void 0 : _b.markKey) || "", index = marksNeeded.indexOf(mark);
            if (index === -1) break;
            marksNeeded.splice(index, 1);
        }
        nodeStack = nodeStack.slice(0, pos);
        let currentNode = nodeStack[nodeStack.length - 1];
        if (currentNode) {
            for (const markKey of marksNeeded){
                const markDef = markDefs == null ? void 0 : markDefs.find((def)=>def._key === markKey), markType = markDef ? markDef._type : markKey, node = {
                    _type: "@span",
                    _key: span._key,
                    children: [],
                    markDef,
                    markType,
                    markKey
                };
                currentNode.children.push(node), nodeStack.push(node), currentNode = node;
            }
            if (isPortableTextSpan(span)) {
                const lines = span.text.split(`
`);
                for(let line = lines.length; line-- > 1;)lines.splice(line, 0, `
`);
                currentNode.children = currentNode.children.concat(lines.map((text)=>({
                        _type: "@text",
                        text
                    })));
            } else currentNode.children = currentNode.children.concat(span);
        }
    }
    return rootNode.children;
}
function nestLists(blocks, mode) {
    const tree = [];
    let currentList;
    for(let i = 0; i < blocks.length; i++){
        const block = blocks[i];
        if (block) {
            if (!isPortableTextListItemBlock(block)) {
                tree.push(block), currentList = void 0;
                continue;
            }
            if (!currentList) {
                currentList = listFromBlock(block, i, mode), tree.push(currentList);
                continue;
            }
            if (blockMatchesList(block, currentList)) {
                currentList.children.push(block);
                continue;
            }
            if ((block.level || 1) > currentList.level) {
                const newList = listFromBlock(block, i, mode);
                if (mode === "html") {
                    const lastListItem = currentList.children[currentList.children.length - 1], newLastChild = _objectSpread(_objectSpread({}, lastListItem), {}, {
                        children: [
                            ...lastListItem.children,
                            newList
                        ]
                    });
                    currentList.children[currentList.children.length - 1] = newLastChild;
                } else currentList.children.push(newList);
                currentList = newList;
                continue;
            }
            if ((block.level || 1) < currentList.level) {
                const matchingBranch = tree[tree.length - 1], match = matchingBranch && findListMatching(matchingBranch, block);
                if (match) {
                    currentList = match, currentList.children.push(block);
                    continue;
                }
                currentList = listFromBlock(block, i, mode), tree.push(currentList);
                continue;
            }
            if (block.listItem !== currentList.listItem) {
                const matchingBranch = tree[tree.length - 1], match = matchingBranch && findListMatching(matchingBranch, {
                    level: block.level || 1
                });
                if (match && match.listItem === block.listItem) {
                    currentList = match, currentList.children.push(block);
                    continue;
                } else {
                    currentList = listFromBlock(block, i, mode), tree.push(currentList);
                    continue;
                }
            }
            console.warn("Unknown state encountered for block", block), tree.push(block);
        }
    }
    return tree;
}
function blockMatchesList(block, list) {
    return (block.level || 1) === list.level && block.listItem === list.listItem;
}
function listFromBlock(block, index, mode) {
    return {
        _type: "@list",
        _key: `${block._key || `${index}`}-parent`,
        mode,
        level: block.level || 1,
        listItem: block.listItem,
        children: [
            block
        ]
    };
}
function findListMatching(rootNode, matching) {
    const level = matching.level || 1, style = matching.listItem || "normal", filterOnType = typeof matching.listItem == "string";
    if (isPortableTextToolkitList(rootNode) && (rootNode.level || 1) === level && filterOnType && (rootNode.listItem || "normal") === style) return rootNode;
    if (!("children" in rootNode)) return;
    const node = rootNode.children[rootNode.children.length - 1];
    return node && !isPortableTextSpan(node) ? findListMatching(node, matching) : void 0;
}
function spanToPlainText(span) {
    let text = "";
    return span.children.forEach((current)=>{
        isPortableTextToolkitTextNode(current) ? text += current.text : isPortableTextToolkitSpan(current) && (text += spanToPlainText(current));
    }), text;
}
const leadingSpace = /^\s/, trailingSpace = /\s$/;
function toPlainText(block) {
    const blocks = Array.isArray(block) ? block : [
        block
    ];
    let text = "";
    return blocks.forEach((current, index)=>{
        if (!isPortableTextBlock(current)) return;
        let pad = !1;
        current.children.forEach((span)=>{
            isPortableTextSpan(span) ? (text += pad && text && !trailingSpace.test(text) && !leadingSpace.test(span.text) ? " " : "", text += span.text, pad = !1) : pad = !0;
        }), index !== blocks.length - 1 && (text += `

`);
    }), text;
}
const LIST_NEST_MODE_HTML = "html", LIST_NEST_MODE_DIRECT = "direct";
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@portabletext/react/dist/index.js [app-ssr] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "PortableText": (()=>PortableText),
    "defaultComponents": (()=>defaultComponents),
    "mergeComponents": (()=>mergeComponents)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/toolkit/dist/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
const _excluded = [
    "block",
    "list",
    "listItem",
    "marks",
    "types"
], _excluded2 = [
    "listItem"
], _excluded3 = [
    "_key"
];
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
function _objectWithoutProperties(e, t) {
    if (null == e) return {};
    var o, r, i = _objectWithoutPropertiesLoose(e, t);
    if (Object.getOwnPropertySymbols) {
        var s = Object.getOwnPropertySymbols(e);
        for(r = 0; r < s.length; r++)o = s[r], t.includes(o) || ({}).propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
}
function _objectWithoutPropertiesLoose(r, e) {
    if (null == r) return {};
    var t = {};
    for(var n in r)if (({}).hasOwnProperty.call(r, n)) {
        if (e.includes(n)) continue;
        t[n] = r[n];
    }
    return t;
}
;
;
;
;
const defaultLists = {
    number: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("ol", {
            children
        }),
    bullet: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("ul", {
            children
        })
}, DefaultListItem = ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("li", {
        children
    }), link = ({ children, value })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("a", {
        href: value?.href,
        children
    }), underlineStyle = {
    textDecoration: "underline"
}, defaultMarks = {
    em: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("em", {
            children
        }),
    strong: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("strong", {
            children
        }),
    code: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("code", {
            children
        }),
    underline: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("span", {
            style: underlineStyle,
            children
        }),
    "strike-through": ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("del", {
            children
        }),
    link
}, getTemplate = (type, prop)=>`[@portabletext/react] Unknown ${type}, specify a component for it in the \`components.${prop}\` prop`, unknownTypeWarning = (typeName)=>getTemplate(`block type "${typeName}"`, "types"), unknownMarkWarning = (markType)=>getTemplate(`mark type "${markType}"`, "marks"), unknownBlockStyleWarning = (blockStyle)=>getTemplate(`block style "${blockStyle}"`, "block"), unknownListStyleWarning = (listStyle)=>getTemplate(`list style "${listStyle}"`, "list"), unknownListItemStyleWarning = (listStyle)=>getTemplate(`list item style "${listStyle}"`, "listItem");
function printWarning(message) {
    console.warn(message);
}
const hidden = {
    display: "none"
}, DefaultUnknownType = ({ value, isInline })=>{
    const warning = unknownTypeWarning(value._type);
    return isInline ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("span", {
        style: hidden,
        children: warning
    }) : /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("div", {
        style: hidden,
        children: warning
    });
}, DefaultUnknownMark = ({ markType, children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("span", {
        className: `unknown__pt__mark__${markType}`,
        children
    }), DefaultUnknownBlockStyle = ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("p", {
        children
    }), DefaultUnknownList = ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("ul", {
        children
    }), DefaultUnknownListItem = ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("li", {
        children
    }), DefaultHardBreak = ()=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("br", {}), defaultBlockStyles = {
    normal: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("p", {
            children
        }),
    blockquote: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("blockquote", {
            children
        }),
    h1: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("h1", {
            children
        }),
    h2: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("h2", {
            children
        }),
    h3: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("h3", {
            children
        }),
    h4: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("h4", {
            children
        }),
    h5: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("h5", {
            children
        }),
    h6: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("h6", {
            children
        })
}, defaultComponents = {
    types: {},
    block: defaultBlockStyles,
    marks: defaultMarks,
    list: defaultLists,
    listItem: DefaultListItem,
    hardBreak: DefaultHardBreak,
    unknownType: DefaultUnknownType,
    unknownMark: DefaultUnknownMark,
    unknownList: DefaultUnknownList,
    unknownListItem: DefaultUnknownListItem,
    unknownBlockStyle: DefaultUnknownBlockStyle
};
function mergeComponents(parent, overrides) {
    const { block, list, listItem, marks, types } = overrides, rest = _objectWithoutProperties(overrides, _excluded);
    return _objectSpread(_objectSpread({}, parent), {}, {
        block: mergeDeeply(parent, overrides, "block"),
        list: mergeDeeply(parent, overrides, "list"),
        listItem: mergeDeeply(parent, overrides, "listItem"),
        marks: mergeDeeply(parent, overrides, "marks"),
        types: mergeDeeply(parent, overrides, "types")
    }, rest);
}
function mergeDeeply(parent, overrides, key) {
    const override = overrides[key], parentVal = parent[key];
    return typeof override == "function" || override && typeof parentVal == "function" ? override : override ? _objectSpread(_objectSpread({}, parentVal), override) : parentVal;
}
function PortableText({ value: input, components: componentOverrides, listNestingMode, onMissingComponent: missingComponentHandler = printWarning }) {
    const handleMissingComponent = missingComponentHandler || noop, blocks = Array.isArray(input) ? input : [
        input
    ], nested = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nestLists"])(blocks, listNestingMode || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LIST_NEST_MODE_HTML"]), components = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useMemo"])(()=>componentOverrides ? mergeComponents(defaultComponents, componentOverrides) : defaultComponents, [
        componentOverrides
    ]), renderNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useMemo"])(()=>getNodeRenderer(components, handleMissingComponent), [
        components,
        handleMissingComponent
    ]), rendered = nested.map((node, index)=>renderNode({
            node,
            index,
            isInline: !1,
            renderNode
        }));
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Fragment"], {
        children: rendered
    });
}
const getNodeRenderer = (components, handleMissingComponent)=>{
    function renderNode(options) {
        const { node, index, isInline } = options, key = node._key || `node-${index}`;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isPortableTextToolkitList"])(node) ? renderList(node, index, key) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isPortableTextListItemBlock"])(node) ? renderListItem(node, index, key) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isPortableTextToolkitSpan"])(node) ? renderSpan(node, index, key) : hasCustomComponentForNode(node) ? renderCustomBlock(node, index, key, isInline) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isPortableTextBlock"])(node) ? renderBlock(node, index, key, isInline) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isPortableTextToolkitTextNode"])(node) ? renderText(node, key) : renderUnknownType(node, index, key, isInline);
    }
    function hasCustomComponentForNode(node) {
        return node._type in components.types;
    }
    function renderListItem(node, index, key) {
        const tree = serializeBlock({
            node,
            index,
            isInline: !1,
            renderNode
        }), renderer = components.listItem, Li = (typeof renderer == "function" ? renderer : renderer[node.listItem]) || components.unknownListItem;
        if (Li === components.unknownListItem) {
            const style = node.listItem || "bullet";
            handleMissingComponent(unknownListItemStyleWarning(style), {
                type: style,
                nodeType: "listItemStyle"
            });
        }
        let children = tree.children;
        if (node.style && node.style !== "normal") {
            const { listItem } = node, blockNode = _objectWithoutProperties(node, _excluded2);
            children = renderNode({
                node: blockNode,
                index,
                isInline: !1,
                renderNode
            });
        }
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])(Li, {
            value: node,
            index,
            isInline: !1,
            renderNode,
            children
        }, key);
    }
    function renderList(node, index, key) {
        const children = node.children.map((child, childIndex)=>renderNode({
                node: child._key ? child : _objectSpread(_objectSpread({}, child), {}, {
                    _key: `li-${index}-${childIndex}`
                }),
                index: childIndex,
                isInline: !1,
                renderNode
            })), component = components.list, List = (typeof component == "function" ? component : component[node.listItem]) || components.unknownList;
        if (List === components.unknownList) {
            const style = node.listItem || "bullet";
            handleMissingComponent(unknownListStyleWarning(style), {
                nodeType: "listStyle",
                type: style
            });
        }
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])(List, {
            value: node,
            index,
            isInline: !1,
            renderNode,
            children
        }, key);
    }
    function renderSpan(node, _index, key) {
        const { markDef, markType, markKey } = node, Span = components.marks[markType] || components.unknownMark, children = node.children.map((child, childIndex)=>renderNode({
                node: child,
                index: childIndex,
                isInline: !0,
                renderNode
            }));
        return Span === components.unknownMark && handleMissingComponent(unknownMarkWarning(markType), {
            nodeType: "mark",
            type: markType
        }), /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])(Span, {
            text: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["spanToPlainText"])(node),
            value: markDef,
            markType,
            markKey,
            renderNode,
            children
        }, key);
    }
    function renderBlock(node, index, key, isInline) {
        const _serializeBlock = serializeBlock({
            node,
            index,
            isInline,
            renderNode
        }), { _key } = _serializeBlock, props = _objectWithoutProperties(_serializeBlock, _excluded3), style = props.node.style || "normal", Block = (typeof components.block == "function" ? components.block : components.block[style]) || components.unknownBlockStyle;
        return Block === components.unknownBlockStyle && handleMissingComponent(unknownBlockStyleWarning(style), {
            nodeType: "blockStyle",
            type: style
        }), /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])(Block, _objectSpread(_objectSpread({}, props), {}, {
            value: props.node,
            renderNode
        }), key);
    }
    function renderText(node, key) {
        if (node.text === `
`) {
            const HardBreak = components.hardBreak;
            return HardBreak ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])(HardBreak, {}, key) : `
`;
        }
        return node.text;
    }
    function renderUnknownType(node, index, key, isInline) {
        const nodeOptions = {
            value: node,
            isInline,
            index,
            renderNode
        };
        handleMissingComponent(unknownTypeWarning(node._type), {
            nodeType: "block",
            type: node._type
        });
        const UnknownType = components.unknownType;
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])(UnknownType, _objectSpread({}, nodeOptions), key);
    }
    function renderCustomBlock(node, index, key, isInline) {
        const nodeOptions = {
            value: node,
            isInline,
            index,
            renderNode
        }, Node = components.types[node._type];
        return Node ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])(Node, _objectSpread({}, nodeOptions), key) : null;
    }
    return renderNode;
};
function serializeBlock(options) {
    const { node, index, isInline, renderNode } = options, children = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["buildMarksTree"])(node).map((child, i)=>renderNode({
            node: child,
            isInline: !0,
            index: i,
            renderNode
        }));
    return {
        _key: node._key || `block-${index}`,
        children,
        index,
        isInline,
        node
    };
}
function noop() {}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/image-external.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    default: null,
    getImageProps: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    default: function() {
        return _default;
    },
    getImageProps: function() {
        return getImageProps;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-ssr] (ecmascript)");
const _getimgprops = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/get-img-props.js [app-ssr] (ecmascript)");
const _imagecomponent = __turbopack_context__.r("[project]/node_modules/next/dist/client/image-component.js [app-ssr] (ecmascript)");
const _imageloader = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/image-loader.js [app-ssr] (ecmascript)"));
function getImageProps(imgProps) {
    const { props } = (0, _getimgprops.getImgProps)(imgProps, {
        defaultLoader: _imageloader.default,
        // This is replaced by webpack define plugin
        imgConf: ("TURBOPACK compile-time value", JSON.parse('{"deviceSizes":[640,750,828,1080,1200,1920,2048,3840],"imageSizes":[16,32,48,64,96,128,256,384],"path":"/_next/image","loader":"default","dangerouslyAllowSVG":false,"unoptimized":false,"domains":[],"remotePatterns":[{"protocol":"https","hostname":"cdn.sanity.io"},{"protocol":"https","hostname":"placehold.co"}]}'))
    });
    // Normally we don't care about undefined props because we pass to JSX,
    // but this exported function could be used by the end user for anything
    // so we delete undefined props to clean it up a little.
    for (const [key, value] of Object.entries(props)){
        if (value === undefined) {
            delete props[key];
        }
    }
    return {
        props
    };
}
const _default = _imagecomponent.Image; //# sourceMappingURL=image-external.js.map
}}),
"[project]/node_modules/next/image.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/image-external.js [app-ssr] (ecmascript)");
}}),
"[project]/node_modules/@sanity/image-url/lib/node/parseAssetId.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
var example = 'image-Tb9Ew8CXIwaY6R1kjMvI0uRR-2000x3000-jpg';
function parseAssetId(ref) {
    var _a = ref.split('-'), id = _a[1], dimensionString = _a[2], format = _a[3];
    if (!id || !dimensionString || !format) {
        throw new Error("Malformed asset _ref '".concat(ref, "'. Expected an id like \"").concat(example, "\"."));
    }
    var _b = dimensionString.split('x'), imgWidthStr = _b[0], imgHeightStr = _b[1];
    var width = +imgWidthStr;
    var height = +imgHeightStr;
    var isValidAssetId = isFinite(width) && isFinite(height);
    if (!isValidAssetId) {
        throw new Error("Malformed asset _ref '".concat(ref, "'. Expected an id like \"").concat(example, "\"."));
    }
    return {
        id: id,
        width: width,
        height: height,
        format: format
    };
}
exports.default = parseAssetId; //# sourceMappingURL=parseAssetId.js.map
}}),
"[project]/node_modules/@sanity/image-url/lib/node/parseSource.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __assign = this && this.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
var isRef = function(src) {
    var source = src;
    return source ? typeof source._ref === 'string' : false;
};
var isAsset = function(src) {
    var source = src;
    return source ? typeof source._id === 'string' : false;
};
var isAssetStub = function(src) {
    var source = src;
    return source && source.asset ? typeof source.asset.url === 'string' : false;
};
// Convert an asset-id, asset or image to an image record suitable for processing
// eslint-disable-next-line complexity
function parseSource(source) {
    if (!source) {
        return null;
    }
    var image;
    if (typeof source === 'string' && isUrl(source)) {
        // Someone passed an existing image url?
        image = {
            asset: {
                _ref: urlToId(source)
            }
        };
    } else if (typeof source === 'string') {
        // Just an asset id
        image = {
            asset: {
                _ref: source
            }
        };
    } else if (isRef(source)) {
        // We just got passed an asset directly
        image = {
            asset: source
        };
    } else if (isAsset(source)) {
        // If we were passed an image asset document
        image = {
            asset: {
                _ref: source._id || ''
            }
        };
    } else if (isAssetStub(source)) {
        // If we were passed a partial asset (`url`, but no `_id`)
        image = {
            asset: {
                _ref: urlToId(source.asset.url)
            }
        };
    } else if (typeof source.asset === 'object') {
        // Probably an actual image with materialized asset
        image = __assign({}, source);
    } else {
        // We got something that does not look like an image, or it is an image
        // that currently isn't sporting an asset.
        return null;
    }
    var img = source;
    if (img.crop) {
        image.crop = img.crop;
    }
    if (img.hotspot) {
        image.hotspot = img.hotspot;
    }
    return applyDefaults(image);
}
exports.default = parseSource;
function isUrl(url) {
    return /^https?:\/\//.test("".concat(url));
}
function urlToId(url) {
    var parts = url.split('/').slice(-1);
    return "image-".concat(parts[0]).replace(/\.([a-z]+)$/, '-$1');
}
// Mock crop and hotspot if image lacks it
function applyDefaults(image) {
    if (image.crop && image.hotspot) {
        return image;
    }
    // We need to pad in default values for crop or hotspot
    var result = __assign({}, image);
    if (!result.crop) {
        result.crop = {
            left: 0,
            top: 0,
            bottom: 0,
            right: 0
        };
    }
    if (!result.hotspot) {
        result.hotspot = {
            x: 0.5,
            y: 0.5,
            height: 1.0,
            width: 1.0
        };
    }
    return result;
} //# sourceMappingURL=parseSource.js.map
}}),
"[project]/node_modules/@sanity/image-url/lib/node/urlForImage.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __assign = this && this.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parseSource = exports.SPEC_NAME_TO_URL_NAME_MAPPINGS = void 0;
var parseAssetId_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/@sanity/image-url/lib/node/parseAssetId.js [app-ssr] (ecmascript)"));
var parseSource_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/@sanity/image-url/lib/node/parseSource.js [app-ssr] (ecmascript)"));
exports.parseSource = parseSource_1.default;
exports.SPEC_NAME_TO_URL_NAME_MAPPINGS = [
    [
        'width',
        'w'
    ],
    [
        'height',
        'h'
    ],
    [
        'format',
        'fm'
    ],
    [
        'download',
        'dl'
    ],
    [
        'blur',
        'blur'
    ],
    [
        'sharpen',
        'sharp'
    ],
    [
        'invert',
        'invert'
    ],
    [
        'orientation',
        'or'
    ],
    [
        'minHeight',
        'min-h'
    ],
    [
        'maxHeight',
        'max-h'
    ],
    [
        'minWidth',
        'min-w'
    ],
    [
        'maxWidth',
        'max-w'
    ],
    [
        'quality',
        'q'
    ],
    [
        'fit',
        'fit'
    ],
    [
        'crop',
        'crop'
    ],
    [
        'saturation',
        'sat'
    ],
    [
        'auto',
        'auto'
    ],
    [
        'dpr',
        'dpr'
    ],
    [
        'pad',
        'pad'
    ],
    [
        'frame',
        'frame'
    ]
];
function urlForImage(options) {
    var spec = __assign({}, options || {});
    var source = spec.source;
    delete spec.source;
    var image = (0, parseSource_1.default)(source);
    if (!image) {
        throw new Error("Unable to resolve image URL from source (".concat(JSON.stringify(source), ")"));
    }
    var id = image.asset._ref || image.asset._id || '';
    var asset = (0, parseAssetId_1.default)(id);
    // Compute crop rect in terms of pixel coordinates in the raw source image
    var cropLeft = Math.round(image.crop.left * asset.width);
    var cropTop = Math.round(image.crop.top * asset.height);
    var crop = {
        left: cropLeft,
        top: cropTop,
        width: Math.round(asset.width - image.crop.right * asset.width - cropLeft),
        height: Math.round(asset.height - image.crop.bottom * asset.height - cropTop)
    };
    // Compute hot spot rect in terms of pixel coordinates
    var hotSpotVerticalRadius = image.hotspot.height * asset.height / 2;
    var hotSpotHorizontalRadius = image.hotspot.width * asset.width / 2;
    var hotSpotCenterX = image.hotspot.x * asset.width;
    var hotSpotCenterY = image.hotspot.y * asset.height;
    var hotspot = {
        left: hotSpotCenterX - hotSpotHorizontalRadius,
        top: hotSpotCenterY - hotSpotVerticalRadius,
        right: hotSpotCenterX + hotSpotHorizontalRadius,
        bottom: hotSpotCenterY + hotSpotVerticalRadius
    };
    // If irrelevant, or if we are requested to: don't perform crop/fit based on
    // the crop/hotspot.
    if (!(spec.rect || spec.focalPoint || spec.ignoreImageParams || spec.crop)) {
        spec = __assign(__assign({}, spec), fit({
            crop: crop,
            hotspot: hotspot
        }, spec));
    }
    return specToImageUrl(__assign(__assign({}, spec), {
        asset: asset
    }));
}
exports.default = urlForImage;
// eslint-disable-next-line complexity
function specToImageUrl(spec) {
    var cdnUrl = (spec.baseUrl || 'https://cdn.sanity.io').replace(/\/+$/, '');
    var vanityStub = spec.vanityName ? "/".concat(spec.vanityName) : '';
    var filename = "".concat(spec.asset.id, "-").concat(spec.asset.width, "x").concat(spec.asset.height, ".").concat(spec.asset.format).concat(vanityStub);
    var baseUrl = "".concat(cdnUrl, "/images/").concat(spec.projectId, "/").concat(spec.dataset, "/").concat(filename);
    var params = [];
    if (spec.rect) {
        // Only bother url with a crop if it actually crops anything
        var _a = spec.rect, left = _a.left, top_1 = _a.top, width = _a.width, height = _a.height;
        var isEffectiveCrop = left !== 0 || top_1 !== 0 || height !== spec.asset.height || width !== spec.asset.width;
        if (isEffectiveCrop) {
            params.push("rect=".concat(left, ",").concat(top_1, ",").concat(width, ",").concat(height));
        }
    }
    if (spec.bg) {
        params.push("bg=".concat(spec.bg));
    }
    if (spec.focalPoint) {
        params.push("fp-x=".concat(spec.focalPoint.x));
        params.push("fp-y=".concat(spec.focalPoint.y));
    }
    var flip = [
        spec.flipHorizontal && 'h',
        spec.flipVertical && 'v'
    ].filter(Boolean).join('');
    if (flip) {
        params.push("flip=".concat(flip));
    }
    // Map from spec name to url param name, and allow using the actual param name as an alternative
    exports.SPEC_NAME_TO_URL_NAME_MAPPINGS.forEach(function(mapping) {
        var specName = mapping[0], param = mapping[1];
        if (typeof spec[specName] !== 'undefined') {
            params.push("".concat(param, "=").concat(encodeURIComponent(spec[specName])));
        } else if (typeof spec[param] !== 'undefined') {
            params.push("".concat(param, "=").concat(encodeURIComponent(spec[param])));
        }
    });
    if (params.length === 0) {
        return baseUrl;
    }
    return "".concat(baseUrl, "?").concat(params.join('&'));
}
function fit(source, spec) {
    var cropRect;
    var imgWidth = spec.width;
    var imgHeight = spec.height;
    // If we are not constraining the aspect ratio, we'll just use the whole crop
    if (!(imgWidth && imgHeight)) {
        return {
            width: imgWidth,
            height: imgHeight,
            rect: source.crop
        };
    }
    var crop = source.crop;
    var hotspot = source.hotspot;
    // If we are here, that means aspect ratio is locked and fitting will be a bit harder
    var desiredAspectRatio = imgWidth / imgHeight;
    var cropAspectRatio = crop.width / crop.height;
    if (cropAspectRatio > desiredAspectRatio) {
        // The crop is wider than the desired aspect ratio. That means we are cutting from the sides
        var height = Math.round(crop.height);
        var width = Math.round(height * desiredAspectRatio);
        var top_2 = Math.max(0, Math.round(crop.top));
        // Center output horizontally over hotspot
        var hotspotXCenter = Math.round((hotspot.right - hotspot.left) / 2 + hotspot.left);
        var left = Math.max(0, Math.round(hotspotXCenter - width / 2));
        // Keep output within crop
        if (left < crop.left) {
            left = crop.left;
        } else if (left + width > crop.left + crop.width) {
            left = crop.left + crop.width - width;
        }
        cropRect = {
            left: left,
            top: top_2,
            width: width,
            height: height
        };
    } else {
        // The crop is taller than the desired ratio, we are cutting from top and bottom
        var width = crop.width;
        var height = Math.round(width / desiredAspectRatio);
        var left = Math.max(0, Math.round(crop.left));
        // Center output vertically over hotspot
        var hotspotYCenter = Math.round((hotspot.bottom - hotspot.top) / 2 + hotspot.top);
        var top_3 = Math.max(0, Math.round(hotspotYCenter - height / 2));
        // Keep output rect within crop
        if (top_3 < crop.top) {
            top_3 = crop.top;
        } else if (top_3 + height > crop.top + crop.height) {
            top_3 = crop.top + crop.height - height;
        }
        cropRect = {
            left: left,
            top: top_3,
            width: width,
            height: height
        };
    }
    return {
        width: imgWidth,
        height: imgHeight,
        rect: cropRect
    };
} //# sourceMappingURL=urlForImage.js.map
}}),
"[project]/node_modules/@sanity/image-url/lib/node/builder.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __assign = this && this.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ImageUrlBuilder = void 0;
var urlForImage_1 = __importStar(__turbopack_context__.r("[project]/node_modules/@sanity/image-url/lib/node/urlForImage.js [app-ssr] (ecmascript)"));
var validFits = [
    'clip',
    'crop',
    'fill',
    'fillmax',
    'max',
    'scale',
    'min'
];
var validCrops = [
    'top',
    'bottom',
    'left',
    'right',
    'center',
    'focalpoint',
    'entropy'
];
var validAutoModes = [
    'format'
];
function isSanityModernClientLike(client) {
    return client && 'config' in client ? typeof client.config === 'function' : false;
}
function isSanityClientLike(client) {
    return client && 'clientConfig' in client ? typeof client.clientConfig === 'object' : false;
}
function rewriteSpecName(key) {
    var specs = urlForImage_1.SPEC_NAME_TO_URL_NAME_MAPPINGS;
    for(var _i = 0, specs_1 = specs; _i < specs_1.length; _i++){
        var entry = specs_1[_i];
        var specName = entry[0], param = entry[1];
        if (key === specName || key === param) {
            return specName;
        }
    }
    return key;
}
function urlBuilder(options) {
    // Did we get a modernish client?
    if (isSanityModernClientLike(options)) {
        // Inherit config from client
        var _a = options.config(), apiUrl = _a.apiHost, projectId = _a.projectId, dataset = _a.dataset;
        var apiHost = apiUrl || 'https://api.sanity.io';
        return new ImageUrlBuilder(null, {
            baseUrl: apiHost.replace(/^https:\/\/api\./, 'https://cdn.'),
            projectId: projectId,
            dataset: dataset
        });
    }
    // Did we get a SanityClient?
    if (isSanityClientLike(options)) {
        // Inherit config from client
        var _b = options.clientConfig, apiUrl = _b.apiHost, projectId = _b.projectId, dataset = _b.dataset;
        var apiHost = apiUrl || 'https://api.sanity.io';
        return new ImageUrlBuilder(null, {
            baseUrl: apiHost.replace(/^https:\/\/api\./, 'https://cdn.'),
            projectId: projectId,
            dataset: dataset
        });
    }
    // Or just accept the options as given
    return new ImageUrlBuilder(null, options || {});
}
exports.default = urlBuilder;
var ImageUrlBuilder = function() {
    function ImageUrlBuilder(parent, options) {
        this.options = parent ? __assign(__assign({}, parent.options || {}), options || {}) : __assign({}, options || {}); // Copy options
    }
    ImageUrlBuilder.prototype.withOptions = function(options) {
        var baseUrl = options.baseUrl || this.options.baseUrl;
        var newOptions = {
            baseUrl: baseUrl
        };
        for(var key in options){
            if (options.hasOwnProperty(key)) {
                var specKey = rewriteSpecName(key);
                newOptions[specKey] = options[key];
            }
        }
        return new ImageUrlBuilder(this, __assign({
            baseUrl: baseUrl
        }, newOptions));
    };
    // The image to be represented. Accepts a Sanity 'image'-document, 'asset'-document or
    // _id of asset. To get the benefit of automatic hot-spot/crop integration with the content
    // studio, the 'image'-document must be provided.
    ImageUrlBuilder.prototype.image = function(source) {
        return this.withOptions({
            source: source
        });
    };
    // Specify the dataset
    ImageUrlBuilder.prototype.dataset = function(dataset) {
        return this.withOptions({
            dataset: dataset
        });
    };
    // Specify the projectId
    ImageUrlBuilder.prototype.projectId = function(projectId) {
        return this.withOptions({
            projectId: projectId
        });
    };
    // Specify background color
    ImageUrlBuilder.prototype.bg = function(bg) {
        return this.withOptions({
            bg: bg
        });
    };
    // Set DPR scaling factor
    ImageUrlBuilder.prototype.dpr = function(dpr) {
        // A DPR of 1 is the default - so only include it if we have a different value
        return this.withOptions(dpr && dpr !== 1 ? {
            dpr: dpr
        } : {});
    };
    // Specify the width of the image in pixels
    ImageUrlBuilder.prototype.width = function(width) {
        return this.withOptions({
            width: width
        });
    };
    // Specify the height of the image in pixels
    ImageUrlBuilder.prototype.height = function(height) {
        return this.withOptions({
            height: height
        });
    };
    // Specify focal point in fraction of image dimensions. Each component 0.0-1.0
    ImageUrlBuilder.prototype.focalPoint = function(x, y) {
        return this.withOptions({
            focalPoint: {
                x: x,
                y: y
            }
        });
    };
    ImageUrlBuilder.prototype.maxWidth = function(maxWidth) {
        return this.withOptions({
            maxWidth: maxWidth
        });
    };
    ImageUrlBuilder.prototype.minWidth = function(minWidth) {
        return this.withOptions({
            minWidth: minWidth
        });
    };
    ImageUrlBuilder.prototype.maxHeight = function(maxHeight) {
        return this.withOptions({
            maxHeight: maxHeight
        });
    };
    ImageUrlBuilder.prototype.minHeight = function(minHeight) {
        return this.withOptions({
            minHeight: minHeight
        });
    };
    // Specify width and height in pixels
    ImageUrlBuilder.prototype.size = function(width, height) {
        return this.withOptions({
            width: width,
            height: height
        });
    };
    // Specify blur between 0 and 100
    ImageUrlBuilder.prototype.blur = function(blur) {
        return this.withOptions({
            blur: blur
        });
    };
    ImageUrlBuilder.prototype.sharpen = function(sharpen) {
        return this.withOptions({
            sharpen: sharpen
        });
    };
    // Specify the desired rectangle of the image
    ImageUrlBuilder.prototype.rect = function(left, top, width, height) {
        return this.withOptions({
            rect: {
                left: left,
                top: top,
                width: width,
                height: height
            }
        });
    };
    // Specify the image format of the image. 'jpg', 'pjpg', 'png', 'webp'
    ImageUrlBuilder.prototype.format = function(format) {
        return this.withOptions({
            format: format
        });
    };
    ImageUrlBuilder.prototype.invert = function(invert) {
        return this.withOptions({
            invert: invert
        });
    };
    // Rotation in degrees 0, 90, 180, 270
    ImageUrlBuilder.prototype.orientation = function(orientation) {
        return this.withOptions({
            orientation: orientation
        });
    };
    // Compression quality 0-100
    ImageUrlBuilder.prototype.quality = function(quality) {
        return this.withOptions({
            quality: quality
        });
    };
    // Make it a download link. Parameter is default filename.
    ImageUrlBuilder.prototype.forceDownload = function(download) {
        return this.withOptions({
            download: download
        });
    };
    // Flip image horizontally
    ImageUrlBuilder.prototype.flipHorizontal = function() {
        return this.withOptions({
            flipHorizontal: true
        });
    };
    // Flip image vertically
    ImageUrlBuilder.prototype.flipVertical = function() {
        return this.withOptions({
            flipVertical: true
        });
    };
    // Ignore crop/hotspot from image record, even when present
    ImageUrlBuilder.prototype.ignoreImageParams = function() {
        return this.withOptions({
            ignoreImageParams: true
        });
    };
    ImageUrlBuilder.prototype.fit = function(value) {
        if (validFits.indexOf(value) === -1) {
            throw new Error("Invalid fit mode \"".concat(value, "\""));
        }
        return this.withOptions({
            fit: value
        });
    };
    ImageUrlBuilder.prototype.crop = function(value) {
        if (validCrops.indexOf(value) === -1) {
            throw new Error("Invalid crop mode \"".concat(value, "\""));
        }
        return this.withOptions({
            crop: value
        });
    };
    // Saturation
    ImageUrlBuilder.prototype.saturation = function(saturation) {
        return this.withOptions({
            saturation: saturation
        });
    };
    ImageUrlBuilder.prototype.auto = function(value) {
        if (validAutoModes.indexOf(value) === -1) {
            throw new Error("Invalid auto mode \"".concat(value, "\""));
        }
        return this.withOptions({
            auto: value
        });
    };
    // Specify the number of pixels to pad the image
    ImageUrlBuilder.prototype.pad = function(pad) {
        return this.withOptions({
            pad: pad
        });
    };
    // Vanity URL for more SEO friendly URLs
    ImageUrlBuilder.prototype.vanityName = function(value) {
        return this.withOptions({
            vanityName: value
        });
    };
    ImageUrlBuilder.prototype.frame = function(frame) {
        if (frame !== 1) {
            throw new Error("Invalid frame value \"".concat(frame, "\""));
        }
        return this.withOptions({
            frame: frame
        });
    };
    // Gets the url based on the submitted parameters
    ImageUrlBuilder.prototype.url = function() {
        return (0, urlForImage_1.default)(this.options);
    };
    // Alias for url()
    ImageUrlBuilder.prototype.toString = function() {
        return this.url();
    };
    return ImageUrlBuilder;
}();
exports.ImageUrlBuilder = ImageUrlBuilder; //# sourceMappingURL=builder.js.map
}}),
"[project]/node_modules/@sanity/image-url/lib/node/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
var builder_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/@sanity/image-url/lib/node/builder.js [app-ssr] (ecmascript)"));
module.exports = builder_1.default; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/clsx/dist/clsx.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "clsx": (()=>clsx),
    "default": (()=>__TURBOPACK__default__export__)
});
function r(e) {
    var t, f, n = "";
    if ("string" == typeof e || "number" == typeof e) n += e;
    else if ("object" == typeof e) if (Array.isArray(e)) {
        var o = e.length;
        for(t = 0; t < o; t++)e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
    } else for(f in e)e[f] && (n && (n += " "), n += f);
    return n;
}
function clsx() {
    for(var e, t, f = 0, n = "", o = arguments.length; f < o; f++)(e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
    return n;
}
const __TURBOPACK__default__export__ = clsx;
}}),
"[project]/node_modules/@sanity/client/dist/_chunks-es/resolveEditInfo.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "DRAFTS_FOLDER": (()=>DRAFTS_FOLDER),
    "VERSION_FOLDER": (()=>VERSION_FOLDER),
    "createEditUrl": (()=>createEditUrl),
    "get": (()=>get),
    "getDraftId": (()=>getDraftId),
    "getPublishedId": (()=>getPublishedId),
    "getVersionFromId": (()=>getVersionFromId),
    "getVersionId": (()=>getVersionId),
    "isDraftId": (()=>isDraftId),
    "isPublishedId": (()=>isPublishedId),
    "isVersionId": (()=>isVersionId),
    "jsonPath": (()=>jsonPath),
    "jsonPathToStudioPath": (()=>jsonPathToStudioPath),
    "parseJsonPath": (()=>parseJsonPath),
    "reKeySegment": (()=>reKeySegment),
    "resolveEditInfo": (()=>resolveEditInfo),
    "resolveMapping": (()=>resolveMapping),
    "resolveStudioBaseRoute": (()=>resolveStudioBaseRoute),
    "studioPath": (()=>studioPath),
    "studioPathToJsonPath": (()=>studioPathToJsonPath),
    "toString": (()=>toString),
    "walkMap": (()=>walkMap)
});
const rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, reKeySegment = /_key\s*==\s*['"](.*)['"]/, reIndexTuple = /^\d*:\d*$/;
function isIndexSegment(segment) {
    return typeof segment == "number" || typeof segment == "string" && /^\[\d+\]$/.test(segment);
}
function isKeySegment(segment) {
    return typeof segment == "string" ? reKeySegment.test(segment.trim()) : typeof segment == "object" && "_key" in segment;
}
function isIndexTuple(segment) {
    if (typeof segment == "string" && reIndexTuple.test(segment)) return !0;
    if (!Array.isArray(segment) || segment.length !== 2) return !1;
    const [from, to] = segment;
    return (typeof from == "number" || from === "") && (typeof to == "number" || to === "");
}
function get(obj, path, defaultVal) {
    const select = typeof path == "string" ? fromString(path) : path;
    if (!Array.isArray(select)) throw new Error("Path must be an array or a string");
    let acc = obj;
    for(let i = 0; i < select.length; i++){
        const segment = select[i];
        if (isIndexSegment(segment)) {
            if (!Array.isArray(acc)) return defaultVal;
            acc = acc[segment];
        }
        if (isKeySegment(segment)) {
            if (!Array.isArray(acc)) return defaultVal;
            acc = acc.find((item)=>item._key === segment._key);
        }
        if (typeof segment == "string" && (acc = typeof acc == "object" && acc !== null ? acc[segment] : void 0), typeof acc > "u") return defaultVal;
    }
    return acc;
}
function toString(path) {
    if (!Array.isArray(path)) throw new Error("Path is not an array");
    return path.reduce((target, segment, i)=>{
        const segmentType = typeof segment;
        if (segmentType === "number") return `${target}[${segment}]`;
        if (segmentType === "string") return `${target}${i === 0 ? "" : "."}${segment}`;
        if (isKeySegment(segment) && segment._key) return `${target}[_key=="${segment._key}"]`;
        if (Array.isArray(segment)) {
            const [from, to] = segment;
            return `${target}[${from}:${to}]`;
        }
        throw new Error(`Unsupported path segment \`${JSON.stringify(segment)}\``);
    }, "");
}
function fromString(path) {
    if (typeof path != "string") throw new Error("Path is not a string");
    const segments = path.match(rePropName);
    if (!segments) throw new Error("Invalid path string");
    return segments.map(parsePathSegment);
}
function parsePathSegment(segment) {
    return isIndexSegment(segment) ? parseIndexSegment(segment) : isKeySegment(segment) ? parseKeySegment(segment) : isIndexTuple(segment) ? parseIndexTupleSegment(segment) : segment;
}
function parseIndexSegment(segment) {
    return Number(segment.replace(/[^\d]/g, ""));
}
function parseKeySegment(segment) {
    return {
        _key: segment.match(reKeySegment)[1]
    };
}
function parseIndexTupleSegment(segment) {
    const [from, to] = segment.split(":").map((seg)=>seg === "" ? seg : Number(seg));
    return [
        from,
        to
    ];
}
var studioPath = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    fromString,
    get,
    isIndexSegment,
    isIndexTuple,
    isKeySegment,
    reKeySegment,
    toString
});
const DRAFTS_FOLDER = "drafts", VERSION_FOLDER = "versions", PATH_SEPARATOR = ".", DRAFTS_PREFIX = `${DRAFTS_FOLDER}${PATH_SEPARATOR}`, VERSION_PREFIX = `${VERSION_FOLDER}${PATH_SEPARATOR}`;
function isDraftId(id) {
    return id.startsWith(DRAFTS_PREFIX);
}
function isVersionId(id) {
    return id.startsWith(VERSION_PREFIX);
}
function isPublishedId(id) {
    return !isDraftId(id) && !isVersionId(id);
}
function getDraftId(id) {
    if (isVersionId(id)) {
        const publishedId = getPublishedId(id);
        return DRAFTS_PREFIX + publishedId;
    }
    return isDraftId(id) ? id : DRAFTS_PREFIX + id;
}
function getVersionId(id, version) {
    if (version === "drafts" || version === "published") throw new Error('Version can not be "published" or "drafts"');
    return `${VERSION_PREFIX}${version}${PATH_SEPARATOR}${getPublishedId(id)}`;
}
function getVersionFromId(id) {
    if (!isVersionId(id)) return;
    const [_versionPrefix, versionId, ..._publishedId] = id.split(PATH_SEPARATOR);
    return versionId;
}
function getPublishedId(id) {
    return isVersionId(id) ? id.split(PATH_SEPARATOR).slice(2).join(PATH_SEPARATOR) : isDraftId(id) ? id.slice(DRAFTS_PREFIX.length) : id;
}
const ESCAPE = {
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t",
    "'": "\\'",
    "\\": "\\\\"
}, UNESCAPE = {
    "\\f": "\f",
    "\\n": `
`,
    "\\r": "\r",
    "\\t": "	",
    "\\'": "'",
    "\\\\": "\\"
};
function jsonPath(path) {
    return `$${path.map((segment)=>typeof segment == "string" ? `['${segment.replace(/[\f\n\r\t'\\]/g, (match)=>ESCAPE[match])}']` : typeof segment == "number" ? `[${segment}]` : segment._key !== "" ? `[?(@._key=='${segment._key.replace(/['\\]/g, (match)=>ESCAPE[match])}')]` : `[${segment._index}]`).join("")}`;
}
function parseJsonPath(path) {
    const parsed = [], parseRe = /\['(.*?)'\]|\[(\d+)\]|\[\?\(@\._key=='(.*?)'\)\]/g;
    let match;
    for(; (match = parseRe.exec(path)) !== null;){
        if (match[1] !== void 0) {
            const key = match[1].replace(/\\(\\|f|n|r|t|')/g, (m)=>UNESCAPE[m]);
            parsed.push(key);
            continue;
        }
        if (match[2] !== void 0) {
            parsed.push(parseInt(match[2], 10));
            continue;
        }
        if (match[3] !== void 0) {
            const _key = match[3].replace(/\\(\\')/g, (m)=>UNESCAPE[m]);
            parsed.push({
                _key,
                _index: -1
            });
            continue;
        }
    }
    return parsed;
}
function jsonPathToStudioPath(path) {
    return path.map((segment)=>{
        if (typeof segment == "string" || typeof segment == "number") return segment;
        if (segment._key !== "") return {
            _key: segment._key
        };
        if (segment._index !== -1) return segment._index;
        throw new Error(`invalid segment:${JSON.stringify(segment)}`);
    });
}
function studioPathToJsonPath(path) {
    return (typeof path == "string" ? fromString(path) : path).map((segment)=>{
        if (typeof segment == "string" || typeof segment == "number") return segment;
        if (Array.isArray(segment)) throw new Error(`IndexTuple segments aren't supported:${JSON.stringify(segment)}`);
        if (isContentSourceMapParsedPathKeyedSegment(segment)) return segment;
        if (segment._key) return {
            _key: segment._key,
            _index: -1
        };
        throw new Error(`invalid segment:${JSON.stringify(segment)}`);
    });
}
function isContentSourceMapParsedPathKeyedSegment(segment) {
    return typeof segment == "object" && "_key" in segment && "_index" in segment;
}
function jsonPathToMappingPath(path) {
    return path.map((segment)=>{
        if (typeof segment == "string" || typeof segment == "number") return segment;
        if (segment._index !== -1) return segment._index;
        throw new Error(`invalid segment:${JSON.stringify(segment)}`);
    });
}
function resolveMapping(resultPath, csm) {
    if (!csm?.mappings) return;
    const resultMappingPath = jsonPath(jsonPathToMappingPath(resultPath));
    if (csm.mappings[resultMappingPath] !== void 0) return {
        mapping: csm.mappings[resultMappingPath],
        matchedPath: resultMappingPath,
        pathSuffix: ""
    };
    const mappings = Object.entries(csm.mappings).filter(([key])=>resultMappingPath.startsWith(key)).sort(([key1], [key2])=>key2.length - key1.length);
    if (mappings.length == 0) return;
    const [matchedPath, mapping] = mappings[0], pathSuffix = resultMappingPath.substring(matchedPath.length);
    return {
        mapping,
        matchedPath,
        pathSuffix
    };
}
function isArray(value) {
    return value !== null && Array.isArray(value);
}
function isRecord(value) {
    return typeof value == "object" && value !== null;
}
function walkMap(value, mappingFn, path = []) {
    if (isArray(value)) return value.map((v, idx)=>{
        if (isRecord(v)) {
            const _key = v._key;
            if (typeof _key == "string") return walkMap(v, mappingFn, path.concat({
                _key,
                _index: idx
            }));
        }
        return walkMap(v, mappingFn, path.concat(idx));
    });
    if (isRecord(value)) {
        if (value._type === "block" || value._type === "span") {
            const result = {
                ...value
            };
            return value._type === "block" ? result.children = walkMap(value.children, mappingFn, path.concat("children")) : value._type === "span" && (result.text = walkMap(value.text, mappingFn, path.concat("text"))), result;
        }
        return Object.fromEntries(Object.entries(value).map(([k, v])=>[
                k,
                walkMap(v, mappingFn, path.concat(k))
            ]));
    }
    return mappingFn(value, path);
}
function createEditUrl(options) {
    const { baseUrl, workspace: _workspace = "default", tool: _tool = "default", id: _id, type, path, projectId, dataset } = options;
    if (!baseUrl) throw new Error("baseUrl is required");
    if (!path) throw new Error("path is required");
    if (!_id) throw new Error("id is required");
    if (baseUrl !== "/" && baseUrl.endsWith("/")) throw new Error("baseUrl must not end with a slash");
    const workspace = _workspace === "default" ? void 0 : _workspace, tool = _tool === "default" ? void 0 : _tool, id = getPublishedId(_id), stringifiedPath = Array.isArray(path) ? toString(jsonPathToStudioPath(path)) : path, searchParams = new URLSearchParams({
        baseUrl,
        id,
        type,
        path: stringifiedPath
    });
    if (workspace && searchParams.set("workspace", workspace), tool && searchParams.set("tool", tool), projectId && searchParams.set("projectId", projectId), dataset && searchParams.set("dataset", dataset), isPublishedId(_id)) searchParams.set("perspective", "published");
    else if (isVersionId(_id)) {
        const versionId = getVersionFromId(_id);
        searchParams.set("perspective", versionId);
    }
    const segments = [
        baseUrl === "/" ? "" : baseUrl
    ];
    workspace && segments.push(workspace);
    const routerParams = [
        "mode=presentation",
        `id=${id}`,
        `type=${type}`,
        `path=${encodeURIComponent(stringifiedPath)}`
    ];
    return tool && routerParams.push(`tool=${tool}`), segments.push("intent", "edit", `${routerParams.join(";")}?${searchParams}`), segments.join("/");
}
function resolveEditInfo(options) {
    const { resultSourceMap: csm, resultPath } = options, { mapping, pathSuffix } = resolveMapping(resultPath, csm) || {};
    if (!mapping || mapping.source.type === "literal" || mapping.source.type === "unknown") return;
    const sourceDoc = csm.documents[mapping.source.document], sourcePath = csm.paths[mapping.source.path];
    if (sourceDoc && sourcePath) {
        const { baseUrl, workspace, tool } = resolveStudioBaseRoute(typeof options.studioUrl == "function" ? options.studioUrl(sourceDoc) : options.studioUrl);
        if (!baseUrl) return;
        const { _id, _type, _projectId, _dataset } = sourceDoc;
        return {
            baseUrl,
            workspace,
            tool,
            id: _id,
            type: _type,
            path: parseJsonPath(sourcePath + pathSuffix),
            projectId: _projectId,
            dataset: _dataset
        };
    }
}
function resolveStudioBaseRoute(studioUrl) {
    let baseUrl = typeof studioUrl == "string" ? studioUrl : studioUrl.baseUrl;
    return baseUrl !== "/" && (baseUrl = baseUrl.replace(/\/$/, "")), typeof studioUrl == "string" ? {
        baseUrl
    } : {
        ...studioUrl,
        baseUrl
    };
}
;
 //# sourceMappingURL=resolveEditInfo.js.map
}}),
"[project]/node_modules/valibot/dist/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// src/storages/globalConfig/globalConfig.ts
__turbopack_context__.s({
    "BASE64_REGEX": (()=>BASE64_REGEX),
    "BIC_REGEX": (()=>BIC_REGEX),
    "CUID2_REGEX": (()=>CUID2_REGEX),
    "DECIMAL_REGEX": (()=>DECIMAL_REGEX),
    "DIGITS_REGEX": (()=>DIGITS_REGEX),
    "EMAIL_REGEX": (()=>EMAIL_REGEX),
    "EMOJI_REGEX": (()=>EMOJI_REGEX),
    "HEXADECIMAL_REGEX": (()=>HEXADECIMAL_REGEX),
    "HEX_COLOR_REGEX": (()=>HEX_COLOR_REGEX),
    "IMEI_REGEX": (()=>IMEI_REGEX),
    "IPV4_REGEX": (()=>IPV4_REGEX),
    "IPV6_REGEX": (()=>IPV6_REGEX),
    "IP_REGEX": (()=>IP_REGEX),
    "ISO_DATE_REGEX": (()=>ISO_DATE_REGEX),
    "ISO_DATE_TIME_REGEX": (()=>ISO_DATE_TIME_REGEX),
    "ISO_TIMESTAMP_REGEX": (()=>ISO_TIMESTAMP_REGEX),
    "ISO_TIME_REGEX": (()=>ISO_TIME_REGEX),
    "ISO_TIME_SECOND_REGEX": (()=>ISO_TIME_SECOND_REGEX),
    "ISO_WEEK_REGEX": (()=>ISO_WEEK_REGEX),
    "MAC48_REGEX": (()=>MAC48_REGEX),
    "MAC64_REGEX": (()=>MAC64_REGEX),
    "MAC_REGEX": (()=>MAC_REGEX),
    "NANO_ID_REGEX": (()=>NANO_ID_REGEX),
    "OCTAL_REGEX": (()=>OCTAL_REGEX),
    "RFC_EMAIL_REGEX": (()=>RFC_EMAIL_REGEX),
    "SLUG_REGEX": (()=>SLUG_REGEX),
    "ULID_REGEX": (()=>ULID_REGEX),
    "UUID_REGEX": (()=>UUID_REGEX),
    "ValiError": (()=>ValiError),
    "_addIssue": (()=>_addIssue),
    "_getByteCount": (()=>_getByteCount),
    "_getGraphemeCount": (()=>_getGraphemeCount),
    "_getStandardProps": (()=>_getStandardProps),
    "_getWordCount": (()=>_getWordCount),
    "_isLuhnAlgo": (()=>_isLuhnAlgo),
    "_isValidObjectKey": (()=>_isValidObjectKey),
    "_joinExpects": (()=>_joinExpects),
    "_stringify": (()=>_stringify),
    "any": (()=>any),
    "args": (()=>args),
    "argsAsync": (()=>argsAsync),
    "array": (()=>array),
    "arrayAsync": (()=>arrayAsync),
    "assert": (()=>assert),
    "awaitAsync": (()=>awaitAsync),
    "base64": (()=>base64),
    "bic": (()=>bic),
    "bigint": (()=>bigint),
    "blob": (()=>blob),
    "boolean": (()=>boolean),
    "brand": (()=>brand),
    "bytes": (()=>bytes),
    "check": (()=>check),
    "checkAsync": (()=>checkAsync),
    "checkItems": (()=>checkItems),
    "checkItemsAsync": (()=>checkItemsAsync),
    "config": (()=>config),
    "creditCard": (()=>creditCard),
    "cuid2": (()=>cuid2),
    "custom": (()=>custom),
    "customAsync": (()=>customAsync),
    "date": (()=>date),
    "decimal": (()=>decimal),
    "deleteGlobalConfig": (()=>deleteGlobalConfig),
    "deleteGlobalMessage": (()=>deleteGlobalMessage),
    "deleteSchemaMessage": (()=>deleteSchemaMessage),
    "deleteSpecificMessage": (()=>deleteSpecificMessage),
    "description": (()=>description),
    "digits": (()=>digits),
    "email": (()=>email),
    "emoji": (()=>emoji),
    "empty": (()=>empty),
    "endsWith": (()=>endsWith),
    "entriesFromList": (()=>entriesFromList),
    "entriesFromObjects": (()=>entriesFromObjects),
    "enum": (()=>enum_),
    "enum_": (()=>enum_),
    "everyItem": (()=>everyItem),
    "exactOptional": (()=>exactOptional),
    "exactOptionalAsync": (()=>exactOptionalAsync),
    "excludes": (()=>excludes),
    "fallback": (()=>fallback),
    "fallbackAsync": (()=>fallbackAsync),
    "file": (()=>file),
    "filterItems": (()=>filterItems),
    "findItem": (()=>findItem),
    "finite": (()=>finite),
    "flatten": (()=>flatten),
    "forward": (()=>forward),
    "forwardAsync": (()=>forwardAsync),
    "function": (()=>function_),
    "function_": (()=>function_),
    "getDefault": (()=>getDefault),
    "getDefaults": (()=>getDefaults),
    "getDefaultsAsync": (()=>getDefaultsAsync),
    "getDotPath": (()=>getDotPath),
    "getFallback": (()=>getFallback),
    "getFallbacks": (()=>getFallbacks),
    "getFallbacksAsync": (()=>getFallbacksAsync),
    "getGlobalConfig": (()=>getGlobalConfig),
    "getGlobalMessage": (()=>getGlobalMessage),
    "getSchemaMessage": (()=>getSchemaMessage),
    "getSpecificMessage": (()=>getSpecificMessage),
    "graphemes": (()=>graphemes),
    "gtValue": (()=>gtValue),
    "hash": (()=>hash),
    "hexColor": (()=>hexColor),
    "hexadecimal": (()=>hexadecimal),
    "imei": (()=>imei),
    "includes": (()=>includes),
    "instance": (()=>instance),
    "integer": (()=>integer),
    "intersect": (()=>intersect),
    "intersectAsync": (()=>intersectAsync),
    "ip": (()=>ip),
    "ipv4": (()=>ipv4),
    "ipv6": (()=>ipv6),
    "is": (()=>is),
    "isOfKind": (()=>isOfKind),
    "isOfType": (()=>isOfType),
    "isValiError": (()=>isValiError),
    "isoDate": (()=>isoDate),
    "isoDateTime": (()=>isoDateTime),
    "isoTime": (()=>isoTime),
    "isoTimeSecond": (()=>isoTimeSecond),
    "isoTimestamp": (()=>isoTimestamp),
    "isoWeek": (()=>isoWeek),
    "keyof": (()=>keyof),
    "lazy": (()=>lazy),
    "lazyAsync": (()=>lazyAsync),
    "length": (()=>length),
    "literal": (()=>literal),
    "looseObject": (()=>looseObject),
    "looseObjectAsync": (()=>looseObjectAsync),
    "looseTuple": (()=>looseTuple),
    "looseTupleAsync": (()=>looseTupleAsync),
    "ltValue": (()=>ltValue),
    "mac": (()=>mac),
    "mac48": (()=>mac48),
    "mac64": (()=>mac64),
    "map": (()=>map),
    "mapAsync": (()=>mapAsync),
    "mapItems": (()=>mapItems),
    "maxBytes": (()=>maxBytes),
    "maxGraphemes": (()=>maxGraphemes),
    "maxLength": (()=>maxLength),
    "maxSize": (()=>maxSize),
    "maxValue": (()=>maxValue),
    "maxWords": (()=>maxWords),
    "metadata": (()=>metadata),
    "mimeType": (()=>mimeType),
    "minBytes": (()=>minBytes),
    "minGraphemes": (()=>minGraphemes),
    "minLength": (()=>minLength),
    "minSize": (()=>minSize),
    "minValue": (()=>minValue),
    "minWords": (()=>minWords),
    "multipleOf": (()=>multipleOf),
    "nan": (()=>nan),
    "nanoid": (()=>nanoid),
    "never": (()=>never),
    "nonEmpty": (()=>nonEmpty),
    "nonNullable": (()=>nonNullable),
    "nonNullableAsync": (()=>nonNullableAsync),
    "nonNullish": (()=>nonNullish),
    "nonNullishAsync": (()=>nonNullishAsync),
    "nonOptional": (()=>nonOptional),
    "nonOptionalAsync": (()=>nonOptionalAsync),
    "normalize": (()=>normalize),
    "notBytes": (()=>notBytes),
    "notGraphemes": (()=>notGraphemes),
    "notLength": (()=>notLength),
    "notSize": (()=>notSize),
    "notValue": (()=>notValue),
    "notValues": (()=>notValues),
    "notWords": (()=>notWords),
    "null": (()=>null_),
    "null_": (()=>null_),
    "nullable": (()=>nullable),
    "nullableAsync": (()=>nullableAsync),
    "nullish": (()=>nullish),
    "nullishAsync": (()=>nullishAsync),
    "number": (()=>number),
    "object": (()=>object),
    "objectAsync": (()=>objectAsync),
    "objectWithRest": (()=>objectWithRest),
    "objectWithRestAsync": (()=>objectWithRestAsync),
    "octal": (()=>octal),
    "omit": (()=>omit),
    "optional": (()=>optional),
    "optionalAsync": (()=>optionalAsync),
    "parse": (()=>parse),
    "parseAsync": (()=>parseAsync),
    "parser": (()=>parser),
    "parserAsync": (()=>parserAsync),
    "partial": (()=>partial),
    "partialAsync": (()=>partialAsync),
    "partialCheck": (()=>partialCheck),
    "partialCheckAsync": (()=>partialCheckAsync),
    "pick": (()=>pick),
    "picklist": (()=>picklist),
    "pipe": (()=>pipe),
    "pipeAsync": (()=>pipeAsync),
    "promise": (()=>promise),
    "rawCheck": (()=>rawCheck),
    "rawCheckAsync": (()=>rawCheckAsync),
    "rawTransform": (()=>rawTransform),
    "rawTransformAsync": (()=>rawTransformAsync),
    "readonly": (()=>readonly),
    "record": (()=>record),
    "recordAsync": (()=>recordAsync),
    "reduceItems": (()=>reduceItems),
    "regex": (()=>regex),
    "required": (()=>required),
    "requiredAsync": (()=>requiredAsync),
    "returns": (()=>returns),
    "returnsAsync": (()=>returnsAsync),
    "rfcEmail": (()=>rfcEmail),
    "safeInteger": (()=>safeInteger),
    "safeParse": (()=>safeParse),
    "safeParseAsync": (()=>safeParseAsync),
    "safeParser": (()=>safeParser),
    "safeParserAsync": (()=>safeParserAsync),
    "set": (()=>set),
    "setAsync": (()=>setAsync),
    "setGlobalConfig": (()=>setGlobalConfig),
    "setGlobalMessage": (()=>setGlobalMessage),
    "setSchemaMessage": (()=>setSchemaMessage),
    "setSpecificMessage": (()=>setSpecificMessage),
    "size": (()=>size),
    "slug": (()=>slug),
    "someItem": (()=>someItem),
    "sortItems": (()=>sortItems),
    "startsWith": (()=>startsWith),
    "strictObject": (()=>strictObject),
    "strictObjectAsync": (()=>strictObjectAsync),
    "strictTuple": (()=>strictTuple),
    "strictTupleAsync": (()=>strictTupleAsync),
    "string": (()=>string),
    "symbol": (()=>symbol),
    "title": (()=>title),
    "toLowerCase": (()=>toLowerCase),
    "toMaxValue": (()=>toMaxValue),
    "toMinValue": (()=>toMinValue),
    "toUpperCase": (()=>toUpperCase),
    "transform": (()=>transform),
    "transformAsync": (()=>transformAsync),
    "trim": (()=>trim),
    "trimEnd": (()=>trimEnd),
    "trimStart": (()=>trimStart),
    "tuple": (()=>tuple),
    "tupleAsync": (()=>tupleAsync),
    "tupleWithRest": (()=>tupleWithRest),
    "tupleWithRestAsync": (()=>tupleWithRestAsync),
    "ulid": (()=>ulid),
    "undefined": (()=>undefined_),
    "undefined_": (()=>undefined_),
    "undefinedable": (()=>undefinedable),
    "undefinedableAsync": (()=>undefinedableAsync),
    "union": (()=>union),
    "unionAsync": (()=>unionAsync),
    "unknown": (()=>unknown),
    "unwrap": (()=>unwrap),
    "url": (()=>url),
    "uuid": (()=>uuid),
    "value": (()=>value),
    "values": (()=>values),
    "variant": (()=>variant),
    "variantAsync": (()=>variantAsync),
    "void": (()=>void_),
    "void_": (()=>void_),
    "words": (()=>words)
});
var store;
function setGlobalConfig(config2) {
    store = {
        ...store,
        ...config2
    };
}
// @__NO_SIDE_EFFECTS__
function getGlobalConfig(config2) {
    return {
        lang: config2?.lang ?? store?.lang,
        message: config2?.message,
        abortEarly: config2?.abortEarly ?? store?.abortEarly,
        abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly
    };
}
function deleteGlobalConfig() {
    store = void 0;
}
// src/storages/globalMessage/globalMessage.ts
var store2;
function setGlobalMessage(message, lang) {
    if (!store2) store2 = /* @__PURE__ */ new Map();
    store2.set(lang, message);
}
// @__NO_SIDE_EFFECTS__
function getGlobalMessage(lang) {
    return store2?.get(lang);
}
function deleteGlobalMessage(lang) {
    store2?.delete(lang);
}
// src/storages/schemaMessage/schemaMessage.ts
var store3;
function setSchemaMessage(message, lang) {
    if (!store3) store3 = /* @__PURE__ */ new Map();
    store3.set(lang, message);
}
// @__NO_SIDE_EFFECTS__
function getSchemaMessage(lang) {
    return store3?.get(lang);
}
function deleteSchemaMessage(lang) {
    store3?.delete(lang);
}
// src/storages/specificMessage/specificMessage.ts
var store4;
function setSpecificMessage(reference, message, lang) {
    if (!store4) store4 = /* @__PURE__ */ new Map();
    if (!store4.get(reference)) store4.set(reference, /* @__PURE__ */ new Map());
    store4.get(reference).set(lang, message);
}
// @__NO_SIDE_EFFECTS__
function getSpecificMessage(reference, lang) {
    return store4?.get(reference)?.get(lang);
}
function deleteSpecificMessage(reference, lang) {
    store4?.get(reference)?.delete(lang);
}
// src/utils/_stringify/_stringify.ts
// @__NO_SIDE_EFFECTS__
function _stringify(input) {
    const type = typeof input;
    if (type === "string") {
        return `"${input}"`;
    }
    if (type === "number" || type === "bigint" || type === "boolean") {
        return `${input}`;
    }
    if (type === "object" || type === "function") {
        return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? "null";
    }
    return type;
}
// src/utils/_addIssue/_addIssue.ts
function _addIssue(context, label, dataset, config2, other) {
    const input = other && "input" in other ? other.input : dataset.value;
    const expected = other?.expected ?? context.expects ?? null;
    const received = other?.received ?? _stringify(input);
    const issue = {
        kind: context.kind,
        type: context.type,
        input,
        expected,
        received,
        message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : "R"}eceived ${received}`,
        requirement: context.requirement,
        path: other?.path,
        issues: other?.issues,
        lang: config2.lang,
        abortEarly: config2.abortEarly,
        abortPipeEarly: config2.abortPipeEarly
    };
    const isSchema = context.kind === "schema";
    const message = other?.message ?? context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang);
    if (message !== void 0) {
        issue.message = typeof message === "function" ? // @ts-expect-error
        message(issue) : message;
    }
    if (isSchema) {
        dataset.typed = false;
    }
    if (dataset.issues) {
        dataset.issues.push(issue);
    } else {
        dataset.issues = [
            issue
        ];
    }
}
// src/utils/_getByteCount/_getByteCount.ts
var textEncoder;
// @__NO_SIDE_EFFECTS__
function _getByteCount(input) {
    if (!textEncoder) {
        textEncoder = new TextEncoder();
    }
    return textEncoder.encode(input).length;
}
// src/utils/_getGraphemeCount/_getGraphemeCount.ts
var segmenter;
// @__NO_SIDE_EFFECTS__
function _getGraphemeCount(input) {
    if (!segmenter) {
        segmenter = new Intl.Segmenter();
    }
    const segments = segmenter.segment(input);
    let count = 0;
    for (const _ of segments){
        count++;
    }
    return count;
}
// src/utils/_getStandardProps/_getStandardProps.ts
// @__NO_SIDE_EFFECTS__
function _getStandardProps(context) {
    return {
        version: 1,
        vendor: "valibot",
        validate (value2) {
            return context["~run"]({
                value: value2
            }, getGlobalConfig());
        }
    };
}
// src/utils/_getWordCount/_getWordCount.ts
var store5;
// @__NO_SIDE_EFFECTS__
function _getWordCount(locales, input) {
    if (!store5) {
        store5 = /* @__PURE__ */ new Map();
    }
    if (!store5.get(locales)) {
        store5.set(locales, new Intl.Segmenter(locales, {
            granularity: "word"
        }));
    }
    const segments = store5.get(locales).segment(input);
    let count = 0;
    for (const segment of segments){
        if (segment.isWordLike) {
            count++;
        }
    }
    return count;
}
// src/utils/_isLuhnAlgo/_isLuhnAlgo.ts
var NON_DIGIT_REGEX = /\D/gu;
// @__NO_SIDE_EFFECTS__
function _isLuhnAlgo(input) {
    const number2 = input.replace(NON_DIGIT_REGEX, "");
    let length2 = number2.length;
    let bit = 1;
    let sum = 0;
    while(length2){
        const value2 = +number2[--length2];
        bit ^= 1;
        sum += bit ? [
            0,
            2,
            4,
            6,
            8,
            1,
            3,
            5,
            7,
            9
        ][value2] : value2;
    }
    return sum % 10 === 0;
}
// src/utils/_isValidObjectKey/_isValidObjectKey.ts
// @__NO_SIDE_EFFECTS__
function _isValidObjectKey(object2, key) {
    return Object.hasOwn(object2, key) && key !== "__proto__" && key !== "prototype" && key !== "constructor";
}
// src/utils/_joinExpects/_joinExpects.ts
// @__NO_SIDE_EFFECTS__
function _joinExpects(values2, separator) {
    const list = [
        ...new Set(values2)
    ];
    if (list.length > 1) {
        return `(${list.join(` ${separator} `)})`;
    }
    return list[0] ?? "never";
}
// src/utils/entriesFromList/entriesFromList.ts
// @__NO_SIDE_EFFECTS__
function entriesFromList(list, schema) {
    const entries = {};
    for (const key of list){
        entries[key] = schema;
    }
    return entries;
}
// src/utils/entriesFromObjects/entriesFromObjects.ts
// @__NO_SIDE_EFFECTS__
function entriesFromObjects(schemas) {
    const entries = {};
    for (const schema of schemas){
        Object.assign(entries, schema.entries);
    }
    return entries;
}
// src/utils/getDotPath/getDotPath.ts
// @__NO_SIDE_EFFECTS__
function getDotPath(issue) {
    if (issue.path) {
        let key = "";
        for (const item of issue.path){
            if (typeof item.key === "string" || typeof item.key === "number") {
                if (key) {
                    key += `.${item.key}`;
                } else {
                    key += item.key;
                }
            } else {
                return null;
            }
        }
        return key;
    }
    return null;
}
// src/utils/isOfKind/isOfKind.ts
// @__NO_SIDE_EFFECTS__
function isOfKind(kind, object2) {
    return object2.kind === kind;
}
// src/utils/isOfType/isOfType.ts
// @__NO_SIDE_EFFECTS__
function isOfType(type, object2) {
    return object2.type === type;
}
// src/utils/isValiError/isValiError.ts
// @__NO_SIDE_EFFECTS__
function isValiError(error) {
    return error instanceof ValiError;
}
// src/utils/ValiError/ValiError.ts
var ValiError = class extends Error {
    /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */ constructor(issues){
        super(issues[0].message);
        this.name = "ValiError";
        this.issues = issues;
    }
};
// src/actions/args/args.ts
// @__NO_SIDE_EFFECTS__
function args(schema) {
    return {
        kind: "transformation",
        type: "args",
        reference: args,
        async: false,
        schema,
        "~run" (dataset, config2) {
            const func = dataset.value;
            dataset.value = (...args_)=>{
                const argsDataset = this.schema["~run"]({
                    value: args_
                }, config2);
                if (argsDataset.issues) {
                    throw new ValiError(argsDataset.issues);
                }
                return func(...argsDataset.value);
            };
            return dataset;
        }
    };
}
// src/actions/args/argsAsync.ts
// @__NO_SIDE_EFFECTS__
function argsAsync(schema) {
    return {
        kind: "transformation",
        type: "args",
        reference: argsAsync,
        async: false,
        schema,
        "~run" (dataset, config2) {
            const func = dataset.value;
            dataset.value = async (...args2)=>{
                const argsDataset = await schema["~run"]({
                    value: args2
                }, config2);
                if (argsDataset.issues) {
                    throw new ValiError(argsDataset.issues);
                }
                return func(...argsDataset.value);
            };
            return dataset;
        }
    };
}
// src/actions/await/awaitAsync.ts
// @__NO_SIDE_EFFECTS__
function awaitAsync() {
    return {
        kind: "transformation",
        type: "await",
        reference: awaitAsync,
        async: true,
        async "~run" (dataset) {
            dataset.value = await dataset.value;
            return dataset;
        }
    };
}
// src/regex.ts
var BASE64_REGEX = /^(?:[\da-z+/]{4})*(?:[\da-z+/]{2}==|[\da-z+/]{3}=)?$/iu;
var BIC_REGEX = /^[A-Z]{6}(?!00)[\dA-Z]{2}(?:[\dA-Z]{3})?$/u;
var CUID2_REGEX = /^[a-z][\da-z]*$/u;
var DECIMAL_REGEX = /^[+-]?(?:\d*\.)?\d+$/u;
var DIGITS_REGEX = /^\d+$/u;
var EMAIL_REGEX = /^[\w+-]+(?:\.[\w+-]+)*@[\da-z]+(?:[.-][\da-z]+)*\.[a-z]{2,}$/iu;
var EMOJI_REGEX = // eslint-disable-next-line redos-detector/no-unsafe-regex, regexp/no-dupe-disjunctions -- false positives
/^(?:[\u{1F1E6}-\u{1F1FF}]{2}|\u{1F3F4}[\u{E0061}-\u{E007A}]{2}[\u{E0030}-\u{E0039}\u{E0061}-\u{E007A}]{1,3}\u{E007F}|(?:\p{Emoji}\uFE0F\u20E3?|\p{Emoji_Modifier_Base}\p{Emoji_Modifier}?|\p{Emoji_Presentation})(?:\u200D(?:\p{Emoji}\uFE0F\u20E3?|\p{Emoji_Modifier_Base}\p{Emoji_Modifier}?|\p{Emoji_Presentation}))*)+$/u;
var HEXADECIMAL_REGEX = /^(?:0[hx])?[\da-fA-F]+$/u;
var HEX_COLOR_REGEX = /^#(?:[\da-fA-F]{3,4}|[\da-fA-F]{6}|[\da-fA-F]{8})$/u;
var IMEI_REGEX = /^\d{15}$|^\d{2}-\d{6}-\d{6}-\d$/u;
var IPV4_REGEX = // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive
/^(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])(?:\.(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])){3}$/u;
var IPV6_REGEX = /^(?:(?:[\da-f]{1,4}:){7}[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,7}:|(?:[\da-f]{1,4}:){1,6}:[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,5}(?::[\da-f]{1,4}){1,2}|(?:[\da-f]{1,4}:){1,4}(?::[\da-f]{1,4}){1,3}|(?:[\da-f]{1,4}:){1,3}(?::[\da-f]{1,4}){1,4}|(?:[\da-f]{1,4}:){1,2}(?::[\da-f]{1,4}){1,5}|[\da-f]{1,4}:(?::[\da-f]{1,4}){1,6}|:(?:(?::[\da-f]{1,4}){1,7}|:)|fe80:(?::[\da-f]{0,4}){0,4}%[\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d)|(?:[\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d))$/iu;
var IP_REGEX = /^(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])(?:\.(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])){3}$|^(?:(?:[\da-f]{1,4}:){7}[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,7}:|(?:[\da-f]{1,4}:){1,6}:[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,5}(?::[\da-f]{1,4}){1,2}|(?:[\da-f]{1,4}:){1,4}(?::[\da-f]{1,4}){1,3}|(?:[\da-f]{1,4}:){1,3}(?::[\da-f]{1,4}){1,4}|(?:[\da-f]{1,4}:){1,2}(?::[\da-f]{1,4}){1,5}|[\da-f]{1,4}:(?::[\da-f]{1,4}){1,6}|:(?:(?::[\da-f]{1,4}){1,7}|:)|fe80:(?::[\da-f]{0,4}){0,4}%[\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d)|(?:[\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d))$/iu;
var ISO_DATE_REGEX = /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])$/u;
var ISO_DATE_TIME_REGEX = /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])[T ](?:0\d|1\d|2[0-3]):[0-5]\d$/u;
var ISO_TIME_REGEX = /^(?:0\d|1\d|2[0-3]):[0-5]\d$/u;
var ISO_TIME_SECOND_REGEX = /^(?:0\d|1\d|2[0-3])(?::[0-5]\d){2}$/u;
var ISO_TIMESTAMP_REGEX = /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])[T ](?:0\d|1\d|2[0-3])(?::[0-5]\d){2}(?:\.\d{1,9})?(?:Z|[+-](?:0\d|1\d|2[0-3])(?::?[0-5]\d)?)$/u;
var ISO_WEEK_REGEX = /^\d{4}-W(?:0[1-9]|[1-4]\d|5[0-3])$/u;
var MAC48_REGEX = /^(?:[\da-f]{2}:){5}[\da-f]{2}$|^(?:[\da-f]{2}-){5}[\da-f]{2}$|^(?:[\da-f]{4}\.){2}[\da-f]{4}$/iu;
var MAC64_REGEX = /^(?:[\da-f]{2}:){7}[\da-f]{2}$|^(?:[\da-f]{2}-){7}[\da-f]{2}$|^(?:[\da-f]{4}\.){3}[\da-f]{4}$|^(?:[\da-f]{4}:){3}[\da-f]{4}$/iu;
var MAC_REGEX = /^(?:[\da-f]{2}:){5}[\da-f]{2}$|^(?:[\da-f]{2}-){5}[\da-f]{2}$|^(?:[\da-f]{4}\.){2}[\da-f]{4}$|^(?:[\da-f]{2}:){7}[\da-f]{2}$|^(?:[\da-f]{2}-){7}[\da-f]{2}$|^(?:[\da-f]{4}\.){3}[\da-f]{4}$|^(?:[\da-f]{4}:){3}[\da-f]{4}$/iu;
var NANO_ID_REGEX = /^[\w-]+$/u;
var OCTAL_REGEX = /^(?:0o)?[0-7]+$/u;
var RFC_EMAIL_REGEX = // eslint-disable-next-line regexp/prefer-w, no-useless-escape, regexp/no-useless-escape, regexp/require-unicode-regexp
/^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var SLUG_REGEX = /^[\da-z]+(?:[-_][\da-z]+)*$/u;
var ULID_REGEX = /^[\da-hjkmnp-tv-zA-HJKMNP-TV-Z]{26}$/u;
var UUID_REGEX = /^[\da-f]{8}(?:-[\da-f]{4}){3}-[\da-f]{12}$/iu;
// src/actions/base64/base64.ts
// @__NO_SIDE_EFFECTS__
function base64(message) {
    return {
        kind: "validation",
        type: "base64",
        reference: base64,
        async: false,
        expects: null,
        requirement: BASE64_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "Base64", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/bic/bic.ts
// @__NO_SIDE_EFFECTS__
function bic(message) {
    return {
        kind: "validation",
        type: "bic",
        reference: bic,
        async: false,
        expects: null,
        requirement: BIC_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "BIC", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/brand/brand.ts
// @__NO_SIDE_EFFECTS__
function brand(name) {
    return {
        kind: "transformation",
        type: "brand",
        reference: brand,
        async: false,
        name,
        "~run" (dataset) {
            return dataset;
        }
    };
}
// src/actions/bytes/bytes.ts
// @__NO_SIDE_EFFECTS__
function bytes(requirement, message) {
    return {
        kind: "validation",
        type: "bytes",
        reference: bytes,
        async: false,
        expects: `${requirement}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed) {
                const length2 = _getByteCount(dataset.value);
                if (length2 !== this.requirement) {
                    _addIssue(this, "bytes", dataset, config2, {
                        received: `${length2}`
                    });
                }
            }
            return dataset;
        }
    };
}
// src/actions/check/check.ts
// @__NO_SIDE_EFFECTS__
function check(requirement, message) {
    return {
        kind: "validation",
        type: "check",
        reference: check,
        async: false,
        expects: null,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement(dataset.value)) {
                _addIssue(this, "input", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/check/checkAsync.ts
// @__NO_SIDE_EFFECTS__
function checkAsync(requirement, message) {
    return {
        kind: "validation",
        type: "check",
        reference: checkAsync,
        async: true,
        expects: null,
        requirement,
        message,
        async "~run" (dataset, config2) {
            if (dataset.typed && !await this.requirement(dataset.value)) {
                _addIssue(this, "input", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/checkItems/checkItems.ts
// @__NO_SIDE_EFFECTS__
function checkItems(requirement, message) {
    return {
        kind: "validation",
        type: "check_items",
        reference: checkItems,
        async: false,
        expects: null,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed) {
                for(let index = 0; index < dataset.value.length; index++){
                    const item = dataset.value[index];
                    if (!this.requirement(item, index, dataset.value)) {
                        _addIssue(this, "item", dataset, config2, {
                            input: item,
                            path: [
                                {
                                    type: "array",
                                    origin: "value",
                                    input: dataset.value,
                                    key: index,
                                    value: item
                                }
                            ]
                        });
                    }
                }
            }
            return dataset;
        }
    };
}
// src/actions/checkItems/checkItemsAsync.ts
// @__NO_SIDE_EFFECTS__
function checkItemsAsync(requirement, message) {
    return {
        kind: "validation",
        type: "check_items",
        reference: checkItemsAsync,
        async: true,
        expects: null,
        requirement,
        message,
        async "~run" (dataset, config2) {
            if (dataset.typed) {
                const requirementResults = await Promise.all(dataset.value.map(this.requirement));
                for(let index = 0; index < dataset.value.length; index++){
                    if (!requirementResults[index]) {
                        const item = dataset.value[index];
                        _addIssue(this, "item", dataset, config2, {
                            input: item,
                            path: [
                                {
                                    type: "array",
                                    origin: "value",
                                    input: dataset.value,
                                    key: index,
                                    value: item
                                }
                            ]
                        });
                    }
                }
            }
            return dataset;
        }
    };
}
// src/actions/creditCard/creditCard.ts
var CREDIT_CARD_REGEX = /^(?:\d{14,19}|\d{4}(?: \d{3,6}){2,4}|\d{4}(?:-\d{3,6}){2,4})$/u;
var SANITIZE_REGEX = /[- ]/gu;
var PROVIDER_REGEX_LIST = [
    // American Express
    /^3[47]\d{13}$/u,
    // Diners Club
    /^3(?:0[0-5]|[68]\d)\d{11,13}$/u,
    // Discover
    /^6(?:011|5\d{2})\d{12,15}$/u,
    // JCB
    /^(?:2131|1800|35\d{3})\d{11}$/u,
    // Mastercard
    // eslint-disable-next-line redos-detector/no-unsafe-regex
    /^5[1-5]\d{2}|(?:222\d|22[3-9]\d|2[3-6]\d{2}|27[01]\d|2720)\d{12}$/u,
    // UnionPay
    /^(?:6[27]\d{14,17}|81\d{14,17})$/u,
    // Visa
    /^4\d{12}(?:\d{3,6})?$/u
];
// @__NO_SIDE_EFFECTS__
function creditCard(message) {
    return {
        kind: "validation",
        type: "credit_card",
        reference: creditCard,
        async: false,
        expects: null,
        requirement (input) {
            let sanitized;
            return CREDIT_CARD_REGEX.test(input) && // Remove any hyphens and blanks
            (sanitized = input.replace(SANITIZE_REGEX, "")) && // Check if it matches a provider
            PROVIDER_REGEX_LIST.some((regex2)=>regex2.test(sanitized)) && // Check if passes luhn algorithm
            _isLuhnAlgo(sanitized);
        },
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement(dataset.value)) {
                _addIssue(this, "credit card", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/cuid2/cuid2.ts
// @__NO_SIDE_EFFECTS__
function cuid2(message) {
    return {
        kind: "validation",
        type: "cuid2",
        reference: cuid2,
        async: false,
        expects: null,
        requirement: CUID2_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "Cuid2", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/decimal/decimal.ts
// @__NO_SIDE_EFFECTS__
function decimal(message) {
    return {
        kind: "validation",
        type: "decimal",
        reference: decimal,
        async: false,
        expects: null,
        requirement: DECIMAL_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "decimal", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/description/description.ts
// @__NO_SIDE_EFFECTS__
function description(description_) {
    return {
        kind: "metadata",
        type: "description",
        reference: description,
        description: description_
    };
}
// src/actions/digits/digits.ts
// @__NO_SIDE_EFFECTS__
function digits(message) {
    return {
        kind: "validation",
        type: "digits",
        reference: digits,
        async: false,
        expects: null,
        requirement: DIGITS_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "digits", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/email/email.ts
// @__NO_SIDE_EFFECTS__
function email(message) {
    return {
        kind: "validation",
        type: "email",
        reference: email,
        expects: null,
        async: false,
        requirement: EMAIL_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "email", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/emoji/emoji.ts
// @__NO_SIDE_EFFECTS__
function emoji(message) {
    return {
        kind: "validation",
        type: "emoji",
        reference: emoji,
        async: false,
        expects: null,
        requirement: EMOJI_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "emoji", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/empty/empty.ts
// @__NO_SIDE_EFFECTS__
function empty(message) {
    return {
        kind: "validation",
        type: "empty",
        reference: empty,
        async: false,
        expects: "0",
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && dataset.value.length > 0) {
                _addIssue(this, "length", dataset, config2, {
                    received: `${dataset.value.length}`
                });
            }
            return dataset;
        }
    };
}
// src/actions/endsWith/endsWith.ts
// @__NO_SIDE_EFFECTS__
function endsWith(requirement, message) {
    return {
        kind: "validation",
        type: "ends_with",
        reference: endsWith,
        async: false,
        expects: `"${requirement}"`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !dataset.value.endsWith(this.requirement)) {
                _addIssue(this, "end", dataset, config2, {
                    received: `"${dataset.value.slice(-this.requirement.length)}"`
                });
            }
            return dataset;
        }
    };
}
// src/actions/everyItem/everyItem.ts
// @__NO_SIDE_EFFECTS__
function everyItem(requirement, message) {
    return {
        kind: "validation",
        type: "every_item",
        reference: everyItem,
        async: false,
        expects: null,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !dataset.value.every(this.requirement)) {
                _addIssue(this, "item", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/excludes/excludes.ts
// @__NO_SIDE_EFFECTS__
function excludes(requirement, message) {
    const received = _stringify(requirement);
    return {
        kind: "validation",
        type: "excludes",
        reference: excludes,
        async: false,
        expects: `!${received}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && dataset.value.includes(this.requirement)) {
                _addIssue(this, "content", dataset, config2, {
                    received
                });
            }
            return dataset;
        }
    };
}
// src/actions/filterItems/filterItems.ts
// @__NO_SIDE_EFFECTS__
function filterItems(operation) {
    return {
        kind: "transformation",
        type: "filter_items",
        reference: filterItems,
        async: false,
        operation,
        "~run" (dataset) {
            dataset.value = dataset.value.filter(this.operation);
            return dataset;
        }
    };
}
// src/actions/findItem/findItem.ts
// @__NO_SIDE_EFFECTS__
function findItem(operation) {
    return {
        kind: "transformation",
        type: "find_item",
        reference: findItem,
        async: false,
        operation,
        "~run" (dataset) {
            dataset.value = dataset.value.find(this.operation);
            return dataset;
        }
    };
}
// src/actions/finite/finite.ts
// @__NO_SIDE_EFFECTS__
function finite(message) {
    return {
        kind: "validation",
        type: "finite",
        reference: finite,
        async: false,
        expects: null,
        requirement: Number.isFinite,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement(dataset.value)) {
                _addIssue(this, "finite", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/graphemes/graphemes.ts
// @__NO_SIDE_EFFECTS__
function graphemes(requirement, message) {
    return {
        kind: "validation",
        type: "graphemes",
        reference: graphemes,
        async: false,
        expects: `${requirement}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed) {
                const count = _getGraphemeCount(dataset.value);
                if (count !== this.requirement) {
                    _addIssue(this, "graphemes", dataset, config2, {
                        received: `${count}`
                    });
                }
            }
            return dataset;
        }
    };
}
// src/actions/gtValue/gtValue.ts
// @__NO_SIDE_EFFECTS__
function gtValue(requirement, message) {
    return {
        kind: "validation",
        type: "gt_value",
        reference: gtValue,
        async: false,
        expects: `>${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !(dataset.value > this.requirement)) {
                _addIssue(this, "value", dataset, config2, {
                    received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)
                });
            }
            return dataset;
        }
    };
}
// src/actions/hash/hash.ts
var HASH_LENGTHS = {
    md4: 32,
    md5: 32,
    sha1: 40,
    sha256: 64,
    sha384: 96,
    sha512: 128,
    ripemd128: 32,
    ripemd160: 40,
    tiger128: 32,
    tiger160: 40,
    tiger192: 48,
    crc32: 8,
    crc32b: 8,
    adler32: 8
};
// @__NO_SIDE_EFFECTS__
function hash(types, message) {
    return {
        kind: "validation",
        type: "hash",
        reference: hash,
        expects: null,
        async: false,
        requirement: RegExp(types.map((type)=>`^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join("|"), "iu"),
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "hash", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/hexadecimal/hexadecimal.ts
// @__NO_SIDE_EFFECTS__
function hexadecimal(message) {
    return {
        kind: "validation",
        type: "hexadecimal",
        reference: hexadecimal,
        async: false,
        expects: null,
        requirement: HEXADECIMAL_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "hexadecimal", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/hexColor/hexColor.ts
// @__NO_SIDE_EFFECTS__
function hexColor(message) {
    return {
        kind: "validation",
        type: "hex_color",
        reference: hexColor,
        async: false,
        expects: null,
        requirement: HEX_COLOR_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "hex color", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/imei/imei.ts
// @__NO_SIDE_EFFECTS__
function imei(message) {
    return {
        kind: "validation",
        type: "imei",
        reference: imei,
        async: false,
        expects: null,
        requirement (input) {
            return IMEI_REGEX.test(input) && _isLuhnAlgo(input);
        },
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement(dataset.value)) {
                _addIssue(this, "IMEI", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/includes/includes.ts
// @__NO_SIDE_EFFECTS__
function includes(requirement, message) {
    const expects = _stringify(requirement);
    return {
        kind: "validation",
        type: "includes",
        reference: includes,
        async: false,
        expects,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !dataset.value.includes(this.requirement)) {
                _addIssue(this, "content", dataset, config2, {
                    received: `!${expects}`
                });
            }
            return dataset;
        }
    };
}
// src/actions/integer/integer.ts
// @__NO_SIDE_EFFECTS__
function integer(message) {
    return {
        kind: "validation",
        type: "integer",
        reference: integer,
        async: false,
        expects: null,
        requirement: Number.isInteger,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement(dataset.value)) {
                _addIssue(this, "integer", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/ip/ip.ts
// @__NO_SIDE_EFFECTS__
function ip(message) {
    return {
        kind: "validation",
        type: "ip",
        reference: ip,
        async: false,
        expects: null,
        requirement: IP_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "IP", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/ipv4/ipv4.ts
// @__NO_SIDE_EFFECTS__
function ipv4(message) {
    return {
        kind: "validation",
        type: "ipv4",
        reference: ipv4,
        async: false,
        expects: null,
        requirement: IPV4_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "IPv4", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/ipv6/ipv6.ts
// @__NO_SIDE_EFFECTS__
function ipv6(message) {
    return {
        kind: "validation",
        type: "ipv6",
        reference: ipv6,
        async: false,
        expects: null,
        requirement: IPV6_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "IPv6", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/isoDate/isoDate.ts
// @__NO_SIDE_EFFECTS__
function isoDate(message) {
    return {
        kind: "validation",
        type: "iso_date",
        reference: isoDate,
        async: false,
        expects: null,
        requirement: ISO_DATE_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "date", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/isoDateTime/isoDateTime.ts
// @__NO_SIDE_EFFECTS__
function isoDateTime(message) {
    return {
        kind: "validation",
        type: "iso_date_time",
        reference: isoDateTime,
        async: false,
        expects: null,
        requirement: ISO_DATE_TIME_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "date-time", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/isoTime/isoTime.ts
// @__NO_SIDE_EFFECTS__
function isoTime(message) {
    return {
        kind: "validation",
        type: "iso_time",
        reference: isoTime,
        async: false,
        expects: null,
        requirement: ISO_TIME_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "time", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/isoTimeSecond/isoTimeSecond.ts
// @__NO_SIDE_EFFECTS__
function isoTimeSecond(message) {
    return {
        kind: "validation",
        type: "iso_time_second",
        reference: isoTimeSecond,
        async: false,
        expects: null,
        requirement: ISO_TIME_SECOND_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "time-second", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/isoTimestamp/isoTimestamp.ts
// @__NO_SIDE_EFFECTS__
function isoTimestamp(message) {
    return {
        kind: "validation",
        type: "iso_timestamp",
        reference: isoTimestamp,
        async: false,
        expects: null,
        requirement: ISO_TIMESTAMP_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "timestamp", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/isoWeek/isoWeek.ts
// @__NO_SIDE_EFFECTS__
function isoWeek(message) {
    return {
        kind: "validation",
        type: "iso_week",
        reference: isoWeek,
        async: false,
        expects: null,
        requirement: ISO_WEEK_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "week", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/length/length.ts
// @__NO_SIDE_EFFECTS__
function length(requirement, message) {
    return {
        kind: "validation",
        type: "length",
        reference: length,
        async: false,
        expects: `${requirement}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && dataset.value.length !== this.requirement) {
                _addIssue(this, "length", dataset, config2, {
                    received: `${dataset.value.length}`
                });
            }
            return dataset;
        }
    };
}
// src/actions/ltValue/ltValue.ts
// @__NO_SIDE_EFFECTS__
function ltValue(requirement, message) {
    return {
        kind: "validation",
        type: "lt_value",
        reference: ltValue,
        async: false,
        expects: `<${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !(dataset.value < this.requirement)) {
                _addIssue(this, "value", dataset, config2, {
                    received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)
                });
            }
            return dataset;
        }
    };
}
// src/actions/mac/mac.ts
// @__NO_SIDE_EFFECTS__
function mac(message) {
    return {
        kind: "validation",
        type: "mac",
        reference: mac,
        async: false,
        expects: null,
        requirement: MAC_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "MAC", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/mac48/mac48.ts
// @__NO_SIDE_EFFECTS__
function mac48(message) {
    return {
        kind: "validation",
        type: "mac48",
        reference: mac48,
        async: false,
        expects: null,
        requirement: MAC48_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "48-bit MAC", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/mac64/mac64.ts
// @__NO_SIDE_EFFECTS__
function mac64(message) {
    return {
        kind: "validation",
        type: "mac64",
        reference: mac64,
        async: false,
        expects: null,
        requirement: MAC64_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "64-bit MAC", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/mapItems/mapItems.ts
// @__NO_SIDE_EFFECTS__
function mapItems(operation) {
    return {
        kind: "transformation",
        type: "map_items",
        reference: mapItems,
        async: false,
        operation,
        "~run" (dataset) {
            dataset.value = dataset.value.map(this.operation);
            return dataset;
        }
    };
}
// src/actions/maxBytes/maxBytes.ts
// @__NO_SIDE_EFFECTS__
function maxBytes(requirement, message) {
    return {
        kind: "validation",
        type: "max_bytes",
        reference: maxBytes,
        async: false,
        expects: `<=${requirement}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed) {
                const length2 = _getByteCount(dataset.value);
                if (length2 > this.requirement) {
                    _addIssue(this, "bytes", dataset, config2, {
                        received: `${length2}`
                    });
                }
            }
            return dataset;
        }
    };
}
// src/actions/maxGraphemes/maxGraphemes.ts
// @__NO_SIDE_EFFECTS__
function maxGraphemes(requirement, message) {
    return {
        kind: "validation",
        type: "max_graphemes",
        reference: maxGraphemes,
        async: false,
        expects: `<=${requirement}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed) {
                const count = _getGraphemeCount(dataset.value);
                if (count > this.requirement) {
                    _addIssue(this, "graphemes", dataset, config2, {
                        received: `${count}`
                    });
                }
            }
            return dataset;
        }
    };
}
// src/actions/maxLength/maxLength.ts
// @__NO_SIDE_EFFECTS__
function maxLength(requirement, message) {
    return {
        kind: "validation",
        type: "max_length",
        reference: maxLength,
        async: false,
        expects: `<=${requirement}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && dataset.value.length > this.requirement) {
                _addIssue(this, "length", dataset, config2, {
                    received: `${dataset.value.length}`
                });
            }
            return dataset;
        }
    };
}
// src/actions/maxSize/maxSize.ts
// @__NO_SIDE_EFFECTS__
function maxSize(requirement, message) {
    return {
        kind: "validation",
        type: "max_size",
        reference: maxSize,
        async: false,
        expects: `<=${requirement}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && dataset.value.size > this.requirement) {
                _addIssue(this, "size", dataset, config2, {
                    received: `${dataset.value.size}`
                });
            }
            return dataset;
        }
    };
}
// src/actions/maxValue/maxValue.ts
// @__NO_SIDE_EFFECTS__
function maxValue(requirement, message) {
    return {
        kind: "validation",
        type: "max_value",
        reference: maxValue,
        async: false,
        expects: `<=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !(dataset.value <= this.requirement)) {
                _addIssue(this, "value", dataset, config2, {
                    received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)
                });
            }
            return dataset;
        }
    };
}
// src/actions/maxWords/maxWords.ts
// @__NO_SIDE_EFFECTS__
function maxWords(locales, requirement, message) {
    return {
        kind: "validation",
        type: "max_words",
        reference: maxWords,
        async: false,
        expects: `<=${requirement}`,
        locales,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed) {
                const count = _getWordCount(this.locales, dataset.value);
                if (count > this.requirement) {
                    _addIssue(this, "words", dataset, config2, {
                        received: `${count}`
                    });
                }
            }
            return dataset;
        }
    };
}
// src/actions/metadata/metadata.ts
// @__NO_SIDE_EFFECTS__
function metadata(metadata_) {
    return {
        kind: "metadata",
        type: "metadata",
        reference: metadata,
        metadata: metadata_
    };
}
// src/actions/mimeType/mimeType.ts
// @__NO_SIDE_EFFECTS__
function mimeType(requirement, message) {
    return {
        kind: "validation",
        type: "mime_type",
        reference: mimeType,
        async: false,
        expects: _joinExpects(requirement.map((option)=>`"${option}"`), "|"),
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.includes(dataset.value.type)) {
                _addIssue(this, "MIME type", dataset, config2, {
                    received: `"${dataset.value.type}"`
                });
            }
            return dataset;
        }
    };
}
// src/actions/minBytes/minBytes.ts
// @__NO_SIDE_EFFECTS__
function minBytes(requirement, message) {
    return {
        kind: "validation",
        type: "min_bytes",
        reference: minBytes,
        async: false,
        expects: `>=${requirement}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed) {
                const length2 = _getByteCount(dataset.value);
                if (length2 < this.requirement) {
                    _addIssue(this, "bytes", dataset, config2, {
                        received: `${length2}`
                    });
                }
            }
            return dataset;
        }
    };
}
// src/actions/minGraphemes/minGraphemes.ts
// @__NO_SIDE_EFFECTS__
function minGraphemes(requirement, message) {
    return {
        kind: "validation",
        type: "min_graphemes",
        reference: minGraphemes,
        async: false,
        expects: `>=${requirement}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed) {
                const count = _getGraphemeCount(dataset.value);
                if (count < this.requirement) {
                    _addIssue(this, "graphemes", dataset, config2, {
                        received: `${count}`
                    });
                }
            }
            return dataset;
        }
    };
}
// src/actions/minLength/minLength.ts
// @__NO_SIDE_EFFECTS__
function minLength(requirement, message) {
    return {
        kind: "validation",
        type: "min_length",
        reference: minLength,
        async: false,
        expects: `>=${requirement}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && dataset.value.length < this.requirement) {
                _addIssue(this, "length", dataset, config2, {
                    received: `${dataset.value.length}`
                });
            }
            return dataset;
        }
    };
}
// src/actions/minSize/minSize.ts
// @__NO_SIDE_EFFECTS__
function minSize(requirement, message) {
    return {
        kind: "validation",
        type: "min_size",
        reference: minSize,
        async: false,
        expects: `>=${requirement}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && dataset.value.size < this.requirement) {
                _addIssue(this, "size", dataset, config2, {
                    received: `${dataset.value.size}`
                });
            }
            return dataset;
        }
    };
}
// src/actions/minValue/minValue.ts
// @__NO_SIDE_EFFECTS__
function minValue(requirement, message) {
    return {
        kind: "validation",
        type: "min_value",
        reference: minValue,
        async: false,
        expects: `>=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !(dataset.value >= this.requirement)) {
                _addIssue(this, "value", dataset, config2, {
                    received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)
                });
            }
            return dataset;
        }
    };
}
// src/actions/minWords/minWords.ts
// @__NO_SIDE_EFFECTS__
function minWords(locales, requirement, message) {
    return {
        kind: "validation",
        type: "min_words",
        reference: minWords,
        async: false,
        expects: `>=${requirement}`,
        locales,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed) {
                const count = _getWordCount(this.locales, dataset.value);
                if (count < this.requirement) {
                    _addIssue(this, "words", dataset, config2, {
                        received: `${count}`
                    });
                }
            }
            return dataset;
        }
    };
}
// src/actions/multipleOf/multipleOf.ts
// @__NO_SIDE_EFFECTS__
function multipleOf(requirement, message) {
    return {
        kind: "validation",
        type: "multiple_of",
        reference: multipleOf,
        async: false,
        expects: `%${requirement}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && dataset.value % this.requirement !== 0) {
                _addIssue(this, "multiple", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/nanoid/nanoid.ts
// @__NO_SIDE_EFFECTS__
function nanoid(message) {
    return {
        kind: "validation",
        type: "nanoid",
        reference: nanoid,
        async: false,
        expects: null,
        requirement: NANO_ID_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "Nano ID", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/nonEmpty/nonEmpty.ts
// @__NO_SIDE_EFFECTS__
function nonEmpty(message) {
    return {
        kind: "validation",
        type: "non_empty",
        reference: nonEmpty,
        async: false,
        expects: "!0",
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && dataset.value.length === 0) {
                _addIssue(this, "length", dataset, config2, {
                    received: "0"
                });
            }
            return dataset;
        }
    };
}
// src/actions/normalize/normalize.ts
// @__NO_SIDE_EFFECTS__
function normalize(form) {
    return {
        kind: "transformation",
        type: "normalize",
        reference: normalize,
        async: false,
        form,
        "~run" (dataset) {
            dataset.value = dataset.value.normalize(this.form);
            return dataset;
        }
    };
}
// src/actions/notBytes/notBytes.ts
// @__NO_SIDE_EFFECTS__
function notBytes(requirement, message) {
    return {
        kind: "validation",
        type: "not_bytes",
        reference: notBytes,
        async: false,
        expects: `!${requirement}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed) {
                const length2 = _getByteCount(dataset.value);
                if (length2 === this.requirement) {
                    _addIssue(this, "bytes", dataset, config2, {
                        received: `${length2}`
                    });
                }
            }
            return dataset;
        }
    };
}
// src/actions/notGraphemes/notGraphemes.ts
// @__NO_SIDE_EFFECTS__
function notGraphemes(requirement, message) {
    return {
        kind: "validation",
        type: "not_graphemes",
        reference: notGraphemes,
        async: false,
        expects: `!${requirement}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed) {
                const count = _getGraphemeCount(dataset.value);
                if (count === this.requirement) {
                    _addIssue(this, "graphemes", dataset, config2, {
                        received: `${count}`
                    });
                }
            }
            return dataset;
        }
    };
}
// src/actions/notLength/notLength.ts
// @__NO_SIDE_EFFECTS__
function notLength(requirement, message) {
    return {
        kind: "validation",
        type: "not_length",
        reference: notLength,
        async: false,
        expects: `!${requirement}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && dataset.value.length === this.requirement) {
                _addIssue(this, "length", dataset, config2, {
                    received: `${dataset.value.length}`
                });
            }
            return dataset;
        }
    };
}
// src/actions/notSize/notSize.ts
// @__NO_SIDE_EFFECTS__
function notSize(requirement, message) {
    return {
        kind: "validation",
        type: "not_size",
        reference: notSize,
        async: false,
        expects: `!${requirement}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && dataset.value.size === this.requirement) {
                _addIssue(this, "size", dataset, config2, {
                    received: `${dataset.value.size}`
                });
            }
            return dataset;
        }
    };
}
// src/actions/notValue/notValue.ts
// @__NO_SIDE_EFFECTS__
function notValue(requirement, message) {
    return {
        kind: "validation",
        type: "not_value",
        reference: notValue,
        async: false,
        expects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${_stringify(requirement)}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) {
                _addIssue(this, "value", dataset, config2, {
                    received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)
                });
            }
            return dataset;
        }
    };
}
// src/actions/notValues/notValues.ts
// @__NO_SIDE_EFFECTS__
function notValues(requirement, message) {
    return {
        kind: "validation",
        type: "not_values",
        reference: notValues,
        async: false,
        expects: `!${_joinExpects(requirement.map((value2)=>value2 instanceof Date ? value2.toJSON() : _stringify(value2)), "|")}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && this.requirement.some((value2)=>value2 <= dataset.value && value2 >= dataset.value)) {
                _addIssue(this, "value", dataset, config2, {
                    received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)
                });
            }
            return dataset;
        }
    };
}
// src/actions/notWords/notWords.ts
// @__NO_SIDE_EFFECTS__
function notWords(locales, requirement, message) {
    return {
        kind: "validation",
        type: "not_words",
        reference: notWords,
        async: false,
        expects: `!${requirement}`,
        locales,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed) {
                const count = _getWordCount(this.locales, dataset.value);
                if (count === this.requirement) {
                    _addIssue(this, "words", dataset, config2, {
                        received: `${count}`
                    });
                }
            }
            return dataset;
        }
    };
}
// src/actions/octal/octal.ts
// @__NO_SIDE_EFFECTS__
function octal(message) {
    return {
        kind: "validation",
        type: "octal",
        reference: octal,
        async: false,
        expects: null,
        requirement: OCTAL_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "octal", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/partialCheck/utils/_isPartiallyTyped/_isPartiallyTyped.ts
// @__NO_SIDE_EFFECTS__
function _isPartiallyTyped(dataset, paths) {
    if (dataset.issues) {
        for (const path of paths){
            for (const issue of dataset.issues){
                let typed = false;
                const bound = Math.min(path.length, issue.path?.length ?? 0);
                for(let index = 0; index < bound; index++){
                    if (// @ts-expect-error
                    path[index] !== issue.path[index].key && // @ts-expect-error
                    (path[index] !== "$" || issue.path[index].type !== "array")) {
                        typed = true;
                        break;
                    }
                }
                if (!typed) {
                    return false;
                }
            }
        }
    }
    return true;
}
// src/actions/partialCheck/partialCheck.ts
// @__NO_SIDE_EFFECTS__
function partialCheck(paths, requirement, message) {
    return {
        kind: "validation",
        type: "partial_check",
        reference: partialCheck,
        async: false,
        expects: null,
        paths,
        requirement,
        message,
        "~run" (dataset, config2) {
            if ((dataset.typed || _isPartiallyTyped(dataset, paths)) && // @ts-expect-error
            !this.requirement(dataset.value)) {
                _addIssue(this, "input", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/partialCheck/partialCheckAsync.ts
// @__NO_SIDE_EFFECTS__
function partialCheckAsync(paths, requirement, message) {
    return {
        kind: "validation",
        type: "partial_check",
        reference: partialCheckAsync,
        async: true,
        expects: null,
        paths,
        requirement,
        message,
        async "~run" (dataset, config2) {
            if ((dataset.typed || _isPartiallyTyped(dataset, paths)) && // @ts-expect-error
            !await this.requirement(dataset.value)) {
                _addIssue(this, "input", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/rawCheck/rawCheck.ts
// @__NO_SIDE_EFFECTS__
function rawCheck(action) {
    return {
        kind: "validation",
        type: "raw_check",
        reference: rawCheck,
        async: false,
        expects: null,
        "~run" (dataset, config2) {
            action({
                dataset,
                config: config2,
                addIssue: (info)=>_addIssue(this, info?.label ?? "input", dataset, config2, info)
            });
            return dataset;
        }
    };
}
// src/actions/rawCheck/rawCheckAsync.ts
// @__NO_SIDE_EFFECTS__
function rawCheckAsync(action) {
    return {
        kind: "validation",
        type: "raw_check",
        reference: rawCheckAsync,
        async: true,
        expects: null,
        async "~run" (dataset, config2) {
            await action({
                dataset,
                config: config2,
                addIssue: (info)=>_addIssue(this, info?.label ?? "input", dataset, config2, info)
            });
            return dataset;
        }
    };
}
// src/actions/rawTransform/rawTransform.ts
// @__NO_SIDE_EFFECTS__
function rawTransform(action) {
    return {
        kind: "transformation",
        type: "raw_transform",
        reference: rawTransform,
        async: false,
        "~run" (dataset, config2) {
            const output = action({
                dataset,
                config: config2,
                addIssue: (info)=>_addIssue(this, info?.label ?? "input", dataset, config2, info),
                NEVER: null
            });
            if (dataset.issues) {
                dataset.typed = false;
            } else {
                dataset.value = output;
            }
            return dataset;
        }
    };
}
// src/actions/rawTransform/rawTransformAsync.ts
// @__NO_SIDE_EFFECTS__
function rawTransformAsync(action) {
    return {
        kind: "transformation",
        type: "raw_transform",
        reference: rawTransformAsync,
        async: true,
        async "~run" (dataset, config2) {
            const output = await action({
                dataset,
                config: config2,
                addIssue: (info)=>_addIssue(this, info?.label ?? "input", dataset, config2, info),
                NEVER: null
            });
            if (dataset.issues) {
                dataset.typed = false;
            } else {
                dataset.value = output;
            }
            return dataset;
        }
    };
}
// src/actions/readonly/readonly.ts
// @__NO_SIDE_EFFECTS__
function readonly() {
    return {
        kind: "transformation",
        type: "readonly",
        reference: readonly,
        async: false,
        "~run" (dataset) {
            return dataset;
        }
    };
}
// src/actions/reduceItems/reduceItems.ts
// @__NO_SIDE_EFFECTS__
function reduceItems(operation, initial) {
    return {
        kind: "transformation",
        type: "reduce_items",
        reference: reduceItems,
        async: false,
        operation,
        initial,
        "~run" (dataset) {
            dataset.value = dataset.value.reduce(this.operation, this.initial);
            return dataset;
        }
    };
}
// src/actions/regex/regex.ts
// @__NO_SIDE_EFFECTS__
function regex(requirement, message) {
    return {
        kind: "validation",
        type: "regex",
        reference: regex,
        async: false,
        expects: `${requirement}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "format", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/returns/returns.ts
// @__NO_SIDE_EFFECTS__
function returns(schema) {
    return {
        kind: "transformation",
        type: "returns",
        reference: returns,
        async: false,
        schema,
        "~run" (dataset, config2) {
            const func = dataset.value;
            dataset.value = (...args_)=>{
                const returnsDataset = this.schema["~run"]({
                    value: func(...args_)
                }, config2);
                if (returnsDataset.issues) {
                    throw new ValiError(returnsDataset.issues);
                }
                return returnsDataset.value;
            };
            return dataset;
        }
    };
}
// src/actions/returns/returnsAsync.ts
// @__NO_SIDE_EFFECTS__
function returnsAsync(schema) {
    return {
        kind: "transformation",
        type: "returns",
        reference: returnsAsync,
        async: false,
        schema,
        "~run" (dataset, config2) {
            const func = dataset.value;
            dataset.value = async (...args_)=>{
                const returnsDataset = await this.schema["~run"]({
                    value: await func(...args_)
                }, config2);
                if (returnsDataset.issues) {
                    throw new ValiError(returnsDataset.issues);
                }
                return returnsDataset.value;
            };
            return dataset;
        }
    };
}
// src/actions/rfcEmail/rfcEmail.ts
// @__NO_SIDE_EFFECTS__
function rfcEmail(message) {
    return {
        kind: "validation",
        type: "rfc_email",
        reference: rfcEmail,
        expects: null,
        async: false,
        requirement: RFC_EMAIL_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "email", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/safeInteger/safeInteger.ts
// @__NO_SIDE_EFFECTS__
function safeInteger(message) {
    return {
        kind: "validation",
        type: "safe_integer",
        reference: safeInteger,
        async: false,
        expects: null,
        requirement: Number.isSafeInteger,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement(dataset.value)) {
                _addIssue(this, "safe integer", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/size/size.ts
// @__NO_SIDE_EFFECTS__
function size(requirement, message) {
    return {
        kind: "validation",
        type: "size",
        reference: size,
        async: false,
        expects: `${requirement}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && dataset.value.size !== this.requirement) {
                _addIssue(this, "size", dataset, config2, {
                    received: `${dataset.value.size}`
                });
            }
            return dataset;
        }
    };
}
// src/actions/slug/slug.ts
// @__NO_SIDE_EFFECTS__
function slug(message) {
    return {
        kind: "validation",
        type: "slug",
        reference: slug,
        async: false,
        expects: null,
        requirement: SLUG_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "slug", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/someItem/someItem.ts
// @__NO_SIDE_EFFECTS__
function someItem(requirement, message) {
    return {
        kind: "validation",
        type: "some_item",
        reference: someItem,
        async: false,
        expects: null,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !dataset.value.some(this.requirement)) {
                _addIssue(this, "item", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/sortItems/sortItems.ts
// @__NO_SIDE_EFFECTS__
function sortItems(operation) {
    return {
        kind: "transformation",
        type: "sort_items",
        reference: sortItems,
        async: false,
        operation,
        "~run" (dataset) {
            dataset.value = dataset.value.sort(this.operation);
            return dataset;
        }
    };
}
// src/actions/startsWith/startsWith.ts
// @__NO_SIDE_EFFECTS__
function startsWith(requirement, message) {
    return {
        kind: "validation",
        type: "starts_with",
        reference: startsWith,
        async: false,
        expects: `"${requirement}"`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !dataset.value.startsWith(this.requirement)) {
                _addIssue(this, "start", dataset, config2, {
                    received: `"${dataset.value.slice(0, this.requirement.length)}"`
                });
            }
            return dataset;
        }
    };
}
// src/actions/title/title.ts
// @__NO_SIDE_EFFECTS__
function title(title_) {
    return {
        kind: "metadata",
        type: "title",
        reference: title,
        title: title_
    };
}
// src/actions/toLowerCase/toLowerCase.ts
// @__NO_SIDE_EFFECTS__
function toLowerCase() {
    return {
        kind: "transformation",
        type: "to_lower_case",
        reference: toLowerCase,
        async: false,
        "~run" (dataset) {
            dataset.value = dataset.value.toLowerCase();
            return dataset;
        }
    };
}
// src/actions/toMaxValue/toMaxValue.ts
// @__NO_SIDE_EFFECTS__
function toMaxValue(requirement) {
    return {
        kind: "transformation",
        type: "to_max_value",
        reference: toMaxValue,
        async: false,
        requirement,
        "~run" (dataset) {
            dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;
            return dataset;
        }
    };
}
// src/actions/toMinValue/toMinValue.ts
// @__NO_SIDE_EFFECTS__
function toMinValue(requirement) {
    return {
        kind: "transformation",
        type: "to_min_value",
        reference: toMinValue,
        async: false,
        requirement,
        "~run" (dataset) {
            dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;
            return dataset;
        }
    };
}
// src/actions/toUpperCase/toUpperCase.ts
// @__NO_SIDE_EFFECTS__
function toUpperCase() {
    return {
        kind: "transformation",
        type: "to_upper_case",
        reference: toUpperCase,
        async: false,
        "~run" (dataset) {
            dataset.value = dataset.value.toUpperCase();
            return dataset;
        }
    };
}
// src/actions/transform/transform.ts
// @__NO_SIDE_EFFECTS__
function transform(operation) {
    return {
        kind: "transformation",
        type: "transform",
        reference: transform,
        async: false,
        operation,
        "~run" (dataset) {
            dataset.value = this.operation(dataset.value);
            return dataset;
        }
    };
}
// src/actions/transform/transformAsync.ts
// @__NO_SIDE_EFFECTS__
function transformAsync(operation) {
    return {
        kind: "transformation",
        type: "transform",
        reference: transformAsync,
        async: true,
        operation,
        async "~run" (dataset) {
            dataset.value = await this.operation(dataset.value);
            return dataset;
        }
    };
}
// src/actions/trim/trim.ts
// @__NO_SIDE_EFFECTS__
function trim() {
    return {
        kind: "transformation",
        type: "trim",
        reference: trim,
        async: false,
        "~run" (dataset) {
            dataset.value = dataset.value.trim();
            return dataset;
        }
    };
}
// src/actions/trimEnd/trimEnd.ts
// @__NO_SIDE_EFFECTS__
function trimEnd() {
    return {
        kind: "transformation",
        type: "trim_end",
        reference: trimEnd,
        async: false,
        "~run" (dataset) {
            dataset.value = dataset.value.trimEnd();
            return dataset;
        }
    };
}
// src/actions/trimStart/trimStart.ts
// @__NO_SIDE_EFFECTS__
function trimStart() {
    return {
        kind: "transformation",
        type: "trim_start",
        reference: trimStart,
        async: false,
        "~run" (dataset) {
            dataset.value = dataset.value.trimStart();
            return dataset;
        }
    };
}
// src/actions/ulid/ulid.ts
// @__NO_SIDE_EFFECTS__
function ulid(message) {
    return {
        kind: "validation",
        type: "ulid",
        reference: ulid,
        async: false,
        expects: null,
        requirement: ULID_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "ULID", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/url/url.ts
// @__NO_SIDE_EFFECTS__
function url(message) {
    return {
        kind: "validation",
        type: "url",
        reference: url,
        async: false,
        expects: null,
        requirement (input) {
            try {
                new URL(input);
                return true;
            } catch  {
                return false;
            }
        },
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement(dataset.value)) {
                _addIssue(this, "URL", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/uuid/uuid.ts
// @__NO_SIDE_EFFECTS__
function uuid(message) {
    return {
        kind: "validation",
        type: "uuid",
        reference: uuid,
        async: false,
        expects: null,
        requirement: UUID_REGEX,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "UUID", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/value/value.ts
// @__NO_SIDE_EFFECTS__
function value(requirement, message) {
    return {
        kind: "validation",
        type: "value",
        reference: value,
        async: false,
        expects: requirement instanceof Date ? requirement.toJSON() : _stringify(requirement),
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) {
                _addIssue(this, "value", dataset, config2, {
                    received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)
                });
            }
            return dataset;
        }
    };
}
// src/actions/values/values.ts
// @__NO_SIDE_EFFECTS__
function values(requirement, message) {
    return {
        kind: "validation",
        type: "values",
        reference: values,
        async: false,
        expects: `${_joinExpects(requirement.map((value2)=>value2 instanceof Date ? value2.toJSON() : _stringify(value2)), "|")}`,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed && !this.requirement.some((value2)=>value2 <= dataset.value && value2 >= dataset.value)) {
                _addIssue(this, "value", dataset, config2, {
                    received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)
                });
            }
            return dataset;
        }
    };
}
// src/actions/words/words.ts
// @__NO_SIDE_EFFECTS__
function words(locales, requirement, message) {
    return {
        kind: "validation",
        type: "words",
        reference: words,
        async: false,
        expects: `${requirement}`,
        locales,
        requirement,
        message,
        "~run" (dataset, config2) {
            if (dataset.typed) {
                const count = _getWordCount(this.locales, dataset.value);
                if (count !== this.requirement) {
                    _addIssue(this, "words", dataset, config2, {
                        received: `${count}`
                    });
                }
            }
            return dataset;
        }
    };
}
// src/methods/assert/assert.ts
function assert(schema, input) {
    const issues = schema["~run"]({
        value: input
    }, {
        abortEarly: true
    }).issues;
    if (issues) {
        throw new ValiError(issues);
    }
}
// src/methods/config/config.ts
// @__NO_SIDE_EFFECTS__
function config(schema, config2) {
    return {
        ...schema,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config_) {
            return schema["~run"](dataset, {
                ...config_,
                ...config2
            });
        }
    };
}
// src/methods/getFallback/getFallback.ts
// @__NO_SIDE_EFFECTS__
function getFallback(schema, dataset, config2) {
    return typeof schema.fallback === "function" ? // @ts-expect-error
    schema.fallback(dataset, config2) : // @ts-expect-error
    schema.fallback;
}
// src/methods/fallback/fallback.ts
// @__NO_SIDE_EFFECTS__
function fallback(schema, fallback2) {
    return {
        ...schema,
        fallback: fallback2,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            const outputDataset = schema["~run"](dataset, config2);
            return outputDataset.issues ? {
                typed: true,
                value: getFallback(this, outputDataset, config2)
            } : outputDataset;
        }
    };
}
// src/methods/fallback/fallbackAsync.ts
// @__NO_SIDE_EFFECTS__
function fallbackAsync(schema, fallback2) {
    return {
        ...schema,
        fallback: fallback2,
        async: true,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            const outputDataset = await schema["~run"](dataset, config2);
            return outputDataset.issues ? {
                typed: true,
                value: await getFallback(this, outputDataset, config2)
            } : outputDataset;
        }
    };
}
// src/methods/flatten/flatten.ts
// @__NO_SIDE_EFFECTS__
function flatten(issues) {
    const flatErrors = {};
    for (const issue of issues){
        if (issue.path) {
            const dotPath = getDotPath(issue);
            if (dotPath) {
                if (!flatErrors.nested) {
                    flatErrors.nested = {};
                }
                if (flatErrors.nested[dotPath]) {
                    flatErrors.nested[dotPath].push(issue.message);
                } else {
                    flatErrors.nested[dotPath] = [
                        issue.message
                    ];
                }
            } else {
                if (flatErrors.other) {
                    flatErrors.other.push(issue.message);
                } else {
                    flatErrors.other = [
                        issue.message
                    ];
                }
            }
        } else {
            if (flatErrors.root) {
                flatErrors.root.push(issue.message);
            } else {
                flatErrors.root = [
                    issue.message
                ];
            }
        }
    }
    return flatErrors;
}
// src/methods/forward/forward.ts
// @__NO_SIDE_EFFECTS__
function forward(action, path) {
    return {
        ...action,
        "~run" (dataset, config2) {
            const prevIssues = dataset.issues && [
                ...dataset.issues
            ];
            dataset = action["~run"](dataset, config2);
            if (dataset.issues) {
                for (const issue of dataset.issues){
                    if (!prevIssues?.includes(issue)) {
                        let pathInput = dataset.value;
                        for (const key of path){
                            const pathValue = pathInput[key];
                            const pathItem = {
                                type: "unknown",
                                origin: "value",
                                input: pathInput,
                                key,
                                value: pathValue
                            };
                            if (issue.path) {
                                issue.path.push(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            if (!pathValue) {
                                break;
                            }
                            pathInput = pathValue;
                        }
                    }
                }
            }
            return dataset;
        }
    };
}
// src/methods/forward/forwardAsync.ts
// @__NO_SIDE_EFFECTS__
function forwardAsync(action, path) {
    return {
        ...action,
        async: true,
        async "~run" (dataset, config2) {
            const prevIssues = dataset.issues && [
                ...dataset.issues
            ];
            dataset = await action["~run"](dataset, config2);
            if (dataset.issues) {
                for (const issue of dataset.issues){
                    if (!prevIssues?.includes(issue)) {
                        let pathInput = dataset.value;
                        for (const key of path){
                            const pathValue = pathInput[key];
                            const pathItem = {
                                type: "unknown",
                                origin: "value",
                                input: pathInput,
                                key,
                                value: pathValue
                            };
                            if (issue.path) {
                                issue.path.push(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            if (!pathValue) {
                                break;
                            }
                            pathInput = pathValue;
                        }
                    }
                }
            }
            return dataset;
        }
    };
}
// src/methods/getDefault/getDefault.ts
// @__NO_SIDE_EFFECTS__
function getDefault(schema, dataset, config2) {
    return typeof schema.default === "function" ? // @ts-expect-error
    schema.default(dataset, config2) : // @ts-expect-error
    schema.default;
}
// src/methods/getDefaults/getDefaults.ts
// @__NO_SIDE_EFFECTS__
function getDefaults(schema) {
    if ("entries" in schema) {
        const object2 = {};
        for(const key in schema.entries){
            object2[key] = /* @__PURE__ */ getDefaults(schema.entries[key]);
        }
        return object2;
    }
    if ("items" in schema) {
        return schema.items.map(getDefaults);
    }
    return getDefault(schema);
}
// src/methods/getDefaults/getDefaultsAsync.ts
// @__NO_SIDE_EFFECTS__
async function getDefaultsAsync(schema) {
    if ("entries" in schema) {
        return Object.fromEntries(await Promise.all(Object.entries(schema.entries).map(async ([key, value2])=>[
                key,
                await /* @__PURE__ */ getDefaultsAsync(value2)
            ])));
    }
    if ("items" in schema) {
        return Promise.all(schema.items.map(getDefaultsAsync));
    }
    return getDefault(schema);
}
// src/methods/getFallbacks/getFallbacks.ts
// @__NO_SIDE_EFFECTS__
function getFallbacks(schema) {
    if ("entries" in schema) {
        const object2 = {};
        for(const key in schema.entries){
            object2[key] = /* @__PURE__ */ getFallbacks(schema.entries[key]);
        }
        return object2;
    }
    if ("items" in schema) {
        return schema.items.map(getFallbacks);
    }
    return getFallback(schema);
}
// src/methods/getFallbacks/getFallbacksAsync.ts
// @__NO_SIDE_EFFECTS__
async function getFallbacksAsync(schema) {
    if ("entries" in schema) {
        return Object.fromEntries(await Promise.all(Object.entries(schema.entries).map(async ([key, value2])=>[
                key,
                await /* @__PURE__ */ getFallbacksAsync(value2)
            ])));
    }
    if ("items" in schema) {
        return Promise.all(schema.items.map(getFallbacksAsync));
    }
    return getFallback(schema);
}
// src/methods/is/is.ts
// @__NO_SIDE_EFFECTS__
function is(schema, input) {
    return !schema["~run"]({
        value: input
    }, {
        abortEarly: true
    }).issues;
}
// src/schemas/any/any.ts
// @__NO_SIDE_EFFECTS__
function any() {
    return {
        kind: "schema",
        type: "any",
        reference: any,
        expects: "any",
        async: false,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset) {
            dataset.typed = true;
            return dataset;
        }
    };
}
// src/schemas/array/array.ts
// @__NO_SIDE_EFFECTS__
function array(item, message) {
    return {
        kind: "schema",
        type: "array",
        reference: array,
        expects: "Array",
        async: false,
        item,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                for(let key = 0; key < input.length; key++){
                    const value2 = input[key];
                    const itemDataset = this.item["~run"]({
                        value: value2
                    }, config2);
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "array",
                            origin: "value",
                            input,
                            key,
                            value: value2
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = itemDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.push(itemDataset.value);
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/array/arrayAsync.ts
// @__NO_SIDE_EFFECTS__
function arrayAsync(item, message) {
    return {
        kind: "schema",
        type: "array",
        reference: arrayAsync,
        expects: "Array",
        async: true,
        item,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                const itemDatasets = await Promise.all(input.map((value2)=>this.item["~run"]({
                        value: value2
                    }, config2)));
                for(let key = 0; key < itemDatasets.length; key++){
                    const itemDataset = itemDatasets[key];
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "array",
                            origin: "value",
                            input,
                            key,
                            value: input[key]
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = itemDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.push(itemDataset.value);
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/bigint/bigint.ts
// @__NO_SIDE_EFFECTS__
function bigint(message) {
    return {
        kind: "schema",
        type: "bigint",
        reference: bigint,
        expects: "bigint",
        async: false,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (typeof dataset.value === "bigint") {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/blob/blob.ts
// @__NO_SIDE_EFFECTS__
function blob(message) {
    return {
        kind: "schema",
        type: "blob",
        reference: blob,
        expects: "Blob",
        async: false,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (dataset.value instanceof Blob) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/boolean/boolean.ts
// @__NO_SIDE_EFFECTS__
function boolean(message) {
    return {
        kind: "schema",
        type: "boolean",
        reference: boolean,
        expects: "boolean",
        async: false,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (typeof dataset.value === "boolean") {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/custom/custom.ts
// @__NO_SIDE_EFFECTS__
function custom(check2, message) {
    return {
        kind: "schema",
        type: "custom",
        reference: custom,
        expects: "unknown",
        async: false,
        check: check2,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (this.check(dataset.value)) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/custom/customAsync.ts
// @__NO_SIDE_EFFECTS__
function customAsync(check2, message) {
    return {
        kind: "schema",
        type: "custom",
        reference: customAsync,
        expects: "unknown",
        async: true,
        check: check2,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            if (await this.check(dataset.value)) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/date/date.ts
// @__NO_SIDE_EFFECTS__
function date(message) {
    return {
        kind: "schema",
        type: "date",
        reference: date,
        expects: "Date",
        async: false,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (dataset.value instanceof Date) {
                if (!isNaN(dataset.value)) {
                    dataset.typed = true;
                } else {
                    _addIssue(this, "type", dataset, config2, {
                        received: '"Invalid Date"'
                    });
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/enum/enum.ts
// @__NO_SIDE_EFFECTS__
function enum_(enum__, message) {
    const options = [];
    for(const key in enum__){
        if (`${+key}` !== key || typeof enum__[key] !== "string" || !Object.is(enum__[enum__[key]], +key)) {
            options.push(enum__[key]);
        }
    }
    return {
        kind: "schema",
        type: "enum",
        reference: enum_,
        expects: _joinExpects(options.map(_stringify), "|"),
        async: false,
        enum: enum__,
        options,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (this.options.includes(dataset.value)) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/exactOptional/exactOptional.ts
// @__NO_SIDE_EFFECTS__
function exactOptional(wrapped, default_) {
    return {
        kind: "schema",
        type: "exact_optional",
        reference: exactOptional,
        expects: wrapped.expects,
        async: false,
        wrapped,
        default: default_,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            return this.wrapped["~run"](dataset, config2);
        }
    };
}
// src/schemas/exactOptional/exactOptionalAsync.ts
// @__NO_SIDE_EFFECTS__
function exactOptionalAsync(wrapped, default_) {
    return {
        kind: "schema",
        type: "exact_optional",
        reference: exactOptionalAsync,
        expects: wrapped.expects,
        async: true,
        wrapped,
        default: default_,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            return this.wrapped["~run"](dataset, config2);
        }
    };
}
// src/schemas/file/file.ts
// @__NO_SIDE_EFFECTS__
function file(message) {
    return {
        kind: "schema",
        type: "file",
        reference: file,
        expects: "File",
        async: false,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (dataset.value instanceof File) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/function/function.ts
// @__NO_SIDE_EFFECTS__
function function_(message) {
    return {
        kind: "schema",
        type: "function",
        reference: function_,
        expects: "Function",
        async: false,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (typeof dataset.value === "function") {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/instance/instance.ts
// @__NO_SIDE_EFFECTS__
function instance(class_, message) {
    return {
        kind: "schema",
        type: "instance",
        reference: instance,
        expects: class_.name,
        async: false,
        class: class_,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (dataset.value instanceof this.class) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/intersect/utils/_merge/_merge.ts
// @__NO_SIDE_EFFECTS__
function _merge(value1, value2) {
    if (typeof value1 === typeof value2) {
        if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) {
            return {
                value: value1
            };
        }
        if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {
            for(const key in value2){
                if (key in value1) {
                    const dataset = /* @__PURE__ */ _merge(value1[key], value2[key]);
                    if (dataset.issue) {
                        return dataset;
                    }
                    value1[key] = dataset.value;
                } else {
                    value1[key] = value2[key];
                }
            }
            return {
                value: value1
            };
        }
        if (Array.isArray(value1) && Array.isArray(value2)) {
            if (value1.length === value2.length) {
                for(let index = 0; index < value1.length; index++){
                    const dataset = /* @__PURE__ */ _merge(value1[index], value2[index]);
                    if (dataset.issue) {
                        return dataset;
                    }
                    value1[index] = dataset.value;
                }
                return {
                    value: value1
                };
            }
        }
    }
    return {
        issue: true
    };
}
// src/schemas/intersect/intersect.ts
// @__NO_SIDE_EFFECTS__
function intersect(options, message) {
    return {
        kind: "schema",
        type: "intersect",
        reference: intersect,
        expects: _joinExpects(options.map((option)=>option.expects), "&"),
        async: false,
        options,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (this.options.length) {
                const input = dataset.value;
                let outputs;
                dataset.typed = true;
                for (const schema of this.options){
                    const optionDataset = schema["~run"]({
                        value: input
                    }, config2);
                    if (optionDataset.issues) {
                        if (dataset.issues) {
                            dataset.issues.push(...optionDataset.issues);
                        } else {
                            dataset.issues = optionDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!optionDataset.typed) {
                        dataset.typed = false;
                    }
                    if (dataset.typed) {
                        if (outputs) {
                            outputs.push(optionDataset.value);
                        } else {
                            outputs = [
                                optionDataset.value
                            ];
                        }
                    }
                }
                if (dataset.typed) {
                    dataset.value = outputs[0];
                    for(let index = 1; index < outputs.length; index++){
                        const mergeDataset = _merge(dataset.value, outputs[index]);
                        if (mergeDataset.issue) {
                            _addIssue(this, "type", dataset, config2, {
                                received: "unknown"
                            });
                            break;
                        }
                        dataset.value = mergeDataset.value;
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/intersect/intersectAsync.ts
// @__NO_SIDE_EFFECTS__
function intersectAsync(options, message) {
    return {
        kind: "schema",
        type: "intersect",
        reference: intersectAsync,
        expects: _joinExpects(options.map((option)=>option.expects), "&"),
        async: true,
        options,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            if (this.options.length) {
                const input = dataset.value;
                let outputs;
                dataset.typed = true;
                const optionDatasets = await Promise.all(this.options.map((schema)=>schema["~run"]({
                        value: input
                    }, config2)));
                for (const optionDataset of optionDatasets){
                    if (optionDataset.issues) {
                        if (dataset.issues) {
                            dataset.issues.push(...optionDataset.issues);
                        } else {
                            dataset.issues = optionDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!optionDataset.typed) {
                        dataset.typed = false;
                    }
                    if (dataset.typed) {
                        if (outputs) {
                            outputs.push(optionDataset.value);
                        } else {
                            outputs = [
                                optionDataset.value
                            ];
                        }
                    }
                }
                if (dataset.typed) {
                    dataset.value = outputs[0];
                    for(let index = 1; index < outputs.length; index++){
                        const mergeDataset = _merge(dataset.value, outputs[index]);
                        if (mergeDataset.issue) {
                            _addIssue(this, "type", dataset, config2, {
                                received: "unknown"
                            });
                            break;
                        }
                        dataset.value = mergeDataset.value;
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/lazy/lazy.ts
// @__NO_SIDE_EFFECTS__
function lazy(getter) {
    return {
        kind: "schema",
        type: "lazy",
        reference: lazy,
        expects: "unknown",
        async: false,
        getter,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            return this.getter(dataset.value)["~run"](dataset, config2);
        }
    };
}
// src/schemas/lazy/lazyAsync.ts
// @__NO_SIDE_EFFECTS__
function lazyAsync(getter) {
    return {
        kind: "schema",
        type: "lazy",
        reference: lazyAsync,
        expects: "unknown",
        async: true,
        getter,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            return (await this.getter(dataset.value))["~run"](dataset, config2);
        }
    };
}
// src/schemas/literal/literal.ts
// @__NO_SIDE_EFFECTS__
function literal(literal_, message) {
    return {
        kind: "schema",
        type: "literal",
        reference: literal,
        expects: _stringify(literal_),
        async: false,
        literal: literal_,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (dataset.value === this.literal) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/looseObject/looseObject.ts
// @__NO_SIDE_EFFECTS__
function looseObject(entries, message) {
    return {
        kind: "schema",
        type: "loose_object",
        reference: looseObject,
        expects: "Object",
        async: false,
        entries,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                for(const key in this.entries){
                    const valueSchema = this.entries[key];
                    if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && // @ts-expect-error
                    valueSchema.default !== void 0) {
                        const value2 = key in input ? // @ts-expect-error
                        input[key] : getDefault(valueSchema);
                        const valueDataset = valueSchema["~run"]({
                            value: value2
                        }, config2);
                        if (valueDataset.issues) {
                            const pathItem = {
                                type: "object",
                                origin: "value",
                                input,
                                key,
                                value: value2
                            };
                            for (const issue of valueDataset.issues){
                                if (issue.path) {
                                    issue.path.unshift(pathItem);
                                } else {
                                    issue.path = [
                                        pathItem
                                    ];
                                }
                                dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                                dataset.issues = valueDataset.issues;
                            }
                            if (config2.abortEarly) {
                                dataset.typed = false;
                                break;
                            }
                        }
                        if (!valueDataset.typed) {
                            dataset.typed = false;
                        }
                        dataset.value[key] = valueDataset.value;
                    } else if (valueSchema.fallback !== void 0) {
                        dataset.value[key] = getFallback(valueSchema);
                    } else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
                        _addIssue(this, "key", dataset, config2, {
                            input: void 0,
                            expected: `"${key}"`,
                            path: [
                                {
                                    type: "object",
                                    origin: "key",
                                    input,
                                    key,
                                    // @ts-expect-error
                                    value: input[key]
                                }
                            ]
                        });
                        if (config2.abortEarly) {
                            break;
                        }
                    }
                }
                if (!dataset.issues || !config2.abortEarly) {
                    for(const key in input){
                        if (_isValidObjectKey(input, key) && !(key in this.entries)) {
                            dataset.value[key] = input[key];
                        }
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/looseObject/looseObjectAsync.ts
// @__NO_SIDE_EFFECTS__
function looseObjectAsync(entries, message) {
    return {
        kind: "schema",
        type: "loose_object",
        reference: looseObjectAsync,
        expects: "Object",
        async: true,
        entries,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                const valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema])=>{
                    if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && // @ts-expect-error
                    valueSchema.default !== void 0) {
                        const value2 = key in input ? // @ts-expect-error
                        input[key] : await getDefault(valueSchema);
                        return [
                            key,
                            value2,
                            valueSchema,
                            await valueSchema["~run"]({
                                value: value2
                            }, config2)
                        ];
                    }
                    return [
                        key,
                        // @ts-expect-error
                        input[key],
                        valueSchema,
                        null
                    ];
                }));
                for (const [key, value2, valueSchema, valueDataset] of valueDatasets){
                    if (valueDataset) {
                        if (valueDataset.issues) {
                            const pathItem = {
                                type: "object",
                                origin: "value",
                                input,
                                key,
                                value: value2
                            };
                            for (const issue of valueDataset.issues){
                                if (issue.path) {
                                    issue.path.unshift(pathItem);
                                } else {
                                    issue.path = [
                                        pathItem
                                    ];
                                }
                                dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                                dataset.issues = valueDataset.issues;
                            }
                            if (config2.abortEarly) {
                                dataset.typed = false;
                                break;
                            }
                        }
                        if (!valueDataset.typed) {
                            dataset.typed = false;
                        }
                        dataset.value[key] = valueDataset.value;
                    } else if (valueSchema.fallback !== void 0) {
                        dataset.value[key] = await getFallback(valueSchema);
                    } else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
                        _addIssue(this, "key", dataset, config2, {
                            input: void 0,
                            expected: `"${key}"`,
                            path: [
                                {
                                    type: "object",
                                    origin: "key",
                                    input,
                                    key,
                                    value: value2
                                }
                            ]
                        });
                        if (config2.abortEarly) {
                            break;
                        }
                    }
                }
                if (!dataset.issues || !config2.abortEarly) {
                    for(const key in input){
                        if (_isValidObjectKey(input, key) && !(key in this.entries)) {
                            dataset.value[key] = input[key];
                        }
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/looseTuple/looseTuple.ts
// @__NO_SIDE_EFFECTS__
function looseTuple(items, message) {
    return {
        kind: "schema",
        type: "loose_tuple",
        reference: looseTuple,
        expects: "Array",
        async: false,
        items,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                for(let key = 0; key < this.items.length; key++){
                    const value2 = input[key];
                    const itemDataset = this.items[key]["~run"]({
                        value: value2
                    }, config2);
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "array",
                            origin: "value",
                            input,
                            key,
                            value: value2
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = itemDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.push(itemDataset.value);
                }
                if (!dataset.issues || !config2.abortEarly) {
                    for(let key = this.items.length; key < input.length; key++){
                        dataset.value.push(input[key]);
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/looseTuple/looseTupleAsync.ts
// @__NO_SIDE_EFFECTS__
function looseTupleAsync(items, message) {
    return {
        kind: "schema",
        type: "loose_tuple",
        reference: looseTupleAsync,
        expects: "Array",
        async: true,
        items,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                const itemDatasets = await Promise.all(this.items.map(async (item, key)=>{
                    const value2 = input[key];
                    return [
                        key,
                        value2,
                        await item["~run"]({
                            value: value2
                        }, config2)
                    ];
                }));
                for (const [key, value2, itemDataset] of itemDatasets){
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "array",
                            origin: "value",
                            input,
                            key,
                            value: value2
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = itemDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.push(itemDataset.value);
                }
                if (!dataset.issues || !config2.abortEarly) {
                    for(let key = this.items.length; key < input.length; key++){
                        dataset.value.push(input[key]);
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/map/map.ts
// @__NO_SIDE_EFFECTS__
function map(key, value2, message) {
    return {
        kind: "schema",
        type: "map",
        reference: map,
        expects: "Map",
        async: false,
        key,
        value: value2,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            const input = dataset.value;
            if (input instanceof Map) {
                dataset.typed = true;
                dataset.value = /* @__PURE__ */ new Map();
                for (const [inputKey, inputValue] of input){
                    const keyDataset = this.key["~run"]({
                        value: inputKey
                    }, config2);
                    if (keyDataset.issues) {
                        const pathItem = {
                            type: "map",
                            origin: "key",
                            input,
                            key: inputKey,
                            value: inputValue
                        };
                        for (const issue of keyDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = keyDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    const valueDataset = this.value["~run"]({
                        value: inputValue
                    }, config2);
                    if (valueDataset.issues) {
                        const pathItem = {
                            type: "map",
                            origin: "value",
                            input,
                            key: inputKey,
                            value: inputValue
                        };
                        for (const issue of valueDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = valueDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!keyDataset.typed || !valueDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.set(keyDataset.value, valueDataset.value);
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/map/mapAsync.ts
// @__NO_SIDE_EFFECTS__
function mapAsync(key, value2, message) {
    return {
        kind: "schema",
        type: "map",
        reference: mapAsync,
        expects: "Map",
        async: true,
        key,
        value: value2,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            const input = dataset.value;
            if (input instanceof Map) {
                dataset.typed = true;
                dataset.value = /* @__PURE__ */ new Map();
                const datasets = await Promise.all([
                    ...input
                ].map(([inputKey, inputValue])=>Promise.all([
                        inputKey,
                        inputValue,
                        this.key["~run"]({
                            value: inputKey
                        }, config2),
                        this.value["~run"]({
                            value: inputValue
                        }, config2)
                    ])));
                for (const [inputKey, inputValue, keyDataset, valueDataset] of datasets){
                    if (keyDataset.issues) {
                        const pathItem = {
                            type: "map",
                            origin: "key",
                            input,
                            key: inputKey,
                            value: inputValue
                        };
                        for (const issue of keyDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = keyDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (valueDataset.issues) {
                        const pathItem = {
                            type: "map",
                            origin: "value",
                            input,
                            key: inputKey,
                            value: inputValue
                        };
                        for (const issue of valueDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = valueDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!keyDataset.typed || !valueDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.set(keyDataset.value, valueDataset.value);
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/nan/nan.ts
// @__NO_SIDE_EFFECTS__
function nan(message) {
    return {
        kind: "schema",
        type: "nan",
        reference: nan,
        expects: "NaN",
        async: false,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (Number.isNaN(dataset.value)) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/never/never.ts
// @__NO_SIDE_EFFECTS__
function never(message) {
    return {
        kind: "schema",
        type: "never",
        reference: never,
        expects: "never",
        async: false,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            _addIssue(this, "type", dataset, config2);
            return dataset;
        }
    };
}
// src/schemas/nonNullable/nonNullable.ts
// @__NO_SIDE_EFFECTS__
function nonNullable(wrapped, message) {
    return {
        kind: "schema",
        type: "non_nullable",
        reference: nonNullable,
        expects: "!null",
        async: false,
        wrapped,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (dataset.value !== null) {
                dataset = this.wrapped["~run"](dataset, config2);
            }
            if (dataset.value === null) {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/nonNullable/nonNullableAsync.ts
// @__NO_SIDE_EFFECTS__
function nonNullableAsync(wrapped, message) {
    return {
        kind: "schema",
        type: "non_nullable",
        reference: nonNullableAsync,
        expects: "!null",
        async: true,
        wrapped,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            if (dataset.value !== null) {
                dataset = await this.wrapped["~run"](dataset, config2);
            }
            if (dataset.value === null) {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/nonNullish/nonNullish.ts
// @__NO_SIDE_EFFECTS__
function nonNullish(wrapped, message) {
    return {
        kind: "schema",
        type: "non_nullish",
        reference: nonNullish,
        expects: "(!null & !undefined)",
        async: false,
        wrapped,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (!(dataset.value === null || dataset.value === void 0)) {
                dataset = this.wrapped["~run"](dataset, config2);
            }
            if (dataset.value === null || dataset.value === void 0) {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/nonNullish/nonNullishAsync.ts
// @__NO_SIDE_EFFECTS__
function nonNullishAsync(wrapped, message) {
    return {
        kind: "schema",
        type: "non_nullish",
        reference: nonNullishAsync,
        expects: "(!null & !undefined)",
        async: true,
        wrapped,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            if (!(dataset.value === null || dataset.value === void 0)) {
                dataset = await this.wrapped["~run"](dataset, config2);
            }
            if (dataset.value === null || dataset.value === void 0) {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/nonOptional/nonOptional.ts
// @__NO_SIDE_EFFECTS__
function nonOptional(wrapped, message) {
    return {
        kind: "schema",
        type: "non_optional",
        reference: nonOptional,
        expects: "!undefined",
        async: false,
        wrapped,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (dataset.value !== void 0) {
                dataset = this.wrapped["~run"](dataset, config2);
            }
            if (dataset.value === void 0) {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/nonOptional/nonOptionalAsync.ts
// @__NO_SIDE_EFFECTS__
function nonOptionalAsync(wrapped, message) {
    return {
        kind: "schema",
        type: "non_optional",
        reference: nonOptionalAsync,
        expects: "!undefined",
        async: true,
        wrapped,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            if (dataset.value !== void 0) {
                dataset = await this.wrapped["~run"](dataset, config2);
            }
            if (dataset.value === void 0) {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/null/null.ts
// @__NO_SIDE_EFFECTS__
function null_(message) {
    return {
        kind: "schema",
        type: "null",
        reference: null_,
        expects: "null",
        async: false,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (dataset.value === null) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/nullable/nullable.ts
// @__NO_SIDE_EFFECTS__
function nullable(wrapped, default_) {
    return {
        kind: "schema",
        type: "nullable",
        reference: nullable,
        expects: `(${wrapped.expects} | null)`,
        async: false,
        wrapped,
        default: default_,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (dataset.value === null) {
                if (this.default !== void 0) {
                    dataset.value = getDefault(this, dataset, config2);
                }
                if (dataset.value === null) {
                    dataset.typed = true;
                    return dataset;
                }
            }
            return this.wrapped["~run"](dataset, config2);
        }
    };
}
// src/schemas/nullable/nullableAsync.ts
// @__NO_SIDE_EFFECTS__
function nullableAsync(wrapped, default_) {
    return {
        kind: "schema",
        type: "nullable",
        reference: nullableAsync,
        expects: `(${wrapped.expects} | null)`,
        async: true,
        wrapped,
        default: default_,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            if (dataset.value === null) {
                if (this.default !== void 0) {
                    dataset.value = await getDefault(this, dataset, config2);
                }
                if (dataset.value === null) {
                    dataset.typed = true;
                    return dataset;
                }
            }
            return this.wrapped["~run"](dataset, config2);
        }
    };
}
// src/schemas/nullish/nullish.ts
// @__NO_SIDE_EFFECTS__
function nullish(wrapped, default_) {
    return {
        kind: "schema",
        type: "nullish",
        reference: nullish,
        expects: `(${wrapped.expects} | null | undefined)`,
        async: false,
        wrapped,
        default: default_,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (dataset.value === null || dataset.value === void 0) {
                if (this.default !== void 0) {
                    dataset.value = getDefault(this, dataset, config2);
                }
                if (dataset.value === null || dataset.value === void 0) {
                    dataset.typed = true;
                    return dataset;
                }
            }
            return this.wrapped["~run"](dataset, config2);
        }
    };
}
// src/schemas/nullish/nullishAsync.ts
// @__NO_SIDE_EFFECTS__
function nullishAsync(wrapped, default_) {
    return {
        kind: "schema",
        type: "nullish",
        reference: nullishAsync,
        expects: `(${wrapped.expects} | null | undefined)`,
        async: true,
        wrapped,
        default: default_,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            if (dataset.value === null || dataset.value === void 0) {
                if (this.default !== void 0) {
                    dataset.value = await getDefault(this, dataset, config2);
                }
                if (dataset.value === null || dataset.value === void 0) {
                    dataset.typed = true;
                    return dataset;
                }
            }
            return this.wrapped["~run"](dataset, config2);
        }
    };
}
// src/schemas/number/number.ts
// @__NO_SIDE_EFFECTS__
function number(message) {
    return {
        kind: "schema",
        type: "number",
        reference: number,
        expects: "number",
        async: false,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (typeof dataset.value === "number" && !isNaN(dataset.value)) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/object/object.ts
// @__NO_SIDE_EFFECTS__
function object(entries, message) {
    return {
        kind: "schema",
        type: "object",
        reference: object,
        expects: "Object",
        async: false,
        entries,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                for(const key in this.entries){
                    const valueSchema = this.entries[key];
                    if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && // @ts-expect-error
                    valueSchema.default !== void 0) {
                        const value2 = key in input ? // @ts-expect-error
                        input[key] : getDefault(valueSchema);
                        const valueDataset = valueSchema["~run"]({
                            value: value2
                        }, config2);
                        if (valueDataset.issues) {
                            const pathItem = {
                                type: "object",
                                origin: "value",
                                input,
                                key,
                                value: value2
                            };
                            for (const issue of valueDataset.issues){
                                if (issue.path) {
                                    issue.path.unshift(pathItem);
                                } else {
                                    issue.path = [
                                        pathItem
                                    ];
                                }
                                dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                                dataset.issues = valueDataset.issues;
                            }
                            if (config2.abortEarly) {
                                dataset.typed = false;
                                break;
                            }
                        }
                        if (!valueDataset.typed) {
                            dataset.typed = false;
                        }
                        dataset.value[key] = valueDataset.value;
                    } else if (valueSchema.fallback !== void 0) {
                        dataset.value[key] = getFallback(valueSchema);
                    } else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
                        _addIssue(this, "key", dataset, config2, {
                            input: void 0,
                            expected: `"${key}"`,
                            path: [
                                {
                                    type: "object",
                                    origin: "key",
                                    input,
                                    key,
                                    // @ts-expect-error
                                    value: input[key]
                                }
                            ]
                        });
                        if (config2.abortEarly) {
                            break;
                        }
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/object/objectAsync.ts
// @__NO_SIDE_EFFECTS__
function objectAsync(entries, message) {
    return {
        kind: "schema",
        type: "object",
        reference: objectAsync,
        expects: "Object",
        async: true,
        entries,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                const valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema])=>{
                    if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && // @ts-expect-error
                    valueSchema.default !== void 0) {
                        const value2 = key in input ? // @ts-expect-error
                        input[key] : await getDefault(valueSchema);
                        return [
                            key,
                            value2,
                            valueSchema,
                            await valueSchema["~run"]({
                                value: value2
                            }, config2)
                        ];
                    }
                    return [
                        key,
                        // @ts-expect-error
                        input[key],
                        valueSchema,
                        null
                    ];
                }));
                for (const [key, value2, valueSchema, valueDataset] of valueDatasets){
                    if (valueDataset) {
                        if (valueDataset.issues) {
                            const pathItem = {
                                type: "object",
                                origin: "value",
                                input,
                                key,
                                value: value2
                            };
                            for (const issue of valueDataset.issues){
                                if (issue.path) {
                                    issue.path.unshift(pathItem);
                                } else {
                                    issue.path = [
                                        pathItem
                                    ];
                                }
                                dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                                dataset.issues = valueDataset.issues;
                            }
                            if (config2.abortEarly) {
                                dataset.typed = false;
                                break;
                            }
                        }
                        if (!valueDataset.typed) {
                            dataset.typed = false;
                        }
                        dataset.value[key] = valueDataset.value;
                    } else if (valueSchema.fallback !== void 0) {
                        dataset.value[key] = await getFallback(valueSchema);
                    } else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
                        _addIssue(this, "key", dataset, config2, {
                            input: void 0,
                            expected: `"${key}"`,
                            path: [
                                {
                                    type: "object",
                                    origin: "key",
                                    input,
                                    key,
                                    value: value2
                                }
                            ]
                        });
                        if (config2.abortEarly) {
                            break;
                        }
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/objectWithRest/objectWithRest.ts
// @__NO_SIDE_EFFECTS__
function objectWithRest(entries, rest, message) {
    return {
        kind: "schema",
        type: "object_with_rest",
        reference: objectWithRest,
        expects: "Object",
        async: false,
        entries,
        rest,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                for(const key in this.entries){
                    const valueSchema = this.entries[key];
                    if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && // @ts-expect-error
                    valueSchema.default !== void 0) {
                        const value2 = key in input ? // @ts-expect-error
                        input[key] : getDefault(valueSchema);
                        const valueDataset = valueSchema["~run"]({
                            value: value2
                        }, config2);
                        if (valueDataset.issues) {
                            const pathItem = {
                                type: "object",
                                origin: "value",
                                input,
                                key,
                                value: value2
                            };
                            for (const issue of valueDataset.issues){
                                if (issue.path) {
                                    issue.path.unshift(pathItem);
                                } else {
                                    issue.path = [
                                        pathItem
                                    ];
                                }
                                dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                                dataset.issues = valueDataset.issues;
                            }
                            if (config2.abortEarly) {
                                dataset.typed = false;
                                break;
                            }
                        }
                        if (!valueDataset.typed) {
                            dataset.typed = false;
                        }
                        dataset.value[key] = valueDataset.value;
                    } else if (valueSchema.fallback !== void 0) {
                        dataset.value[key] = getFallback(valueSchema);
                    } else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
                        _addIssue(this, "key", dataset, config2, {
                            input: void 0,
                            expected: `"${key}"`,
                            path: [
                                {
                                    type: "object",
                                    origin: "key",
                                    input,
                                    key,
                                    // @ts-expect-error
                                    value: input[key]
                                }
                            ]
                        });
                        if (config2.abortEarly) {
                            break;
                        }
                    }
                }
                if (!dataset.issues || !config2.abortEarly) {
                    for(const key in input){
                        if (_isValidObjectKey(input, key) && !(key in this.entries)) {
                            const valueDataset = this.rest["~run"](// @ts-expect-error
                            {
                                value: input[key]
                            }, config2);
                            if (valueDataset.issues) {
                                const pathItem = {
                                    type: "object",
                                    origin: "value",
                                    input,
                                    key,
                                    // @ts-expect-error
                                    value: input[key]
                                };
                                for (const issue of valueDataset.issues){
                                    if (issue.path) {
                                        issue.path.unshift(pathItem);
                                    } else {
                                        issue.path = [
                                            pathItem
                                        ];
                                    }
                                    dataset.issues?.push(issue);
                                }
                                if (!dataset.issues) {
                                    dataset.issues = valueDataset.issues;
                                }
                                if (config2.abortEarly) {
                                    dataset.typed = false;
                                    break;
                                }
                            }
                            if (!valueDataset.typed) {
                                dataset.typed = false;
                            }
                            dataset.value[key] = valueDataset.value;
                        }
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/objectWithRest/objectWithRestAsync.ts
// @__NO_SIDE_EFFECTS__
function objectWithRestAsync(entries, rest, message) {
    return {
        kind: "schema",
        type: "object_with_rest",
        reference: objectWithRestAsync,
        expects: "Object",
        async: true,
        entries,
        rest,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                const [normalDatasets, restDatasets] = await Promise.all([
                    // If key is present or its an optional schema with a default value,
                    // parse input of key or default value asynchronously
                    Promise.all(Object.entries(this.entries).map(async ([key, valueSchema])=>{
                        if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && // @ts-expect-error
                        valueSchema.default !== void 0) {
                            const value2 = key in input ? // @ts-expect-error
                            input[key] : await getDefault(valueSchema);
                            return [
                                key,
                                value2,
                                valueSchema,
                                await valueSchema["~run"]({
                                    value: value2
                                }, config2)
                            ];
                        }
                        return [
                            key,
                            // @ts-expect-error
                            input[key],
                            valueSchema,
                            null
                        ];
                    })),
                    // Parse other entries with rest schema asynchronously
                    // Hint: We exclude specific keys for security reasons
                    Promise.all(Object.entries(input).filter(([key])=>_isValidObjectKey(input, key) && !(key in this.entries)).map(async ([key, value2])=>[
                            key,
                            value2,
                            await this.rest["~run"]({
                                value: value2
                            }, config2)
                        ]))
                ]);
                for (const [key, value2, valueSchema, valueDataset] of normalDatasets){
                    if (valueDataset) {
                        if (valueDataset.issues) {
                            const pathItem = {
                                type: "object",
                                origin: "value",
                                input,
                                key,
                                value: value2
                            };
                            for (const issue of valueDataset.issues){
                                if (issue.path) {
                                    issue.path.unshift(pathItem);
                                } else {
                                    issue.path = [
                                        pathItem
                                    ];
                                }
                                dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                                dataset.issues = valueDataset.issues;
                            }
                            if (config2.abortEarly) {
                                dataset.typed = false;
                                break;
                            }
                        }
                        if (!valueDataset.typed) {
                            dataset.typed = false;
                        }
                        dataset.value[key] = valueDataset.value;
                    } else if (valueSchema.fallback !== void 0) {
                        dataset.value[key] = await getFallback(valueSchema);
                    } else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
                        _addIssue(this, "key", dataset, config2, {
                            input: void 0,
                            expected: `"${key}"`,
                            path: [
                                {
                                    type: "object",
                                    origin: "key",
                                    input,
                                    key,
                                    value: value2
                                }
                            ]
                        });
                        if (config2.abortEarly) {
                            break;
                        }
                    }
                }
                if (!dataset.issues || !config2.abortEarly) {
                    for (const [key, value2, valueDataset] of restDatasets){
                        if (valueDataset.issues) {
                            const pathItem = {
                                type: "object",
                                origin: "value",
                                input,
                                key,
                                value: value2
                            };
                            for (const issue of valueDataset.issues){
                                if (issue.path) {
                                    issue.path.unshift(pathItem);
                                } else {
                                    issue.path = [
                                        pathItem
                                    ];
                                }
                                dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                                dataset.issues = valueDataset.issues;
                            }
                            if (config2.abortEarly) {
                                dataset.typed = false;
                                break;
                            }
                        }
                        if (!valueDataset.typed) {
                            dataset.typed = false;
                        }
                        dataset.value[key] = valueDataset.value;
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/optional/optional.ts
// @__NO_SIDE_EFFECTS__
function optional(wrapped, default_) {
    return {
        kind: "schema",
        type: "optional",
        reference: optional,
        expects: `(${wrapped.expects} | undefined)`,
        async: false,
        wrapped,
        default: default_,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (dataset.value === void 0) {
                if (this.default !== void 0) {
                    dataset.value = getDefault(this, dataset, config2);
                }
                if (dataset.value === void 0) {
                    dataset.typed = true;
                    return dataset;
                }
            }
            return this.wrapped["~run"](dataset, config2);
        }
    };
}
// src/schemas/optional/optionalAsync.ts
// @__NO_SIDE_EFFECTS__
function optionalAsync(wrapped, default_) {
    return {
        kind: "schema",
        type: "optional",
        reference: optionalAsync,
        expects: `(${wrapped.expects} | undefined)`,
        async: true,
        wrapped,
        default: default_,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            if (dataset.value === void 0) {
                if (this.default !== void 0) {
                    dataset.value = await getDefault(this, dataset, config2);
                }
                if (dataset.value === void 0) {
                    dataset.typed = true;
                    return dataset;
                }
            }
            return this.wrapped["~run"](dataset, config2);
        }
    };
}
// src/schemas/picklist/picklist.ts
// @__NO_SIDE_EFFECTS__
function picklist(options, message) {
    return {
        kind: "schema",
        type: "picklist",
        reference: picklist,
        expects: _joinExpects(options.map(_stringify), "|"),
        async: false,
        options,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (this.options.includes(dataset.value)) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/promise/promise.ts
// @__NO_SIDE_EFFECTS__
function promise(message) {
    return {
        kind: "schema",
        type: "promise",
        reference: promise,
        expects: "Promise",
        async: false,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (dataset.value instanceof Promise) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/record/record.ts
// @__NO_SIDE_EFFECTS__
function record(key, value2, message) {
    return {
        kind: "schema",
        type: "record",
        reference: record,
        expects: "Object",
        async: false,
        key,
        value: value2,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                for(const entryKey in input){
                    if (_isValidObjectKey(input, entryKey)) {
                        const entryValue = input[entryKey];
                        const keyDataset = this.key["~run"]({
                            value: entryKey
                        }, config2);
                        if (keyDataset.issues) {
                            const pathItem = {
                                type: "object",
                                origin: "key",
                                input,
                                key: entryKey,
                                value: entryValue
                            };
                            for (const issue of keyDataset.issues){
                                issue.path = [
                                    pathItem
                                ];
                                dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                                dataset.issues = keyDataset.issues;
                            }
                            if (config2.abortEarly) {
                                dataset.typed = false;
                                break;
                            }
                        }
                        const valueDataset = this.value["~run"]({
                            value: entryValue
                        }, config2);
                        if (valueDataset.issues) {
                            const pathItem = {
                                type: "object",
                                origin: "value",
                                input,
                                key: entryKey,
                                value: entryValue
                            };
                            for (const issue of valueDataset.issues){
                                if (issue.path) {
                                    issue.path.unshift(pathItem);
                                } else {
                                    issue.path = [
                                        pathItem
                                    ];
                                }
                                dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                                dataset.issues = valueDataset.issues;
                            }
                            if (config2.abortEarly) {
                                dataset.typed = false;
                                break;
                            }
                        }
                        if (!keyDataset.typed || !valueDataset.typed) {
                            dataset.typed = false;
                        }
                        if (keyDataset.typed) {
                            dataset.value[keyDataset.value] = valueDataset.value;
                        }
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/record/recordAsync.ts
// @__NO_SIDE_EFFECTS__
function recordAsync(key, value2, message) {
    return {
        kind: "schema",
        type: "record",
        reference: recordAsync,
        expects: "Object",
        async: true,
        key,
        value: value2,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                const datasets = await Promise.all(Object.entries(input).filter(([key2])=>_isValidObjectKey(input, key2)).map(([entryKey, entryValue])=>Promise.all([
                        entryKey,
                        entryValue,
                        this.key["~run"]({
                            value: entryKey
                        }, config2),
                        this.value["~run"]({
                            value: entryValue
                        }, config2)
                    ])));
                for (const [entryKey, entryValue, keyDataset, valueDataset] of datasets){
                    if (keyDataset.issues) {
                        const pathItem = {
                            type: "object",
                            origin: "key",
                            input,
                            key: entryKey,
                            value: entryValue
                        };
                        for (const issue of keyDataset.issues){
                            issue.path = [
                                pathItem
                            ];
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = keyDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (valueDataset.issues) {
                        const pathItem = {
                            type: "object",
                            origin: "value",
                            input,
                            key: entryKey,
                            value: entryValue
                        };
                        for (const issue of valueDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = valueDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!keyDataset.typed || !valueDataset.typed) {
                        dataset.typed = false;
                    }
                    if (keyDataset.typed) {
                        dataset.value[keyDataset.value] = valueDataset.value;
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/set/set.ts
// @__NO_SIDE_EFFECTS__
function set(value2, message) {
    return {
        kind: "schema",
        type: "set",
        reference: set,
        expects: "Set",
        async: false,
        value: value2,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            const input = dataset.value;
            if (input instanceof Set) {
                dataset.typed = true;
                dataset.value = /* @__PURE__ */ new Set();
                for (const inputValue of input){
                    const valueDataset = this.value["~run"]({
                        value: inputValue
                    }, config2);
                    if (valueDataset.issues) {
                        const pathItem = {
                            type: "set",
                            origin: "value",
                            input,
                            key: null,
                            value: inputValue
                        };
                        for (const issue of valueDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = valueDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!valueDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.add(valueDataset.value);
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/set/setAsync.ts
// @__NO_SIDE_EFFECTS__
function setAsync(value2, message) {
    return {
        kind: "schema",
        type: "set",
        reference: setAsync,
        expects: "Set",
        async: true,
        value: value2,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            const input = dataset.value;
            if (input instanceof Set) {
                dataset.typed = true;
                dataset.value = /* @__PURE__ */ new Set();
                const valueDatasets = await Promise.all([
                    ...input
                ].map(async (inputValue)=>[
                        inputValue,
                        await this.value["~run"]({
                            value: inputValue
                        }, config2)
                    ]));
                for (const [inputValue, valueDataset] of valueDatasets){
                    if (valueDataset.issues) {
                        const pathItem = {
                            type: "set",
                            origin: "value",
                            input,
                            key: null,
                            value: inputValue
                        };
                        for (const issue of valueDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = valueDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!valueDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.add(valueDataset.value);
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/strictObject/strictObject.ts
// @__NO_SIDE_EFFECTS__
function strictObject(entries, message) {
    return {
        kind: "schema",
        type: "strict_object",
        reference: strictObject,
        expects: "Object",
        async: false,
        entries,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                for(const key in this.entries){
                    const valueSchema = this.entries[key];
                    if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && // @ts-expect-error
                    valueSchema.default !== void 0) {
                        const value2 = key in input ? // @ts-expect-error
                        input[key] : getDefault(valueSchema);
                        const valueDataset = valueSchema["~run"]({
                            value: value2
                        }, config2);
                        if (valueDataset.issues) {
                            const pathItem = {
                                type: "object",
                                origin: "value",
                                input,
                                key,
                                value: value2
                            };
                            for (const issue of valueDataset.issues){
                                if (issue.path) {
                                    issue.path.unshift(pathItem);
                                } else {
                                    issue.path = [
                                        pathItem
                                    ];
                                }
                                dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                                dataset.issues = valueDataset.issues;
                            }
                            if (config2.abortEarly) {
                                dataset.typed = false;
                                break;
                            }
                        }
                        if (!valueDataset.typed) {
                            dataset.typed = false;
                        }
                        dataset.value[key] = valueDataset.value;
                    } else if (valueSchema.fallback !== void 0) {
                        dataset.value[key] = getFallback(valueSchema);
                    } else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
                        _addIssue(this, "key", dataset, config2, {
                            input: void 0,
                            expected: `"${key}"`,
                            path: [
                                {
                                    type: "object",
                                    origin: "key",
                                    input,
                                    key,
                                    // @ts-expect-error
                                    value: input[key]
                                }
                            ]
                        });
                        if (config2.abortEarly) {
                            break;
                        }
                    }
                }
                if (!dataset.issues || !config2.abortEarly) {
                    for(const key in input){
                        if (!(key in this.entries)) {
                            _addIssue(this, "key", dataset, config2, {
                                input: key,
                                expected: "never",
                                path: [
                                    {
                                        type: "object",
                                        origin: "key",
                                        input,
                                        key,
                                        // @ts-expect-error
                                        value: input[key]
                                    }
                                ]
                            });
                            break;
                        }
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/strictObject/strictObjectAsync.ts
// @__NO_SIDE_EFFECTS__
function strictObjectAsync(entries, message) {
    return {
        kind: "schema",
        type: "strict_object",
        reference: strictObjectAsync,
        expects: "Object",
        async: true,
        entries,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                const valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema])=>{
                    if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && // @ts-expect-error
                    valueSchema.default !== void 0) {
                        const value2 = key in input ? // @ts-expect-error
                        input[key] : await getDefault(valueSchema);
                        return [
                            key,
                            value2,
                            valueSchema,
                            await valueSchema["~run"]({
                                value: value2
                            }, config2)
                        ];
                    }
                    return [
                        key,
                        // @ts-expect-error
                        input[key],
                        valueSchema,
                        null
                    ];
                }));
                for (const [key, value2, valueSchema, valueDataset] of valueDatasets){
                    if (valueDataset) {
                        if (valueDataset.issues) {
                            const pathItem = {
                                type: "object",
                                origin: "value",
                                input,
                                key,
                                value: value2
                            };
                            for (const issue of valueDataset.issues){
                                if (issue.path) {
                                    issue.path.unshift(pathItem);
                                } else {
                                    issue.path = [
                                        pathItem
                                    ];
                                }
                                dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                                dataset.issues = valueDataset.issues;
                            }
                            if (config2.abortEarly) {
                                dataset.typed = false;
                                break;
                            }
                        }
                        if (!valueDataset.typed) {
                            dataset.typed = false;
                        }
                        dataset.value[key] = valueDataset.value;
                    } else if (valueSchema.fallback !== void 0) {
                        dataset.value[key] = await getFallback(valueSchema);
                    } else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
                        _addIssue(this, "key", dataset, config2, {
                            input: void 0,
                            expected: `"${key}"`,
                            path: [
                                {
                                    type: "object",
                                    origin: "key",
                                    input,
                                    key,
                                    value: value2
                                }
                            ]
                        });
                        if (config2.abortEarly) {
                            break;
                        }
                    }
                }
                if (!dataset.issues || !config2.abortEarly) {
                    for(const key in input){
                        if (!(key in this.entries)) {
                            _addIssue(this, "key", dataset, config2, {
                                input: key,
                                expected: "never",
                                path: [
                                    {
                                        type: "object",
                                        origin: "key",
                                        input,
                                        key,
                                        // @ts-expect-error
                                        value: input[key]
                                    }
                                ]
                            });
                            break;
                        }
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/strictTuple/strictTuple.ts
// @__NO_SIDE_EFFECTS__
function strictTuple(items, message) {
    return {
        kind: "schema",
        type: "strict_tuple",
        reference: strictTuple,
        expects: "Array",
        async: false,
        items,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                for(let key = 0; key < this.items.length; key++){
                    const value2 = input[key];
                    const itemDataset = this.items[key]["~run"]({
                        value: value2
                    }, config2);
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "array",
                            origin: "value",
                            input,
                            key,
                            value: value2
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = itemDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.push(itemDataset.value);
                }
                if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {
                    _addIssue(this, "type", dataset, config2, {
                        input: input[this.items.length],
                        expected: "never",
                        path: [
                            {
                                type: "array",
                                origin: "value",
                                input,
                                key: this.items.length,
                                value: input[this.items.length]
                            }
                        ]
                    });
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/strictTuple/strictTupleAsync.ts
// @__NO_SIDE_EFFECTS__
function strictTupleAsync(items, message) {
    return {
        kind: "schema",
        type: "strict_tuple",
        reference: strictTupleAsync,
        expects: "Array",
        async: true,
        items,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                const itemDatasets = await Promise.all(this.items.map(async (item, key)=>{
                    const value2 = input[key];
                    return [
                        key,
                        value2,
                        await item["~run"]({
                            value: value2
                        }, config2)
                    ];
                }));
                for (const [key, value2, itemDataset] of itemDatasets){
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "array",
                            origin: "value",
                            input,
                            key,
                            value: value2
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = itemDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.push(itemDataset.value);
                }
                if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {
                    _addIssue(this, "type", dataset, config2, {
                        input: input[this.items.length],
                        expected: "never",
                        path: [
                            {
                                type: "array",
                                origin: "value",
                                input,
                                key: this.items.length,
                                value: input[this.items.length]
                            }
                        ]
                    });
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/string/string.ts
// @__NO_SIDE_EFFECTS__
function string(message) {
    return {
        kind: "schema",
        type: "string",
        reference: string,
        expects: "string",
        async: false,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (typeof dataset.value === "string") {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/symbol/symbol.ts
// @__NO_SIDE_EFFECTS__
function symbol(message) {
    return {
        kind: "schema",
        type: "symbol",
        reference: symbol,
        expects: "symbol",
        async: false,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (typeof dataset.value === "symbol") {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/tuple/tuple.ts
// @__NO_SIDE_EFFECTS__
function tuple(items, message) {
    return {
        kind: "schema",
        type: "tuple",
        reference: tuple,
        expects: "Array",
        async: false,
        items,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                for(let key = 0; key < this.items.length; key++){
                    const value2 = input[key];
                    const itemDataset = this.items[key]["~run"]({
                        value: value2
                    }, config2);
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "array",
                            origin: "value",
                            input,
                            key,
                            value: value2
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = itemDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.push(itemDataset.value);
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/tuple/tupleAsync.ts
// @__NO_SIDE_EFFECTS__
function tupleAsync(items, message) {
    return {
        kind: "schema",
        type: "tuple",
        reference: tupleAsync,
        expects: "Array",
        async: true,
        items,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                const itemDatasets = await Promise.all(this.items.map(async (item, key)=>{
                    const value2 = input[key];
                    return [
                        key,
                        value2,
                        await item["~run"]({
                            value: value2
                        }, config2)
                    ];
                }));
                for (const [key, value2, itemDataset] of itemDatasets){
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "array",
                            origin: "value",
                            input,
                            key,
                            value: value2
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = itemDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.push(itemDataset.value);
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/tupleWithRest/tupleWithRest.ts
// @__NO_SIDE_EFFECTS__
function tupleWithRest(items, rest, message) {
    return {
        kind: "schema",
        type: "tuple_with_rest",
        reference: tupleWithRest,
        expects: "Array",
        async: false,
        items,
        rest,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                for(let key = 0; key < this.items.length; key++){
                    const value2 = input[key];
                    const itemDataset = this.items[key]["~run"]({
                        value: value2
                    }, config2);
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "array",
                            origin: "value",
                            input,
                            key,
                            value: value2
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = itemDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.push(itemDataset.value);
                }
                if (!dataset.issues || !config2.abortEarly) {
                    for(let key = this.items.length; key < input.length; key++){
                        const value2 = input[key];
                        const itemDataset = this.rest["~run"]({
                            value: value2
                        }, config2);
                        if (itemDataset.issues) {
                            const pathItem = {
                                type: "array",
                                origin: "value",
                                input,
                                key,
                                value: value2
                            };
                            for (const issue of itemDataset.issues){
                                if (issue.path) {
                                    issue.path.unshift(pathItem);
                                } else {
                                    issue.path = [
                                        pathItem
                                    ];
                                }
                                dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                                dataset.issues = itemDataset.issues;
                            }
                            if (config2.abortEarly) {
                                dataset.typed = false;
                                break;
                            }
                        }
                        if (!itemDataset.typed) {
                            dataset.typed = false;
                        }
                        dataset.value.push(itemDataset.value);
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/tupleWithRest/tupleWithRestAsync.ts
// @__NO_SIDE_EFFECTS__
function tupleWithRestAsync(items, rest, message) {
    return {
        kind: "schema",
        type: "tuple_with_rest",
        reference: tupleWithRestAsync,
        expects: "Array",
        async: true,
        items,
        rest,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                const [normalDatasets, restDatasets] = await Promise.all([
                    // Parse schema of each normal item
                    Promise.all(this.items.map(async (item, key)=>{
                        const value2 = input[key];
                        return [
                            key,
                            value2,
                            await item["~run"]({
                                value: value2
                            }, config2)
                        ];
                    })),
                    // Parse other items with rest schema
                    Promise.all(input.slice(this.items.length).map(async (value2, key)=>{
                        return [
                            key + this.items.length,
                            value2,
                            await this.rest["~run"]({
                                value: value2
                            }, config2)
                        ];
                    }))
                ]);
                for (const [key, value2, itemDataset] of normalDatasets){
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "array",
                            origin: "value",
                            input,
                            key,
                            value: value2
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = itemDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.push(itemDataset.value);
                }
                if (!dataset.issues || !config2.abortEarly) {
                    for (const [key, value2, itemDataset] of restDatasets){
                        if (itemDataset.issues) {
                            const pathItem = {
                                type: "array",
                                origin: "value",
                                input,
                                key,
                                value: value2
                            };
                            for (const issue of itemDataset.issues){
                                if (issue.path) {
                                    issue.path.unshift(pathItem);
                                } else {
                                    issue.path = [
                                        pathItem
                                    ];
                                }
                                dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                                dataset.issues = itemDataset.issues;
                            }
                            if (config2.abortEarly) {
                                dataset.typed = false;
                                break;
                            }
                        }
                        if (!itemDataset.typed) {
                            dataset.typed = false;
                        }
                        dataset.value.push(itemDataset.value);
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/undefined/undefined.ts
// @__NO_SIDE_EFFECTS__
function undefined_(message) {
    return {
        kind: "schema",
        type: "undefined",
        reference: undefined_,
        expects: "undefined",
        async: false,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (dataset.value === void 0) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/undefinedable/undefinedable.ts
// @__NO_SIDE_EFFECTS__
function undefinedable(wrapped, default_) {
    return {
        kind: "schema",
        type: "undefinedable",
        reference: undefinedable,
        expects: `(${wrapped.expects} | undefined)`,
        async: false,
        wrapped,
        default: default_,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (dataset.value === void 0) {
                if (this.default !== void 0) {
                    dataset.value = getDefault(this, dataset, config2);
                }
                if (dataset.value === void 0) {
                    dataset.typed = true;
                    return dataset;
                }
            }
            return this.wrapped["~run"](dataset, config2);
        }
    };
}
// src/schemas/undefinedable/undefinedableAsync.ts
// @__NO_SIDE_EFFECTS__
function undefinedableAsync(wrapped, default_) {
    return {
        kind: "schema",
        type: "undefinedable",
        reference: undefinedableAsync,
        expects: `(${wrapped.expects} | undefined)`,
        async: true,
        wrapped,
        default: default_,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            if (dataset.value === void 0) {
                if (this.default !== void 0) {
                    dataset.value = await getDefault(this, dataset, config2);
                }
                if (dataset.value === void 0) {
                    dataset.typed = true;
                    return dataset;
                }
            }
            return this.wrapped["~run"](dataset, config2);
        }
    };
}
// src/schemas/union/utils/_subIssues/_subIssues.ts
// @__NO_SIDE_EFFECTS__
function _subIssues(datasets) {
    let issues;
    if (datasets) {
        for (const dataset of datasets){
            if (issues) {
                issues.push(...dataset.issues);
            } else {
                issues = dataset.issues;
            }
        }
    }
    return issues;
}
// src/schemas/union/union.ts
// @__NO_SIDE_EFFECTS__
function union(options, message) {
    return {
        kind: "schema",
        type: "union",
        reference: union,
        expects: _joinExpects(options.map((option)=>option.expects), "|"),
        async: false,
        options,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            let validDataset;
            let typedDatasets;
            let untypedDatasets;
            for (const schema of this.options){
                const optionDataset = schema["~run"]({
                    value: dataset.value
                }, config2);
                if (optionDataset.typed) {
                    if (optionDataset.issues) {
                        if (typedDatasets) {
                            typedDatasets.push(optionDataset);
                        } else {
                            typedDatasets = [
                                optionDataset
                            ];
                        }
                    } else {
                        validDataset = optionDataset;
                        break;
                    }
                } else {
                    if (untypedDatasets) {
                        untypedDatasets.push(optionDataset);
                    } else {
                        untypedDatasets = [
                            optionDataset
                        ];
                    }
                }
            }
            if (validDataset) {
                return validDataset;
            }
            if (typedDatasets) {
                if (typedDatasets.length === 1) {
                    return typedDatasets[0];
                }
                _addIssue(this, "type", dataset, config2, {
                    issues: _subIssues(typedDatasets)
                });
                dataset.typed = true;
            } else if (untypedDatasets?.length === 1) {
                return untypedDatasets[0];
            } else {
                _addIssue(this, "type", dataset, config2, {
                    issues: _subIssues(untypedDatasets)
                });
            }
            return dataset;
        }
    };
}
// src/schemas/union/unionAsync.ts
// @__NO_SIDE_EFFECTS__
function unionAsync(options, message) {
    return {
        kind: "schema",
        type: "union",
        reference: unionAsync,
        expects: _joinExpects(options.map((option)=>option.expects), "|"),
        async: true,
        options,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            let validDataset;
            let typedDatasets;
            let untypedDatasets;
            for (const schema of this.options){
                const optionDataset = await schema["~run"]({
                    value: dataset.value
                }, config2);
                if (optionDataset.typed) {
                    if (optionDataset.issues) {
                        if (typedDatasets) {
                            typedDatasets.push(optionDataset);
                        } else {
                            typedDatasets = [
                                optionDataset
                            ];
                        }
                    } else {
                        validDataset = optionDataset;
                        break;
                    }
                } else {
                    if (untypedDatasets) {
                        untypedDatasets.push(optionDataset);
                    } else {
                        untypedDatasets = [
                            optionDataset
                        ];
                    }
                }
            }
            if (validDataset) {
                return validDataset;
            }
            if (typedDatasets) {
                if (typedDatasets.length === 1) {
                    return typedDatasets[0];
                }
                _addIssue(this, "type", dataset, config2, {
                    issues: _subIssues(typedDatasets)
                });
                dataset.typed = true;
            } else if (untypedDatasets?.length === 1) {
                return untypedDatasets[0];
            } else {
                _addIssue(this, "type", dataset, config2, {
                    issues: _subIssues(untypedDatasets)
                });
            }
            return dataset;
        }
    };
}
// src/schemas/unknown/unknown.ts
// @__NO_SIDE_EFFECTS__
function unknown() {
    return {
        kind: "schema",
        type: "unknown",
        reference: unknown,
        expects: "unknown",
        async: false,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset) {
            dataset.typed = true;
            return dataset;
        }
    };
}
// src/schemas/variant/variant.ts
// @__NO_SIDE_EFFECTS__
function variant(key, options, message) {
    return {
        kind: "schema",
        type: "variant",
        reference: variant,
        expects: "Object",
        async: false,
        key,
        options,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                let outputDataset;
                let maxDiscriminatorPriority = 0;
                let invalidDiscriminatorKey = this.key;
                let expectedDiscriminators = [];
                const parseOptions = (variant2, allKeys)=>{
                    for (const schema of variant2.options){
                        if (schema.type === "variant") {
                            parseOptions(schema, new Set(allKeys).add(schema.key));
                        } else {
                            let keysAreValid = true;
                            let currentPriority = 0;
                            for (const currentKey of allKeys){
                                const discriminatorSchema = schema.entries[currentKey];
                                if (currentKey in input ? discriminatorSchema["~run"](// @ts-expect-error
                                {
                                    typed: false,
                                    value: input[currentKey]
                                }, config2).issues : discriminatorSchema.type !== "exact_optional" && discriminatorSchema.type !== "optional" && discriminatorSchema.type !== "nullish") {
                                    keysAreValid = false;
                                    if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {
                                        maxDiscriminatorPriority = currentPriority;
                                        invalidDiscriminatorKey = currentKey;
                                        expectedDiscriminators = [];
                                    }
                                    if (invalidDiscriminatorKey === currentKey) {
                                        expectedDiscriminators.push(schema.entries[currentKey].expects);
                                    }
                                    break;
                                }
                                currentPriority++;
                            }
                            if (keysAreValid) {
                                const optionDataset = schema["~run"]({
                                    value: input
                                }, config2);
                                if (!outputDataset || !outputDataset.typed && optionDataset.typed) {
                                    outputDataset = optionDataset;
                                }
                            }
                        }
                        if (outputDataset && !outputDataset.issues) {
                            break;
                        }
                    }
                };
                parseOptions(this, /* @__PURE__ */ new Set([
                    this.key
                ]));
                if (outputDataset) {
                    return outputDataset;
                }
                _addIssue(this, "type", dataset, config2, {
                    // @ts-expect-error
                    input: input[invalidDiscriminatorKey],
                    expected: _joinExpects(expectedDiscriminators, "|"),
                    path: [
                        {
                            type: "object",
                            origin: "value",
                            input,
                            key: invalidDiscriminatorKey,
                            // @ts-expect-error
                            value: input[invalidDiscriminatorKey]
                        }
                    ]
                });
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/variant/variantAsync.ts
// @__NO_SIDE_EFFECTS__
function variantAsync(key, options, message) {
    return {
        kind: "schema",
        type: "variant",
        reference: variantAsync,
        expects: "Object",
        async: true,
        key,
        options,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                let outputDataset;
                let maxDiscriminatorPriority = 0;
                let invalidDiscriminatorKey = this.key;
                let expectedDiscriminators = [];
                const parseOptions = async (variant2, allKeys)=>{
                    for (const schema of variant2.options){
                        if (schema.type === "variant") {
                            await parseOptions(schema, new Set(allKeys).add(schema.key));
                        } else {
                            let keysAreValid = true;
                            let currentPriority = 0;
                            for (const currentKey of allKeys){
                                const discriminatorSchema = schema.entries[currentKey];
                                if (currentKey in input ? (await discriminatorSchema["~run"](// @ts-expect-error
                                {
                                    typed: false,
                                    value: input[currentKey]
                                }, config2)).issues : discriminatorSchema.type !== "exact_optional" && discriminatorSchema.type !== "optional" && discriminatorSchema.type !== "nullish") {
                                    keysAreValid = false;
                                    if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {
                                        maxDiscriminatorPriority = currentPriority;
                                        invalidDiscriminatorKey = currentKey;
                                        expectedDiscriminators = [];
                                    }
                                    if (invalidDiscriminatorKey === currentKey) {
                                        expectedDiscriminators.push(schema.entries[currentKey].expects);
                                    }
                                    break;
                                }
                                currentPriority++;
                            }
                            if (keysAreValid) {
                                const optionDataset = await schema["~run"]({
                                    value: input
                                }, config2);
                                if (!outputDataset || !outputDataset.typed && optionDataset.typed) {
                                    outputDataset = optionDataset;
                                }
                            }
                        }
                        if (outputDataset && !outputDataset.issues) {
                            break;
                        }
                    }
                };
                await parseOptions(this, /* @__PURE__ */ new Set([
                    this.key
                ]));
                if (outputDataset) {
                    return outputDataset;
                }
                _addIssue(this, "type", dataset, config2, {
                    // @ts-expect-error
                    input: input[invalidDiscriminatorKey],
                    expected: _joinExpects(expectedDiscriminators, "|"),
                    path: [
                        {
                            type: "object",
                            origin: "value",
                            input,
                            key: invalidDiscriminatorKey,
                            // @ts-expect-error
                            value: input[invalidDiscriminatorKey]
                        }
                    ]
                });
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/void/void.ts
// @__NO_SIDE_EFFECTS__
function void_(message) {
    return {
        kind: "schema",
        type: "void",
        reference: void_,
        expects: "void",
        async: false,
        message,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            if (dataset.value === void 0) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/methods/keyof/keyof.ts
// @__NO_SIDE_EFFECTS__
function keyof(schema, message) {
    return picklist(Object.keys(schema.entries), message);
}
// src/methods/omit/omit.ts
// @__NO_SIDE_EFFECTS__
function omit(schema, keys) {
    const entries = {
        ...schema.entries
    };
    for (const key of keys){
        delete entries[key];
    }
    return {
        ...schema,
        entries,
        get "~standard" () {
            return _getStandardProps(this);
        }
    };
}
// src/methods/parse/parse.ts
function parse(schema, input, config2) {
    const dataset = schema["~run"]({
        value: input
    }, getGlobalConfig(config2));
    if (dataset.issues) {
        throw new ValiError(dataset.issues);
    }
    return dataset.value;
}
// src/methods/parse/parseAsync.ts
async function parseAsync(schema, input, config2) {
    const dataset = await schema["~run"]({
        value: input
    }, getGlobalConfig(config2));
    if (dataset.issues) {
        throw new ValiError(dataset.issues);
    }
    return dataset.value;
}
// src/methods/parser/parser.ts
// @__NO_SIDE_EFFECTS__
function parser(schema, config2) {
    const func = (input)=>parse(schema, input, config2);
    func.schema = schema;
    func.config = config2;
    return func;
}
// src/methods/parser/parserAsync.ts
// @__NO_SIDE_EFFECTS__
function parserAsync(schema, config2) {
    const func = (input)=>parseAsync(schema, input, config2);
    func.schema = schema;
    func.config = config2;
    return func;
}
// src/methods/partial/partial.ts
// @__NO_SIDE_EFFECTS__
function partial(schema, keys) {
    const entries = {};
    for(const key in schema.entries){
        entries[key] = !keys || keys.includes(key) ? optional(schema.entries[key]) : schema.entries[key];
    }
    return {
        ...schema,
        entries,
        get "~standard" () {
            return _getStandardProps(this);
        }
    };
}
// src/methods/partial/partialAsync.ts
// @__NO_SIDE_EFFECTS__
function partialAsync(schema, keys) {
    const entries = {};
    for(const key in schema.entries){
        entries[key] = !keys || keys.includes(key) ? optionalAsync(schema.entries[key]) : schema.entries[key];
    }
    return {
        ...schema,
        entries,
        get "~standard" () {
            return _getStandardProps(this);
        }
    };
}
// src/methods/pick/pick.ts
// @__NO_SIDE_EFFECTS__
function pick(schema, keys) {
    const entries = {};
    for (const key of keys){
        entries[key] = schema.entries[key];
    }
    return {
        ...schema,
        entries,
        get "~standard" () {
            return _getStandardProps(this);
        }
    };
}
// src/methods/pipe/pipe.ts
// @__NO_SIDE_EFFECTS__
function pipe(...pipe2) {
    return {
        ...pipe2[0],
        pipe: pipe2,
        get "~standard" () {
            return _getStandardProps(this);
        },
        "~run" (dataset, config2) {
            for (const item of pipe2){
                if (item.kind !== "metadata") {
                    if (dataset.issues && (item.kind === "schema" || item.kind === "transformation")) {
                        dataset.typed = false;
                        break;
                    }
                    if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {
                        dataset = item["~run"](dataset, config2);
                    }
                }
            }
            return dataset;
        }
    };
}
// src/methods/pipe/pipeAsync.ts
// @__NO_SIDE_EFFECTS__
function pipeAsync(...pipe2) {
    return {
        ...pipe2[0],
        pipe: pipe2,
        async: true,
        get "~standard" () {
            return _getStandardProps(this);
        },
        async "~run" (dataset, config2) {
            for (const item of pipe2){
                if (item.kind !== "metadata") {
                    if (dataset.issues && (item.kind === "schema" || item.kind === "transformation")) {
                        dataset.typed = false;
                        break;
                    }
                    if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {
                        dataset = await item["~run"](dataset, config2);
                    }
                }
            }
            return dataset;
        }
    };
}
// src/methods/required/required.ts
// @__NO_SIDE_EFFECTS__
function required(schema, arg2, arg3) {
    const keys = Array.isArray(arg2) ? arg2 : void 0;
    const message = Array.isArray(arg2) ? arg3 : arg2;
    const entries = {};
    for(const key in schema.entries){
        entries[key] = !keys || keys.includes(key) ? nonOptional(schema.entries[key], message) : schema.entries[key];
    }
    return {
        ...schema,
        entries,
        get "~standard" () {
            return _getStandardProps(this);
        }
    };
}
// src/methods/required/requiredAsync.ts
// @__NO_SIDE_EFFECTS__
function requiredAsync(schema, arg2, arg3) {
    const keys = Array.isArray(arg2) ? arg2 : void 0;
    const message = Array.isArray(arg2) ? arg3 : arg2;
    const entries = {};
    for(const key in schema.entries){
        entries[key] = !keys || keys.includes(key) ? nonOptionalAsync(schema.entries[key], message) : schema.entries[key];
    }
    return {
        ...schema,
        entries,
        get "~standard" () {
            return _getStandardProps(this);
        }
    };
}
// src/methods/safeParse/safeParse.ts
// @__NO_SIDE_EFFECTS__
function safeParse(schema, input, config2) {
    const dataset = schema["~run"]({
        value: input
    }, getGlobalConfig(config2));
    return {
        typed: dataset.typed,
        success: !dataset.issues,
        output: dataset.value,
        issues: dataset.issues
    };
}
// src/methods/safeParse/safeParseAsync.ts
// @__NO_SIDE_EFFECTS__
async function safeParseAsync(schema, input, config2) {
    const dataset = await schema["~run"]({
        value: input
    }, getGlobalConfig(config2));
    return {
        typed: dataset.typed,
        success: !dataset.issues,
        output: dataset.value,
        issues: dataset.issues
    };
}
// src/methods/safeParser/safeParser.ts
// @__NO_SIDE_EFFECTS__
function safeParser(schema, config2) {
    const func = (input)=>safeParse(schema, input, config2);
    func.schema = schema;
    func.config = config2;
    return func;
}
// src/methods/safeParser/safeParserAsync.ts
// @__NO_SIDE_EFFECTS__
function safeParserAsync(schema, config2) {
    const func = (input)=>safeParseAsync(schema, input, config2);
    func.schema = schema;
    func.config = config2;
    return func;
}
// src/methods/unwrap/unwrap.ts
// @__NO_SIDE_EFFECTS__
function unwrap(schema) {
    return schema.wrapped;
}
;
}}),
"[project]/node_modules/@sanity/visual-editing-csm/dist/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createDataAttribute": (()=>createDataAttribute),
    "decodeSanityNodeData": (()=>decodeSanityNodeData),
    "encodeSanityNodeData": (()=>encodeSanityNodeData),
    "pathToUrlString": (()=>pathToUrlString),
    "urlStringToPath": (()=>urlStringToPath)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/client/dist/_chunks-es/resolveEditInfo.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/valibot/dist/index.js [app-ssr] (ecmascript)");
;
;
const lengthyStr$1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pipe"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["string"])(), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["minLength"])(1)), optionalLengthyStr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["optional"])(lengthyStr$1), sanityNodeSchema = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["object"])({
    baseUrl: lengthyStr$1,
    dataset: optionalLengthyStr,
    id: lengthyStr$1,
    path: lengthyStr$1,
    projectId: optionalLengthyStr,
    tool: optionalLengthyStr,
    type: optionalLengthyStr,
    workspace: optionalLengthyStr
});
function isValidSanityNode(node) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["is"])(sanityNodeSchema, node);
}
function isArray(value) {
    return value !== null && Array.isArray(value);
}
function pathToUrlString(path) {
    let str = "";
    for (const segment of path){
        if (typeof segment == "string") {
            str && (str += "."), str += segment;
            continue;
        }
        if (typeof segment == "number") {
            str && (str += ":"), str += `${segment}`;
            continue;
        }
        if (isArray(segment)) {
            str && (str += ":"), str += `${segment.join(",")}}`;
            continue;
        }
        if (segment._key) {
            str && (str += ":"), str += `${segment._key}`;
            continue;
        }
    }
    return str;
}
function encodeSanityNodeData(node) {
    const { id: _id, path, baseUrl, tool, workspace, type } = node;
    return isValidSanityNode(node) ? [
        [
            "id",
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getPublishedId"])(_id)
        ],
        [
            "type",
            type
        ],
        [
            "path",
            pathToUrlString(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["studioPath"].fromString(path))
        ],
        [
            "base",
            encodeURIComponent(baseUrl)
        ],
        [
            "workspace",
            workspace
        ],
        [
            "tool",
            tool
        ]
    ].filter(([, value])=>!!value).map((part)=>part.join("=")).join(";") : void 0;
}
function createDataAttribute(props) {
    function normalizePath(path) {
        return path ? typeof path == "string" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["studioPath"].fromString(path) : path : [];
    }
    function toString(props2) {
        if (!props2.id) throw new Error("`id` is required to create a data attribute");
        if (!props2.type) throw new Error("`type` is required to create a data attribute");
        if (!props2.path || !props2.path.length) throw new Error("`path` is required to create a data attribute");
        const attrs = {
            baseUrl: props2.baseUrl || "/",
            workspace: props2.workspace,
            tool: props2.tool,
            type: props2.type,
            id: props2.id,
            path: typeof props2.path == "string" ? props2.path : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["studioPath"].toString(props2.path)
        };
        return encodeSanityNodeData(attrs);
    }
    const DataAttribute = (path)=>toString({
            ...props,
            path: [
                ...normalizePath(props.path),
                ...normalizePath(path)
            ]
        });
    return DataAttribute.toString = function() {
        return toString(props);
    }, DataAttribute.combine = function(attrs) {
        return createDataAttribute({
            ...props,
            ...attrs
        });
    }, DataAttribute.scope = function(path) {
        return createDataAttribute({
            ...props,
            path: [
                ...normalizePath(props.path),
                ...normalizePath(path)
            ]
        });
    }, DataAttribute;
}
const RE_SEGMENT_WITH_INDEX = /^([\w-]+):(0|[1-9][0-9]*)$/, RE_SEGMENT_WITH_TUPLE = /^([\w-]+):([0-9]+),([0-9]+)$/, RE_SEGMENT_WITH_KEY = /^([\w-]+):([\w-]+)$/;
function urlStringToPath(str) {
    const path = [];
    for (const segment of str.split(".")){
        const withIndex = RE_SEGMENT_WITH_INDEX.exec(segment);
        if (withIndex) {
            path.push(withIndex[1], Number(withIndex[2]));
            continue;
        }
        const withTuple = RE_SEGMENT_WITH_TUPLE.exec(segment);
        if (withTuple) {
            path.push(withTuple[1], [
                Number(withTuple[2]),
                Number(withTuple[3])
            ]);
            continue;
        }
        const withKey = RE_SEGMENT_WITH_KEY.exec(segment);
        if (withKey) {
            path.push(withKey[1], {
                _key: withKey[2]
            });
            continue;
        }
        path.push(segment);
    }
    return path;
}
const lengthyStr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pipe"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["string"])(), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["minLength"])(1)), sanityLegacyNodeSchema = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["object"])({
    origin: lengthyStr,
    href: lengthyStr,
    data: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["optional"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["record"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["string"])(), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unknown"])()))
});
function decodeSanityString(str) {
    const data = str.split(";").reduce((acc, segment)=>{
        const [key, value] = segment.split("=");
        if (!key || segment.includes("=") && !value) return acc;
        switch(key){
            case "id":
                acc.id = value;
                break;
            case "type":
                acc.type = value;
                break;
            case "path":
                acc.path = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["studioPath"].toString(urlStringToPath(value));
                break;
            case "base":
                acc.baseUrl = decodeURIComponent(value);
                break;
            case "tool":
                acc.tool = value;
                break;
            case "workspace":
                acc.workspace = value;
                break;
            case "projectId":
                acc.projectId = value;
                break;
            case "dataset":
                acc.dataset = value;
                break;
        }
        return acc;
    }, {});
    if (isValidSanityNode(data)) return data;
}
function decodeSanityObject(data) {
    const sanityNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["safeParse"])(sanityNodeSchema, data);
    if (sanityNode.success) return sanityNode.output;
    const sanityLegacyNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["safeParse"])(sanityLegacyNodeSchema, data);
    if (sanityLegacyNode.success) try {
        const url = new URL(sanityLegacyNode.output.href, typeof document > "u" ? "https://example.com" : location.origin);
        return url.searchParams.size > 0 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"])(sanityNodeSchema, Object.fromEntries(url.searchParams.entries())) : sanityLegacyNode.output;
    } catch (err) {
        return console.error("Failed to parse sanity node", err), sanityLegacyNode.output;
    }
}
function decodeSanityNodeData(data) {
    if (typeof data == "object" && data !== null) return decodeSanityObject(data);
    try {
        const obj = JSON.parse(data);
        return decodeSanityObject(obj);
    } catch  {
        return decodeSanityString(data);
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/react-compiler-runtime/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @lightSyntaxTransform
 * @noflow
 * @nolint
 * @preventMunge
 * @preserve-invariant-messages
 */ "use no memo";
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
// src/index.ts
var index_exports = {};
__export(index_exports, {
    $dispatcherGuard: ()=>$dispatcherGuard,
    $makeReadOnly: ()=>$makeReadOnly,
    $reset: ()=>$reset,
    $structuralCheck: ()=>$structuralCheck,
    c: ()=>c,
    clearRenderCounterRegistry: ()=>clearRenderCounterRegistry,
    renderCounterRegistry: ()=>renderCounterRegistry,
    useRenderCounter: ()=>useRenderCounter
});
module.exports = __toCommonJS(index_exports);
var React = __toESM(__turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"));
var { useRef, useEffect, isValidElement } = React;
var _a;
var ReactSecretInternals = //@ts-ignore
(_a = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE) != null ? _a : React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
var $empty = Symbol.for("react.memo_cache_sentinel");
var _a2;
var c = // @ts-expect-error
typeof ((_a2 = React.__COMPILER_RUNTIME) == null ? void 0 : _a2.c) === "function" ? // @ts-expect-error
React.__COMPILER_RUNTIME.c : function c2(size) {
    return React.useMemo(()=>{
        const $ = new Array(size);
        for(let ii = 0; ii < size; ii++){
            $[ii] = $empty;
        }
        $[$empty] = true;
        return $;
    }, []);
};
var LazyGuardDispatcher = {};
[
    "readContext",
    "useCallback",
    "useContext",
    "useEffect",
    "useImperativeHandle",
    "useInsertionEffect",
    "useLayoutEffect",
    "useMemo",
    "useReducer",
    "useRef",
    "useState",
    "useDebugValue",
    "useDeferredValue",
    "useTransition",
    "useMutableSource",
    "useSyncExternalStore",
    "useId",
    "unstable_isNewReconciler",
    "getCacheSignal",
    "getCacheForType",
    "useCacheRefresh"
].forEach((name)=>{
    LazyGuardDispatcher[name] = ()=>{
        throw new Error(`[React] Unexpected React hook call (${name}) from a React compiled function. Check that all hooks are called directly and named according to convention ('use[A-Z]') `);
    };
});
var originalDispatcher = null;
LazyGuardDispatcher["useMemoCache"] = (count)=>{
    if (originalDispatcher == null) {
        throw new Error("React Compiler internal invariant violation: unexpected null dispatcher");
    } else {
        return originalDispatcher.useMemoCache(count);
    }
};
function setCurrent(newDispatcher) {
    ReactSecretInternals.ReactCurrentDispatcher.current = newDispatcher;
    return ReactSecretInternals.ReactCurrentDispatcher.current;
}
var guardFrames = [];
function $dispatcherGuard(kind) {
    const curr = ReactSecretInternals.ReactCurrentDispatcher.current;
    if (kind === 0 /* PushGuardContext */ ) {
        guardFrames.push(curr);
        if (guardFrames.length === 1) {
            originalDispatcher = curr;
        }
        if (curr === LazyGuardDispatcher) {
            throw new Error(`[React] Unexpected call to custom hook or component from a React compiled function. Check that (1) all hooks are called directly and named according to convention ('use[A-Z]') and (2) components are returned as JSX instead of being directly invoked.`);
        }
        setCurrent(LazyGuardDispatcher);
    } else if (kind === 1 /* PopGuardContext */ ) {
        const lastFrame = guardFrames.pop();
        if (lastFrame == null) {
            throw new Error("React Compiler internal error: unexpected null in guard stack");
        }
        if (guardFrames.length === 0) {
            originalDispatcher = null;
        }
        setCurrent(lastFrame);
    } else if (kind === 2 /* PushExpectHook */ ) {
        guardFrames.push(curr);
        setCurrent(originalDispatcher);
    } else if (kind === 3 /* PopExpectHook */ ) {
        const lastFrame = guardFrames.pop();
        if (lastFrame == null) {
            throw new Error("React Compiler internal error: unexpected null in guard stack");
        }
        setCurrent(lastFrame);
    } else {
        throw new Error("React Compiler internal error: unreachable block" + kind);
    }
}
function $reset($) {
    for(let ii = 0; ii < $.length; ii++){
        $[ii] = $empty;
    }
}
function $makeReadOnly() {
    throw new Error("TODO: implement $makeReadOnly in react-compiler-runtime");
}
var renderCounterRegistry = /* @__PURE__ */ new Map();
function clearRenderCounterRegistry() {
    for (const counters of renderCounterRegistry.values()){
        counters.forEach((counter)=>{
            counter.count = 0;
        });
    }
}
function registerRenderCounter(name, val) {
    let counters = renderCounterRegistry.get(name);
    if (counters == null) {
        counters = /* @__PURE__ */ new Set();
        renderCounterRegistry.set(name, counters);
    }
    counters.add(val);
}
function removeRenderCounter(name, val) {
    const counters = renderCounterRegistry.get(name);
    if (counters == null) {
        return;
    }
    counters.delete(val);
}
function useRenderCounter(name) {
    const val = useRef(null);
    if (val.current != null) {
        val.current.count += 1;
    }
    useEffect(()=>{
        if (val.current == null) {
            const counter = {
                count: 0
            };
            registerRenderCounter(name, counter);
            val.current = counter;
        }
        return ()=>{
            if (val.current !== null) {
                removeRenderCounter(name, val.current);
            }
        };
    });
}
var seenErrors = /* @__PURE__ */ new Set();
function $structuralCheck(oldValue, newValue, variableName, fnName, kind, loc) {
    function error(l, r, path, depth) {
        const str = `${fnName}:${loc} [${kind}] ${variableName}${path} changed from ${l} to ${r} at depth ${depth}`;
        if (seenErrors.has(str)) {
            return;
        }
        seenErrors.add(str);
        console.error(str);
    }
    const depthLimit = 2;
    function recur(oldValue2, newValue2, path, depth) {
        if (depth > depthLimit) {
            return;
        } else if (oldValue2 === newValue2) {
            return;
        } else if (typeof oldValue2 !== typeof newValue2) {
            error(`type ${typeof oldValue2}`, `type ${typeof newValue2}`, path, depth);
        } else if (typeof oldValue2 === "object") {
            const oldArray = Array.isArray(oldValue2);
            const newArray = Array.isArray(newValue2);
            if (oldValue2 === null && newValue2 !== null) {
                error("null", `type ${typeof newValue2}`, path, depth);
            } else if (newValue2 === null) {
                error(`type ${typeof oldValue2}`, "null", path, depth);
            } else if (oldValue2 instanceof Map) {
                if (!(newValue2 instanceof Map)) {
                    error(`Map instance`, `other value`, path, depth);
                } else if (oldValue2.size !== newValue2.size) {
                    error(`Map instance with size ${oldValue2.size}`, `Map instance with size ${newValue2.size}`, path, depth);
                } else {
                    for (const [k, v] of oldValue2){
                        if (!newValue2.has(k)) {
                            error(`Map instance with key ${k}`, `Map instance without key ${k}`, path, depth);
                        } else {
                            recur(v, newValue2.get(k), `${path}.get(${k})`, depth + 1);
                        }
                    }
                }
            } else if (newValue2 instanceof Map) {
                error("other value", `Map instance`, path, depth);
            } else if (oldValue2 instanceof Set) {
                if (!(newValue2 instanceof Set)) {
                    error(`Set instance`, `other value`, path, depth);
                } else if (oldValue2.size !== newValue2.size) {
                    error(`Set instance with size ${oldValue2.size}`, `Set instance with size ${newValue2.size}`, path, depth);
                } else {
                    for (const v of newValue2){
                        if (!oldValue2.has(v)) {
                            error(`Set instance without element ${v}`, `Set instance with element ${v}`, path, depth);
                        }
                    }
                }
            } else if (newValue2 instanceof Set) {
                error("other value", `Set instance`, path, depth);
            } else if (oldArray || newArray) {
                if (oldArray !== newArray) {
                    error(`type ${oldArray ? "array" : "object"}`, `type ${newArray ? "array" : "object"}`, path, depth);
                } else if (oldValue2.length !== newValue2.length) {
                    error(`array with length ${oldValue2.length}`, `array with length ${newValue2.length}`, path, depth);
                } else {
                    for(let ii = 0; ii < oldValue2.length; ii++){
                        recur(oldValue2[ii], newValue2[ii], `${path}[${ii}]`, depth + 1);
                    }
                }
            } else if (isValidElement(oldValue2) || isValidElement(newValue2)) {
                if (isValidElement(oldValue2) !== isValidElement(newValue2)) {
                    error(`type ${isValidElement(oldValue2) ? "React element" : "object"}`, `type ${isValidElement(newValue2) ? "React element" : "object"}`, path, depth);
                } else if (oldValue2.type !== newValue2.type) {
                    error(`React element of type ${oldValue2.type}`, `React element of type ${newValue2.type}`, path, depth);
                } else {
                    recur(oldValue2.props, newValue2.props, `[props of ${path}]`, depth + 1);
                }
            } else {
                for(const key in newValue2){
                    if (!(key in oldValue2)) {
                        error(`object without key ${key}`, `object with key ${key}`, path, depth);
                    }
                }
                for(const key in oldValue2){
                    if (!(key in newValue2)) {
                        error(`object with key ${key}`, `object without key ${key}`, path, depth);
                    } else {
                        recur(oldValue2[key], newValue2[key], `${path}.${key}`, depth + 1);
                    }
                }
            }
        } else if (typeof oldValue2 === "function") {
            return;
        } else if (isNaN(oldValue2) || isNaN(newValue2)) {
            if (isNaN(oldValue2) !== isNaN(newValue2)) {
                error(`${isNaN(oldValue2) ? "NaN" : "non-NaN value"}`, `${isNaN(newValue2) ? "NaN" : "non-NaN value"}`, path, depth);
            }
        } else if (oldValue2 !== newValue2) {
            error(oldValue2, newValue2, path, depth);
        }
    }
    recur(oldValue, newValue, "", 0);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    $dispatcherGuard,
    $makeReadOnly,
    $reset,
    $structuralCheck,
    c,
    clearRenderCounterRegistry,
    renderCounterRegistry,
    useRenderCounter
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/next-sanity/node_modules/@sanity/visual-editing/dist/_chunks-es/context.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "actor": (()=>actor),
    "emptyActor": (()=>emptyActor),
    "isEmptyActor": (()=>isEmptyActor),
    "listeners": (()=>listeners),
    "setActor": (()=>setActor)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$actors$2f$dist$2f$xstate$2d$actors$2e$development$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/xstate/actors/dist/xstate-actors.development.esm.js [app-ssr] (ecmascript)");
;
const emptyActor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$actors$2f$dist$2f$xstate$2d$actors$2e$development$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createEmptyActor"])();
let actor = emptyActor;
const listeners = /* @__PURE__ */ new Set();
function isEmptyActor(actor2) {
    return actor2 === emptyActor;
}
function setActor(nextActor) {
    actor = nextActor;
    for (const onActorChange of listeners)onActorChange();
}
;
 //# sourceMappingURL=context.js.map
}}),
"[project]/node_modules/next-sanity/node_modules/@sanity/mutate/dist/_chunks-es/parse.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "parse": (()=>parse)
});
function parse(path) {
    return path.split(/[[.\]]/g).filter(Boolean).map((seg)=>seg.includes("==") ? parseSegment(seg) : coerce(seg));
}
const IS_NUMERIC = /^-?\d+$/;
function unquote(str) {
    return str.replace(/^['"]/, "").replace(/['"]$/, "");
}
function parseSegment(segment) {
    const [key, value] = segment.split("==");
    if (key !== "_key") throw new Error(`Currently only "_key" is supported as path segment. Found ${key}`);
    if (typeof value > "u") throw new Error('Invalid path segment, expected `key=="value"`');
    return {
        _key: unquote(value)
    };
}
function coerce(segment) {
    return IS_NUMERIC.test(segment) ? Number(segment) : segment;
}
;
 //# sourceMappingURL=parse.js.map
}}),
"[project]/node_modules/next-sanity/node_modules/@sanity/mutate/dist/_chunks-es/stringify.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "isArrayElement": (()=>isArrayElement),
    "isElementEqual": (()=>isElementEqual),
    "isEqual": (()=>isEqual),
    "isIndexElement": (()=>isIndexElement),
    "isKeyElement": (()=>isKeyElement),
    "isKeyedElement": (()=>isKeyedElement),
    "isPropertyElement": (()=>isPropertyElement),
    "startsWith": (()=>startsWith),
    "stringify": (()=>stringify)
});
function safeGetElementAt(array, index) {
    if (index < 0 || index >= array.length) throw new Error("Index out of bounds");
    return array[index];
}
function startsWith(parentPath, path) {
    return parentPath.length <= path.length && parentPath.every((segment, i)=>isElementEqual(segment, safeGetElementAt(path, i)));
}
function isEqual(path, otherPath) {
    return path.length === otherPath.length && path.every((segment, i)=>isElementEqual(segment, safeGetElementAt(path, i)));
}
function isElementEqual(segmentA, segmentB) {
    return isKeyElement(segmentA) && isKeyElement(segmentB) ? segmentA._key === segmentB._key : isIndexElement(segmentA) ? Number(segmentA) === Number(segmentB) : segmentA === segmentB;
}
function isKeyElement(segment) {
    return typeof segment?._key == "string";
}
function isIndexElement(segment) {
    return typeof segment == "number";
}
function isKeyedElement(element) {
    return typeof element == "object" && "_key" in element && typeof element._key == "string";
}
function isArrayElement(element) {
    return typeof element == "number" || isKeyedElement(element);
}
function isPropertyElement(element) {
    return typeof element == "string";
}
const IS_DOTTABLE = /^[a-z_$]+/;
function stringifySegment(segment, hasLeading) {
    return Array.isArray(segment) ? `[${segment[0]}:${segment[1] || ""}]` : typeof segment == "number" ? `[${segment}]` : isKeyedElement(segment) ? `[_key==${JSON.stringify(segment._key)}]` : typeof segment == "string" && IS_DOTTABLE.test(segment) ? hasLeading ? segment : `.${segment}` : `['${segment}']`;
}
function stringify(pathArray) {
    return pathArray.map((segment, i)=>stringifySegment(segment, i === 0)).join("");
}
;
 //# sourceMappingURL=stringify.js.map
}}),
"[project]/node_modules/next-sanity/node_modules/@sanity/mutate/dist/_chunks-es/decode.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "decode": (()=>decode),
    "decodeAll": (()=>decodeAll)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next-sanity/node_modules/@sanity/mutate/dist/_chunks-es/parse.js [app-ssr] (ecmascript)");
;
function isCreateIfNotExistsMutation(sanityMutation) {
    return "createIfNotExists" in sanityMutation;
}
function isCreateOrReplaceMutation(sanityMutation) {
    return "createOrReplace" in sanityMutation;
}
function isCreateMutation(sanityMutation) {
    return "create" in sanityMutation;
}
function isDeleteMutation(sanityMutation) {
    return "delete" in sanityMutation;
}
function isPatchMutation(sanityMutation) {
    return "patch" in sanityMutation;
}
function isSetPatch(sanityPatch) {
    return "set" in sanityPatch;
}
function isSetIfMissingPatch(sanityPatch) {
    return "setIfMissing" in sanityPatch;
}
function isUnsetPatch(sanityPatch) {
    return "unset" in sanityPatch;
}
function isIncPatch(sanityPatch) {
    return "inc" in sanityPatch;
}
function isDecPatch(sanityPatch) {
    return "inc" in sanityPatch;
}
function isInsertPatch(sanityPatch) {
    return "insert" in sanityPatch;
}
function decodeAll(sanityMutations) {
    return sanityMutations.map(decodeMutation);
}
function decode(encodedMutation) {
    return decodeMutation(encodedMutation);
}
function decodeMutation(encodedMutation) {
    if (isCreateIfNotExistsMutation(encodedMutation)) return {
        type: "createIfNotExists",
        document: encodedMutation.createIfNotExists
    };
    if (isCreateOrReplaceMutation(encodedMutation)) return {
        type: "createOrReplace",
        document: encodedMutation.createOrReplace
    };
    if (isCreateMutation(encodedMutation)) return {
        type: "create",
        document: encodedMutation.create
    };
    if (isDeleteMutation(encodedMutation)) return {
        id: encodedMutation.delete.id,
        type: "delete"
    };
    if (isPatchMutation(encodedMutation)) return {
        type: "patch",
        id: encodedMutation.patch.id,
        patches: decodeNodePatches(encodedMutation.patch)
    };
    throw new Error(`Unknown mutation: ${JSON.stringify(encodedMutation)}`);
}
const POSITION_KEYS = [
    "before",
    "replace",
    "after"
];
function getInsertPosition(insert) {
    const positions = POSITION_KEYS.filter((k)=>k in insert);
    if (positions.length > 1) throw new Error(`Insert patch is ambiguous. Should only contain one of: ${POSITION_KEYS.join(", ")}, instead found ${positions.join(", ")}`);
    return positions[0];
}
function decodeNodePatches(patch) {
    return [
        ...getSetPatches(patch),
        ...getSetIfMissingPatches(patch),
        ...getUnsetPatches(patch),
        ...getIncPatches(patch),
        ...getDecPatches(patch),
        ...getInsertPatches(patch)
    ];
}
function getSetPatches(patch) {
    return isSetPatch(patch) ? Object.keys(patch.set).map((path)=>({
            path: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"])(path),
            op: {
                type: "set",
                value: patch.set[path]
            }
        })) : [];
}
function getSetIfMissingPatches(patch) {
    return isSetIfMissingPatch(patch) ? Object.keys(patch.setIfMissing).map((path)=>({
            path: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"])(path),
            op: {
                type: "setIfMissing",
                value: patch.setIfMissing[path]
            }
        })) : [];
}
function getUnsetPatches(patch) {
    return isUnsetPatch(patch) ? patch.unset.map((path)=>({
            path: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"])(path),
            op: {
                type: "unset"
            }
        })) : [];
}
function getIncPatches(patch) {
    return isIncPatch(patch) ? Object.keys(patch.inc).map((path)=>({
            path: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"])(path),
            op: {
                type: "inc",
                amount: patch.inc[path]
            }
        })) : [];
}
function getDecPatches(patch) {
    return isDecPatch(patch) ? Object.keys(patch.dec).map((path)=>({
            path: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"])(path),
            op: {
                type: "dec",
                amount: patch.dec[path]
            }
        })) : [];
}
function getInsertPatches(patch) {
    if (!isInsertPatch(patch)) return [];
    const position = getInsertPosition(patch.insert);
    if (!position) throw new Error("Insert patch missing position");
    const path = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"])(patch.insert[position]), referenceItem = path.pop(), op = position === "replace" ? {
        type: "insert",
        position,
        referenceItem,
        items: patch.insert.items
    } : {
        type: "insert",
        position,
        referenceItem,
        items: patch.insert.items
    };
    return [
        {
            path,
            op
        }
    ];
}
;
 //# sourceMappingURL=decode.js.map
}}),
"[project]/node_modules/next-sanity/node_modules/@sanity/mutate/dist/_chunks-es/encode.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "encode": (()=>encode),
    "encodeAll": (()=>encodeAll),
    "encodeMutation": (()=>encodeMutation),
    "encodeTransaction": (()=>encodeTransaction)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next-sanity/node_modules/@sanity/mutate/dist/_chunks-es/stringify.js [app-ssr] (ecmascript)");
;
function encode(mutation) {
    return encodeMutation(mutation);
}
function encodeAll(mutations) {
    return mutations.flatMap(encode);
}
function encodeTransaction(transaction) {
    return {
        transactionId: transaction.id,
        mutations: encodeAll(transaction.mutations)
    };
}
function encodeMutation(mutation) {
    if (mutation.type === "create" || mutation.type === "createIfNotExists" || mutation.type === "createOrReplace") return {
        [mutation.type]: mutation.document
    };
    if (mutation.type === "delete") return {
        delete: {
            id: mutation.id
        }
    };
    const ifRevisionID = mutation.options?.ifRevision;
    return mutation.patches.map((patch)=>({
            patch: {
                id: mutation.id,
                ...ifRevisionID && {
                    ifRevisionID
                },
                ...patchToSanity(patch)
            }
        }));
}
function patchToSanity(patch) {
    const { path, op } = patch;
    if (op.type === "unset") return {
        unset: [
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringify"])(path)
        ]
    };
    if (op.type === "insert") return {
        insert: {
            [op.position]: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringify"])([
                ...path,
                op.referenceItem
            ]),
            items: op.items
        }
    };
    if (op.type === "diffMatchPatch") return {
        diffMatchPatch: {
            [(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringify"])(path)]: op.value
        }
    };
    if (op.type === "inc") return {
        inc: {
            [(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringify"])(path)]: op.amount
        }
    };
    if (op.type === "dec") return {
        dec: {
            [(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringify"])(path)]: op.amount
        }
    };
    if (op.type === "set" || op.type === "setIfMissing") return {
        [op.type]: {
            [(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringify"])(path)]: op.value
        }
    };
    if (op.type === "truncate") {
        const range = [
            op.startIndex,
            typeof op.endIndex == "number" ? op.endIndex : ""
        ].join(":");
        return {
            unset: [
                `${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringify"])(path)}[${range}]`
            ]
        };
    }
    if (op.type === "upsert") return {
        unset: op.items.map((item)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringify"])([
                ...path,
                {
                    _key: item._key
                }
            ])),
        insert: {
            [op.position]: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringify"])([
                ...path,
                op.referenceItem
            ]),
            items: op.items
        }
    };
    if (op.type === "assign") return {
        set: Object.fromEntries(Object.keys(op.value).map((key)=>[
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringify"])(path.concat(key)),
                op.value[key]
            ]))
    };
    if (op.type === "unassign") return {
        unset: op.keys.map((key)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringify"])(path.concat(key)))
    };
    if (op.type === "replace") return {
        insert: {
            replace: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringify"])(path.concat(op.referenceItem)),
            items: op.items
        }
    };
    if (op.type === "remove") return {
        unset: [
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringify"])(path.concat(op.referenceItem))
        ]
    };
    throw new Error(`Unknown operation type ${op.type}`);
}
;
 //# sourceMappingURL=encode.js.map
}}),
"[project]/node_modules/next-sanity/node_modules/@sanity/mutate/dist/_chunks-es/isObject.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "isObject": (()=>isObject)
});
function isObject(val) {
    return val !== null && typeof val == "object" && !Array.isArray(val);
}
;
 //# sourceMappingURL=isObject.js.map
}}),
"[project]/node_modules/next-sanity/node_modules/@sanity/mutate/dist/_chunks-es/arrify.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "arrify": (()=>arrify)
});
function arrify(val) {
    return Array.isArray(val) ? val : [
        val
    ];
}
;
 //# sourceMappingURL=arrify.js.map
}}),
"[project]/node_modules/next-sanity/node_modules/@sanity/mutate/dist/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "CompactEncoder": (()=>index$1),
    "CompactFormatter": (()=>compact),
    "SanityEncoder": (()=>index),
    "append": (()=>append),
    "assign": (()=>assign),
    "at": (()=>at),
    "autoKeys": (()=>autoKeys),
    "create": (()=>create),
    "createIfNotExists": (()=>createIfNotExists),
    "createOrReplace": (()=>createOrReplace),
    "dec": (()=>dec),
    "del": (()=>del),
    "delete_": (()=>delete_),
    "destroy": (()=>destroy),
    "diffMatchPatch": (()=>diffMatchPatch),
    "inc": (()=>inc),
    "insert": (()=>insert),
    "insertAfter": (()=>insertAfter),
    "insertBefore": (()=>insertBefore),
    "patch": (()=>patch),
    "prepend": (()=>prepend),
    "remove": (()=>remove),
    "replace": (()=>replace),
    "set": (()=>set),
    "setIfMissing": (()=>setIfMissing),
    "truncate": (()=>truncate),
    "unassign": (()=>unassign),
    "unset": (()=>unset),
    "upsert": (()=>upsert)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next-sanity/node_modules/@sanity/mutate/dist/_chunks-es/parse.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next-sanity/node_modules/@sanity/mutate/dist/_chunks-es/stringify.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$decode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next-sanity/node_modules/@sanity/mutate/dist/_chunks-es/decode.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$encode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next-sanity/node_modules/@sanity/mutate/dist/_chunks-es/encode.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$isObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next-sanity/node_modules/@sanity/mutate/dist/_chunks-es/isObject.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$arrify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next-sanity/node_modules/@sanity/mutate/dist/_chunks-es/arrify.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
function decode(mutations) {
    return mutations.map(decodeMutation);
}
function decodeMutation(mutation) {
    const [type] = mutation;
    if (type === "delete") {
        const [, id] = mutation;
        return {
            id,
            type
        };
    } else if (type === "create") {
        const [, document] = mutation;
        return {
            type,
            document
        };
    } else if (type === "createIfNotExists") {
        const [, document] = mutation;
        return {
            type,
            document
        };
    } else if (type === "createOrReplace") {
        const [, document] = mutation;
        return {
            type,
            document
        };
    } else if (type === "patch") return decodePatchMutation(mutation);
    throw new Error(`Unrecognized mutation: ${JSON.stringify(mutation)}`);
}
function decodePatchMutation(mutation) {
    const [, type, id, serializedPath, , revisionId] = mutation, path = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"])(serializedPath);
    if (type === "dec" || type === "inc") {
        const [, , , , [amount]] = mutation;
        return {
            type: "patch",
            id,
            patches: [
                {
                    path,
                    op: {
                        type: "inc",
                        amount
                    }
                }
            ],
            ...createOpts(revisionId)
        };
    }
    if (type === "unset") return {
        type: "patch",
        id,
        patches: [
            {
                path,
                op: {
                    type: "unset"
                }
            }
        ],
        ...createOpts(revisionId)
    };
    if (type === "insert") {
        const [, , , , [position, ref, items]] = mutation;
        return {
            type: "patch",
            id,
            patches: [
                {
                    path,
                    op: {
                        type: "insert",
                        position,
                        items,
                        referenceItem: typeof ref == "string" ? {
                            _key: ref
                        } : ref
                    }
                }
            ],
            ...createOpts(revisionId)
        };
    }
    if (type === "set") {
        const [, , , , [value]] = mutation;
        return {
            type: "patch",
            id,
            patches: [
                {
                    path,
                    op: {
                        type: "set",
                        value
                    }
                }
            ],
            ...createOpts(revisionId)
        };
    }
    if (type === "setIfMissing") {
        const [, , , , [value]] = mutation;
        return {
            type: "patch",
            id,
            patches: [
                {
                    path,
                    op: {
                        type: "setIfMissing",
                        value
                    }
                }
            ],
            ...createOpts(revisionId)
        };
    }
    if (type === "diffMatchPatch") {
        const [, , , , [value]] = mutation;
        return {
            type: "patch",
            id,
            patches: [
                {
                    path,
                    op: {
                        type: "diffMatchPatch",
                        value
                    }
                }
            ],
            ...createOpts(revisionId)
        };
    }
    if (type === "truncate") {
        const [, , , , [startIndex, endIndex]] = mutation;
        return {
            type: "patch",
            id,
            patches: [
                {
                    path,
                    op: {
                        type: "truncate",
                        startIndex,
                        endIndex
                    }
                }
            ],
            ...createOpts(revisionId)
        };
    }
    if (type === "assign") {
        const [, , , , [value]] = mutation;
        return {
            type: "patch",
            id,
            patches: [
                {
                    path,
                    op: {
                        type: "assign",
                        value
                    }
                }
            ],
            ...createOpts(revisionId)
        };
    }
    if (type === "replace") {
        const [, , , , [ref, items]] = mutation;
        return {
            type: "patch",
            id,
            patches: [
                {
                    path,
                    op: {
                        type: "replace",
                        items,
                        referenceItem: decodeItemRef(ref)
                    }
                }
            ],
            ...createOpts(revisionId)
        };
    }
    if (type === "upsert") {
        const [, , , , [position, referenceItem, items]] = mutation;
        return {
            type: "patch",
            id,
            patches: [
                {
                    path,
                    op: {
                        type: "upsert",
                        items,
                        referenceItem: decodeItemRef(referenceItem),
                        position
                    }
                }
            ],
            ...createOpts(revisionId)
        };
    }
    throw new Error(`Invalid mutation type: ${type}`);
}
function decodeItemRef(ref) {
    return typeof ref == "string" ? {
        _key: ref
    } : ref;
}
function createOpts(revisionId) {
    return revisionId ? {
        options: {
            ifRevision: revisionId
        }
    } : null;
}
function encode(mutations) {
    return mutations.flatMap((m)=>encodeMutation$1(m));
}
function encodeItemRef$1(ref) {
    return typeof ref == "number" ? ref : ref._key;
}
function encodeMutation$1(mutation) {
    if (mutation.type === "create" || mutation.type === "createIfNotExists" || mutation.type === "createOrReplace") return [
        [
            mutation.type,
            mutation.document
        ]
    ];
    if (mutation.type === "delete") return [
        [
            "delete",
            mutation.id
        ]
    ];
    if (mutation.type === "patch") return mutation.patches.map((patch2)=>maybeAddRevision(mutation.options?.ifRevision, encodePatchMutation(mutation.id, patch2)));
    throw new Error(`Invalid mutation type: ${mutation.type}`);
}
function encodePatchMutation(id, patch2) {
    const { op } = patch2, path = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringify"])(patch2.path);
    if (op.type === "unset") return [
        "patch",
        "unset",
        id,
        path,
        []
    ];
    if (op.type === "diffMatchPatch") return [
        "patch",
        "diffMatchPatch",
        id,
        path,
        [
            op.value
        ]
    ];
    if (op.type === "inc" || op.type === "dec") return [
        "patch",
        op.type,
        id,
        path,
        [
            op.amount
        ]
    ];
    if (op.type === "set") return [
        "patch",
        op.type,
        id,
        path,
        [
            op.value
        ]
    ];
    if (op.type === "setIfMissing") return [
        "patch",
        op.type,
        id,
        path,
        [
            op.value
        ]
    ];
    if (op.type === "insert") return [
        "patch",
        "insert",
        id,
        path,
        [
            op.position,
            encodeItemRef$1(op.referenceItem),
            op.items
        ]
    ];
    if (op.type === "upsert") return [
        "patch",
        "upsert",
        id,
        path,
        [
            op.position,
            encodeItemRef$1(op.referenceItem),
            op.items
        ]
    ];
    if (op.type === "assign") return [
        "patch",
        "assign",
        id,
        path,
        [
            op.value
        ]
    ];
    if (op.type === "unassign") return [
        "patch",
        "assign",
        id,
        path,
        [
            op.keys
        ]
    ];
    if (op.type === "replace") return [
        "patch",
        "replace",
        id,
        path,
        [
            encodeItemRef$1(op.referenceItem),
            op.items
        ]
    ];
    if (op.type === "truncate") return [
        "patch",
        "truncate",
        id,
        path,
        [
            op.startIndex,
            op.endIndex
        ]
    ];
    if (op.type === "remove") return [
        "patch",
        "remove",
        id,
        path,
        [
            encodeItemRef$1(op.referenceItem)
        ]
    ];
    throw new Error(`Invalid operation type: ${op.type}`);
}
function maybeAddRevision(revision, mut) {
    const [mutType, patchType, id, path, args] = mut;
    return revision ? [
        mutType,
        patchType,
        id,
        path,
        args,
        revision
    ] : mut;
}
var index$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    decode,
    encode
}), index = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    decode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$decode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decode"],
    decodeAll: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$decode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decodeAll"],
    encode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$encode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encode"],
    encodeAll: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$encode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encodeAll"],
    encodeMutation: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$encode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encodeMutation"],
    encodeTransaction: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$encode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encodeTransaction"]
});
function format(mutations) {
    return mutations.flatMap((m)=>encodeMutation(m)).join(`
`);
}
function encodeItemRef(ref) {
    return typeof ref == "number" ? ref : ref._key;
}
function encodeMutation(mutation) {
    if (mutation.type === "create" || mutation.type === "createIfNotExists" || mutation.type === "createOrReplace") return [
        mutation.type,
        ": ",
        JSON.stringify(mutation.document)
    ].join("");
    if (mutation.type === "delete") return [
        "delete ",
        mutation.id
    ].join(": ");
    if (mutation.type === "patch") {
        const ifRevision = mutation.options?.ifRevision;
        return [
            "patch",
            " ",
            `id=${mutation.id}`,
            ifRevision ? ` (if revision==${ifRevision})` : "",
            `:
`,
            mutation.patches.map((nodePatch)=>`  ${formatPatchMutation(nodePatch)}`).join(`
`)
        ].join("");
    }
    throw new Error(`Invalid mutation type: ${mutation.type}`);
}
function formatPatchMutation(patch2) {
    const { op } = patch2, path = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringify"])(patch2.path);
    if (op.type === "unset") return [
        path,
        "unset()"
    ].join(": ");
    if (op.type === "diffMatchPatch") return [
        path,
        `diffMatchPatch(${op.value})`
    ].join(": ");
    if (op.type === "inc" || op.type === "dec") return [
        path,
        `${op.type}(${op.amount})`
    ].join(": ");
    if (op.type === "set" || op.type === "setIfMissing") return [
        path,
        `${op.type}(${JSON.stringify(op.value)})`
    ].join(": ");
    if (op.type === "assign") return [
        path,
        `${op.type}(${JSON.stringify(op.value)})`
    ].join(": ");
    if (op.type === "unassign") return [
        path,
        `${op.type}(${JSON.stringify(op.keys)})`
    ].join(": ");
    if (op.type === "insert" || op.type === "upsert") return [
        path,
        `${op.type}(${op.position}, ${encodeItemRef(op.referenceItem)}, ${JSON.stringify(op.items)})`
    ].join(": ");
    if (op.type === "replace") return [
        path,
        `replace(${encodeItemRef(op.referenceItem)}, ${JSON.stringify(op.items)})`
    ].join(": ");
    if (op.type === "truncate") return [
        path,
        `truncate(${op.startIndex}, ${op.endIndex}`
    ].join(": ");
    if (op.type === "remove") return [
        path,
        `remove(${encodeItemRef(op.referenceItem)})`
    ].join(": ");
    throw new Error(`Invalid operation type: ${op.type}`);
}
var compact = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    format
});
const set = (value)=>({
        type: "set",
        value
    }), assign = (value)=>({
        type: "assign",
        value
    }), unassign = (keys)=>({
        type: "unassign",
        keys
    }), setIfMissing = (value)=>({
        type: "setIfMissing",
        value
    }), unset = ()=>({
        type: "unset"
    }), inc = (amount = 1)=>({
        type: "inc",
        amount
    }), dec = (amount = 1)=>({
        type: "dec",
        amount
    }), diffMatchPatch = (value)=>({
        type: "diffMatchPatch",
        value
    });
function insert(items, position, indexOrReferenceItem) {
    return {
        type: "insert",
        referenceItem: indexOrReferenceItem,
        position,
        items: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$arrify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arrify"])(items)
    };
}
function append(items) {
    return insert(items, "after", -1);
}
function prepend(items) {
    return insert(items, "before", 0);
}
function insertBefore(items, indexOrReferenceItem) {
    return insert(items, "before", indexOrReferenceItem);
}
const insertAfter = (items, indexOrReferenceItem)=>insert(items, "after", indexOrReferenceItem);
function truncate(startIndex, endIndex) {
    return {
        type: "truncate",
        startIndex,
        endIndex
    };
}
function replace(items, referenceItem) {
    return {
        type: "replace",
        referenceItem,
        items: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$arrify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arrify"])(items)
    };
}
function remove(referenceItem) {
    return {
        type: "remove",
        referenceItem
    };
}
function upsert(items, position, referenceItem) {
    return {
        type: "upsert",
        items: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$arrify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arrify"])(items),
        referenceItem,
        position
    };
}
function autoKeys(generateKey) {
    const ensureKeys = createEnsureKeys(generateKey), insert$1 = (position, referenceItem, items)=>insert(ensureKeys(items), position, referenceItem), upsert$1 = (items, position, referenceItem)=>upsert(ensureKeys(items), position, referenceItem), replace$1 = (items, position, referenceItem)=>replace(ensureKeys(items), referenceItem), insertBefore2 = (ref, items)=>insert$1("before", ref, items);
    return {
        insert: insert$1,
        upsert: upsert$1,
        replace: replace$1,
        insertBefore: insertBefore2,
        prepend: (items)=>insertBefore2(0, items),
        insertAfter: (ref, items)=>insert$1("after", ref, items),
        append: (items)=>insert$1("after", -1, items)
    };
}
function hasKey(item) {
    return "_key" in item;
}
function createEnsureKeys(generateKey) {
    return (array)=>{
        let didModify = !1;
        const withKeys = array.map((item)=>needsKey(item) ? (didModify = !0, {
                ...item,
                _key: generateKey(item)
            }) : item);
        return didModify ? withKeys : array;
    };
}
function needsKey(arrayItem) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$isObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(arrayItem) && !hasKey(arrayItem);
}
function create(document) {
    return {
        type: "create",
        document
    };
}
function patch(id, patches, options) {
    return {
        type: "patch",
        id,
        patches: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$arrify$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arrify"])(patches),
        ...options ? {
            options
        } : {}
    };
}
function at(path, operation) {
    return {
        path: typeof path == "string" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"])(path) : path,
        op: operation
    };
}
function createIfNotExists(document) {
    return {
        type: "createIfNotExists",
        document
    };
}
function createOrReplace(document) {
    return {
        type: "createOrReplace",
        document
    };
}
function delete_(id) {
    return {
        type: "delete",
        id
    };
}
const del = delete_, destroy = delete_;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/get-random-values-esm/index.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Strict ESM env, designed to run outside Node.js in envs that provide WebCrypto (deno, browsers, etc)
__turbopack_context__.s({
    "default": (()=>getRandomValues)
});
function getRandomValues(typedArray) {
    const crypto = typeof window !== 'undefined' && 'crypto' in window ? window.crypto : globalThis.crypto;
    if (!crypto || !crypto.getRandomValues) {
        throw new Error('WebCrypto not available in this environment');
    }
    return crypto.getRandomValues(typedArray);
}
}}),
"[project]/node_modules/next-sanity/node_modules/@sanity/visual-editing/dist/_chunks-es/mutations.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "get": (()=>get),
    "getArrayDuplicatePatches": (()=>getArrayDuplicatePatches),
    "getArrayInsertPatches": (()=>getArrayInsertPatches),
    "getArrayItemKeyAndParentPath": (()=>getArrayItemKeyAndParentPath),
    "getArrayMovePatches": (()=>getArrayMovePatches),
    "getArrayRemovePatches": (()=>getArrayRemovePatches),
    "useDocuments": (()=>useDocuments),
    "useOptimisticActor": (()=>useOptimisticActor),
    "useOptimisticActorReady": (()=>useOptimisticActorReady)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-compiler-runtime/dist/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/client/dist/_chunks-es/resolveEditInfo.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next-sanity/node_modules/@sanity/mutate/dist/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$presentation$2d$comlink$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@sanity/presentation-comlink/dist/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$dist$2f$_chunks$2d$es$2f$context$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next-sanity/node_modules/@sanity/visual-editing/dist/_chunks-es/context.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$random$2d$values$2d$esm$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/get-random-values-esm/index.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
const reKeySegment$1 = /_key\s*==\s*['"](.*)['"]/, reIndexTuple = /^\d*:\d*$/;
function isIndexSegment(segment) {
    return typeof segment == "number" || typeof segment == "string" && /^\[\d+\]$/.test(segment);
}
function isKeySegment(segment) {
    return typeof segment == "string" ? reKeySegment$1.test(segment.trim()) : typeof segment == "object" && "_key" in segment;
}
function isIndexTuple(segment) {
    if (typeof segment == "string" && reIndexTuple.test(segment)) return !0;
    if (!Array.isArray(segment) || segment.length !== 2) return !1;
    const [from, to] = segment;
    return (typeof from == "number" || from === "") && (typeof to == "number" || to === "");
}
const rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, reKeySegment = /_key\s*==\s*['"](.*)['"]/;
function get(obj, path, defaultVal) {
    const select = typeof path == "string" ? fromString(path) : path;
    if (!Array.isArray(select)) throw new Error("Path must be an array or a string");
    let acc = obj;
    for(let i = 0; i < select.length; i++){
        const segment = select[i];
        if (isIndexSegment(segment)) {
            if (!Array.isArray(acc)) return defaultVal;
            acc = acc[segment];
        }
        if (isKeySegment(segment)) {
            if (!Array.isArray(acc)) return defaultVal;
            acc = acc.find((item)=>item._key === segment._key);
        }
        if (typeof segment == "string" && (acc = typeof acc == "object" && acc !== null ? acc[segment] : void 0), typeof acc > "u") return defaultVal;
    }
    return acc;
}
function fromString(path) {
    if (typeof path != "string") throw new Error("Path is not a string");
    const segments = path.match(rePropName);
    if (!segments) throw new Error("Invalid path string");
    return segments.map(normalizePathSegment);
}
function normalizePathSegment(segment) {
    return isIndexSegment(segment) ? normalizeIndexSegment(segment) : isKeySegment(segment) ? normalizeKeySegment(segment) : isIndexTuple(segment) ? normalizeIndexTupleSegment(segment) : segment;
}
function normalizeIndexSegment(segment) {
    return Number(segment.replace(/[^\d]/g, ""));
}
function normalizeKeySegment(segment) {
    return {
        _key: segment.match(reKeySegment)[1]
    };
}
function normalizeIndexTupleSegment(segment) {
    const [from, to] = segment.split(":").map((seg)=>seg === "" ? seg : Number(seg));
    return [
        from,
        to
    ];
}
function useOptimisticActor() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useSyncExternalStore"])(_temp, _temp2, _temp3);
}
function _temp3() {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$dist$2f$_chunks$2d$es$2f$context$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["emptyActor"];
}
function _temp2() {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$dist$2f$_chunks$2d$es$2f$context$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["actor"];
}
function _temp(listener) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$dist$2f$_chunks$2d$es$2f$context$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["listeners"].add(listener), ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$dist$2f$_chunks$2d$es$2f$context$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["listeners"].delete(listener);
}
function useOptimisticActorReady() {
    const actor2 = useOptimisticActor();
    let t0;
    return t0 = !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$dist$2f$_chunks$2d$es$2f$context$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isEmptyActor"])(actor2), t0;
}
function debounce(fn, timeout) {
    let timer;
    return (...args)=>{
        clearTimeout(timer), timer = setTimeout(()=>{
            fn.apply(fn, args);
        }, timeout);
    };
}
function getDocumentsAndSnapshot(id, actor2) {
    const inFrame = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$presentation$2d$comlink$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isMaybePreviewIframe"])(), inPopUp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$presentation$2d$comlink$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isMaybePreviewWindow"])();
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$dist$2f$_chunks$2d$es$2f$context$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isEmptyActor"])(actor2) || !inFrame && !inPopUp) throw new Error("The `useDocuments` hook cannot be used in this context");
    const draftId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getDraftId"])(id), publishedId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getPublishedId"])(id), documents = actor2.getSnapshot().context?.documents, draftDoc = documents?.[draftId], publishedDoc = documents?.[publishedId], doc = draftDoc || publishedDoc;
    if (!doc) throw new Error(`Document "${id}" not found`);
    const snapshot = draftDoc.getSnapshot().context?.local || publishedDoc.getSnapshot().context?.local, snapshotPromise = new Promise((resolve)=>{
        if (snapshot) resolve(snapshot);
        else {
            const subscriber = doc.on("ready", (event)=>{
                const { snapshot: snapshot2 } = event;
                resolve(snapshot2 || null), subscriber.unsubscribe();
            });
        }
    });
    return {
        draftDoc,
        draftId,
        getSnapshot: ()=>snapshotPromise,
        publishedDoc,
        publishedId,
        /**
     * @deprecated - use `getSnapshot` instead
     */ get snapshot () {
            if (!snapshot) throw new Error(`Snapshot for document "${id}" not found`);
            return snapshot;
        }
    };
}
function createDocumentCommit(id, actor2) {
    return ()=>{
        const { draftDoc } = getDocumentsAndSnapshot(id, actor2);
        draftDoc.send({
            type: "submit"
        });
    };
}
function createDocumentGet(id, actor2) {
    return (path)=>{
        const { snapshot } = getDocumentsAndSnapshot(id, actor2);
        return path ? get(snapshot, path) : snapshot;
    };
}
function createDocumentGetSnapshot(id, actor2) {
    const { getSnapshot } = getDocumentsAndSnapshot(id, actor2);
    return getSnapshot;
}
function createDocumentPatch(id, actor2) {
    return async (patches, options)=>{
        const result = getDocumentsAndSnapshot(id, actor2), { draftDoc, draftId, getSnapshot, publishedId } = result, { commit = !0 } = options || {}, resolvedPatches = await (typeof patches == "function" ? patches({
            draftId,
            publishedId,
            /**
       * @deprecated - use `getSnapshot` instead
       */ get snapshot () {
                return result.snapshot;
            },
            getSnapshot
        }) : patches), _snapshot = await getSnapshot();
        if (!_snapshot) throw new Error(`Snapshot for document "${id}" not found`);
        draftDoc.send({
            type: "mutate",
            mutations: [
                // Attempt to create the draft document, it might not exist if the
                // snapshot was from the published document
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createIfNotExists"])({
                    ..._snapshot,
                    _id: draftId
                }),
                // Patch the draft document with the resolved patches
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["patch"])(draftId, resolvedPatches)
            ]
        }), commit && (typeof commit == "object" && "debounce" in commit ? debounce(()=>draftDoc.send({
                type: "submit"
            }), commit.debounce)() : draftDoc.send({
            type: "submit"
        }));
    };
}
function useDocuments() {
    const $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])(7), actor2 = useOptimisticActor();
    let t0;
    $[0] !== actor2 ? (t0 = (documentId)=>({
            id: documentId,
            commit: createDocumentCommit(documentId, actor2),
            get: createDocumentGet(documentId, actor2),
            getSnapshot: createDocumentGetSnapshot(documentId, actor2),
            patch: createDocumentPatch(documentId, actor2)
        }), $[0] = actor2, $[1] = t0) : t0 = $[1];
    const getDocument = t0;
    let t1;
    $[2] !== actor2 ? (t1 = (id, mutations, options)=>{
        const { draftDoc } = getDocumentsAndSnapshot(id, actor2), { commit: t22 } = options || {}, commit = t22 === void 0 ? !0 : t22;
        draftDoc.send({
            type: "mutate",
            mutations
        }), commit && (typeof commit == "object" && "debounce" in commit ? debounce(()=>draftDoc.send({
                type: "submit"
            }), commit.debounce)() : draftDoc.send({
            type: "submit"
        }));
    }, $[2] = actor2, $[3] = t1) : t1 = $[3];
    const mutateDocument = t1;
    let t2;
    return $[4] !== getDocument || $[5] !== mutateDocument ? (t2 = {
        getDocument,
        mutateDocument
    }, $[4] = getDocument, $[5] = mutateDocument, $[6] = t2) : t2 = $[6], t2;
}
function whatwgRNG(length = 16) {
    const rnds8 = new Uint8Array(length);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$random$2d$values$2d$esm$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(rnds8), rnds8;
}
const getByteHexTable = /* @__PURE__ */ (()=>{
    let table;
    return ()=>{
        if (table) return table;
        table = [];
        for(let i = 0; i < 256; ++i)table[i] = (i + 256).toString(16).slice(1);
        return table;
    };
})();
function randomKey(length) {
    const table = getByteHexTable();
    return whatwgRNG(length).reduce((str, n)=>str + table[n], "").slice(0, length);
}
function getArrayItemKeyAndParentPath(pathOrNode) {
    const elementPath = typeof pathOrNode == "string" ? pathOrNode : pathOrNode.path, lastDotIndex = elementPath.lastIndexOf("."), lastPathItem = elementPath.substring(lastDotIndex + 1, elementPath.length);
    if (!lastPathItem.indexOf("[")) throw new Error("Invalid path: not an array");
    const lastArrayIndex = elementPath.lastIndexOf("["), path = elementPath.substring(0, lastArrayIndex);
    let key, hasExplicitKey;
    if (lastPathItem.includes("_key")) {
        const startIndex = lastPathItem.indexOf('"') + 1, endIndex = lastPathItem.indexOf('"', startIndex);
        key = lastPathItem.substring(startIndex, endIndex), hasExplicitKey = !0;
    } else {
        const startIndex = lastPathItem.indexOf("[") + 1, endIndex = lastPathItem.indexOf("]", startIndex);
        key = lastPathItem.substring(startIndex, endIndex), hasExplicitKey = !1;
    }
    if (!path || !key) throw new Error("Invalid path");
    return {
        path,
        key,
        hasExplicitKey
    };
}
function getArrayDuplicatePatches(node, snapshot, position = "after") {
    const { path: arrayPath, key: itemKey } = getArrayItemKeyAndParentPath(node), duplicate = {
        ...get(snapshot, node.path),
        _key: randomKey()
    };
    return [
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["at"])(arrayPath, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["insert"])(duplicate, position, {
            _key: itemKey
        }))
    ];
}
function getArrayRemovePatches(node, snapshot) {
    const { path: arrayPath, key: itemKey } = getArrayItemKeyAndParentPath(node), currentIndex = get(snapshot, arrayPath).findIndex((item)=>item._key === itemKey);
    return [
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["at"])(arrayPath, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["truncate"])(currentIndex, currentIndex + 1))
    ];
}
function getArrayInsertPatches(node, insertType, position) {
    const { path: arrayPath, key: itemKey } = getArrayItemKeyAndParentPath(node), insertKey = randomKey();
    return [
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["at"])(arrayPath, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["insert"])([
            {
                _type: insertType,
                _key: insertKey
            }
        ], position, {
            _key: itemKey
        }))
    ];
}
async function getArrayMovePatches(node, doc, moveTo) {
    if (!node.type) throw new Error("Node type is missing");
    const { path: arrayPath, key: itemKey } = getArrayItemKeyAndParentPath(node), snapshot = await doc.getSnapshot(), array = get(snapshot, arrayPath), item = get(snapshot, node.path), currentIndex = array.findIndex((item2)=>item2._key === itemKey);
    let nextIndex = -1, position = "before";
    if (moveTo === "first") {
        if (currentIndex === 0) return [];
        nextIndex = 0, position = "before";
    } else if (moveTo === "last") {
        if (currentIndex === array.length - 1) return [];
        nextIndex = -1, position = "after";
    } else if (moveTo === "next") {
        if (currentIndex === array.length - 1) return [];
        nextIndex = currentIndex, position = "after";
    } else if (moveTo === "previous") {
        if (currentIndex === 0) return [];
        nextIndex = currentIndex - 1, position = "before";
    }
    return [
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["at"])(arrayPath, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["truncate"])(currentIndex, currentIndex + 1)),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["at"])(arrayPath, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["insert"])(item, position, nextIndex))
    ];
}
;
 //# sourceMappingURL=mutations.js.map
}}),
"[project]/node_modules/@vercel/stega/dist/index.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "VERCEL_STEGA_REGEX": (()=>f),
    "legacyStegaEncode": (()=>y),
    "vercelStegaClean": (()=>O),
    "vercelStegaCombine": (()=>C),
    "vercelStegaDecode": (()=>G),
    "vercelStegaDecodeAll": (()=>$),
    "vercelStegaEncode": (()=>E),
    "vercelStegaSplit": (()=>_)
});
var s = {
    0: 8203,
    1: 8204,
    2: 8205,
    3: 8290,
    4: 8291,
    5: 8288,
    6: 65279,
    7: 8289,
    8: 119155,
    9: 119156,
    a: 119157,
    b: 119158,
    c: 119159,
    d: 119160,
    e: 119161,
    f: 119162
}, c = {
    0: 8203,
    1: 8204,
    2: 8205,
    3: 65279
}, u = new Array(4).fill(String.fromCodePoint(c[0])).join(""), m = String.fromCharCode(0);
function E(t) {
    let e = JSON.stringify(t);
    return `${u}${Array.from(e).map((r)=>{
        let n = r.charCodeAt(0);
        if (n > 255) throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${e} on character ${r} (${n})`);
        return Array.from(n.toString(4).padStart(4, "0")).map((o)=>String.fromCodePoint(c[o])).join("");
    }).join("")}`;
}
function y(t) {
    let e = JSON.stringify(t);
    return Array.from(e).map((r)=>{
        let n = r.charCodeAt(0);
        if (n > 255) throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${e} on character ${r} (${n})`);
        return Array.from(n.toString(16).padStart(2, "0")).map((o)=>String.fromCodePoint(s[o])).join("");
    }).join("");
}
function I(t) {
    return !Number.isNaN(Number(t)) || /[a-z]/i.test(t) && !/\d+(?:[-:\/]\d+){2}(?:T\d+(?:[-:\/]\d+){1,2}(\.\d+)?Z?)?/.test(t) ? !1 : Boolean(Date.parse(t));
}
function T(t) {
    try {
        new URL(t, t.startsWith("/") ? "https://acme.com" : void 0);
    } catch  {
        return !1;
    }
    return !0;
}
function C(t, e, r = "auto") {
    return r === !0 || r === "auto" && (I(t) || T(t)) ? t : `${t}${E(e)}`;
}
var x = Object.fromEntries(Object.entries(c).map((t)=>t.reverse())), g = Object.fromEntries(Object.entries(s).map((t)=>t.reverse())), S = `${Object.values(s).map((t)=>`\\u{${t.toString(16)}}`).join("")}`, f = new RegExp(`[${S}]{4,}`, "gu");
function G(t) {
    let e = t.match(f);
    if (!!e) return h(e[0], !0)[0];
}
function $(t) {
    let e = t.match(f);
    if (!!e) return e.map((r)=>h(r)).flat();
}
function h(t, e = !1) {
    let r = Array.from(t);
    if (r.length % 2 === 0) {
        if (r.length % 4 || !t.startsWith(u)) return A(r, e);
    } else throw new Error("Encoded data has invalid length");
    let n = [];
    for(let o = r.length * .25; o--;){
        let p = r.slice(o * 4, o * 4 + 4).map((d)=>x[d.codePointAt(0)]).join("");
        n.unshift(String.fromCharCode(parseInt(p, 4)));
    }
    if (e) {
        n.shift();
        let o = n.indexOf(m);
        return o === -1 && (o = n.length), [
            JSON.parse(n.slice(0, o).join(""))
        ];
    }
    return n.join("").split(m).filter(Boolean).map((o)=>JSON.parse(o));
}
function A(t, e) {
    var d;
    let r = [];
    for(let i = t.length * .5; i--;){
        let a = `${g[t[i * 2].codePointAt(0)]}${g[t[i * 2 + 1].codePointAt(0)]}`;
        r.unshift(String.fromCharCode(parseInt(a, 16)));
    }
    let n = [], o = [
        r.join("")
    ], p = 10;
    for(; o.length;){
        let i = o.shift();
        try {
            if (n.push(JSON.parse(i)), e) return n;
        } catch (a) {
            if (!p--) throw a;
            let l = +((d = a.message.match(/\sposition\s(\d+)$/)) == null ? void 0 : d[1]);
            if (!l) throw a;
            o.unshift(i.substring(0, l), i.substring(l));
        }
    }
    return n;
}
function _(t) {
    var e;
    return {
        cleaned: t.replace(f, ""),
        encoded: ((e = t.match(f)) == null ? void 0 : e[0]) || ""
    };
}
function O(t) {
    return t && JSON.parse(_(JSON.stringify(t)).cleaned);
}
;
}}),
"[project]/node_modules/next-sanity/node_modules/@sanity/visual-editing/dist/_chunks-es/SharedStateContext.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "SharedStateContext": (()=>SharedStateContext),
    "createOverlayController": (()=>createOverlayController),
    "sanityNodesExistInSameArray": (()=>sanityNodesExistInSameArray),
    "useOptimistic": (()=>useOptimistic)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-compiler-runtime/dist/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/client/dist/_chunks-es/resolveEditInfo.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$effect$2d$event$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/use-effect-event/dist/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$dist$2f$_chunks$2d$es$2f$context$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next-sanity/node_modules/@sanity/visual-editing/dist/_chunks-es/context.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$dist$2f$_chunks$2d$es$2f$mutations$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next-sanity/node_modules/@sanity/visual-editing/dist/_chunks-es/mutations.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2d$csm$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/visual-editing-csm/dist/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vercel$2f$stega$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@vercel/stega/dist/index.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
function useOptimistic(passthrough, reducer) {
    const $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])(21), [pristine, setPristine] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useState"])(!0), [optimistic, setOptimistic] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useState"])(passthrough), [lastEvent, setLastEvent] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useState"])(null), [lastPassthrough, setLastPassthrough] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useState"])(passthrough), actor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$dist$2f$_chunks$2d$es$2f$mutations$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useOptimisticActor"])();
    let t0;
    $[0] !== reducer ? (t0 = (action, prevState)=>(Array.isArray(reducer) ? reducer : [
            reducer
        ]).reduce((acc, reducer_0)=>reducer_0(acc, {
                document: action.document,
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getPublishedId"])(action.id),
                originalId: action.id,
                type: action.type
            }), prevState), $[0] = reducer, $[1] = t0) : t0 = $[1];
    const reduceStateFromAction = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$effect$2d$event$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useEffectEvent"])(t0);
    let t1;
    $[2] !== passthrough ? (t1 = ()=>setLastPassthrough(passthrough), $[2] = passthrough, $[3] = t1) : t1 = $[3];
    const updateLastPassthrough = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$effect$2d$event$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useEffectEvent"])(t1);
    let t2;
    $[4] !== actor || $[5] !== reduceStateFromAction || $[6] !== updateLastPassthrough ? (t2 = ()=>{
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$dist$2f$_chunks$2d$es$2f$context$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isEmptyActor"])(actor)) return;
        let pristineTimeout;
        const rebasedSub = actor.on("rebased.local", (_event)=>{
            const event = {
                document: _event.document,
                id: _event.id,
                originalId: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getPublishedId"])(_event.id),
                type: "mutate"
            };
            setOptimistic((prevState_0)=>reduceStateFromAction(event, prevState_0)), setLastEvent(event), updateLastPassthrough(), setPristine(!1), clearTimeout(pristineTimeout);
        }), pristineSub = actor.on("pristine", ()=>{
            pristineTimeout = setTimeout(()=>{
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["startTransition"])(()=>setPristine(!0));
            }, 15e3);
        });
        return ()=>{
            rebasedSub.unsubscribe(), pristineSub.unsubscribe();
        };
    }, $[4] = actor, $[5] = reduceStateFromAction, $[6] = updateLastPassthrough, $[7] = t2) : t2 = $[7];
    let t3;
    $[8] !== actor ? (t3 = [
        actor
    ], $[8] = actor, $[9] = t3) : t3 = $[9], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useEffect"])(t2, t3);
    let t4;
    $[10] !== lastEvent || $[11] !== lastPassthrough || $[12] !== passthrough || $[13] !== pristine || $[14] !== reduceStateFromAction ? (t4 = ()=>{
        if (!pristine) {
            if (!lastEvent) throw new Error("No last event found when syncing passthrough");
            lastPassthrough !== passthrough && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["startTransition"])(()=>{
                setOptimistic(reduceStateFromAction(lastEvent, passthrough)), setLastPassthrough(passthrough);
            });
        }
    }, $[10] = lastEvent, $[11] = lastPassthrough, $[12] = passthrough, $[13] = pristine, $[14] = reduceStateFromAction, $[15] = t4) : t4 = $[15];
    let t5;
    return $[16] !== lastEvent || $[17] !== lastPassthrough || $[18] !== passthrough || $[19] !== pristine ? (t5 = [
        lastEvent,
        lastPassthrough,
        passthrough,
        pristine
    ], $[16] = lastEvent, $[17] = lastPassthrough, $[18] = passthrough, $[19] = pristine, $[20] = t5) : t5 = $[20], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useEffect"])(t4, t5), pristine ? passthrough : optimistic;
}
const byteToHex = [];
for(let i = 0; i < 256; ++i)byteToHex.push((i + 256).toString(16).slice(1));
function unsafeStringify(arr, offset = 0) {
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
    if (!getRandomValues) {
        if (typeof crypto > "u" || !crypto.getRandomValues) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
        getRandomValues = crypto.getRandomValues.bind(crypto);
    }
    return getRandomValues(rnds8);
}
const randomUUID = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native = {
    randomUUID
};
function v4(options, buf, offset) {
    if (native.randomUUID && !options) return native.randomUUID();
    options = options || {};
    const rnds = options.random ?? options.rng?.() ?? rng();
    if (rnds.length < 16) throw new Error("Random bytes length must be >= 16");
    return rnds[6] = rnds[6] & 15 | 64, rnds[8] = rnds[8] & 63 | 128, unsafeStringify(rnds);
}
function getRect(element) {
    const domRect = element.getBoundingClientRect();
    return {
        x: domRect.x + scrollX,
        y: domRect.y + scrollY,
        w: domRect.width,
        h: domRect.height
    };
}
function offsetRect(rect, px, axis) {
    return axis === "x" ? {
        x: rect.x + px,
        y: rect.y,
        w: rect.w - 2 * px,
        h: rect.h
    } : {
        x: rect.x,
        y: rect.y + px,
        w: rect.w,
        h: rect.h - 2 * px
    };
}
function rayIntersect(l1, l2) {
    const { x1, y1, x2, y2 } = l1, { x1: x3, y1: y3, x2: x4, y2: y4 } = l2;
    if (x1 === x2 && y1 === y2 || x3 === x4 && y3 === y4) return !1;
    const denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
    if (denominator === 0) return !1;
    const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator, ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;
    if (ua < 0 || ua > 1 || ub < 0 || ub > 1) return !1;
    const x = x1 + ua * (x2 - x1), y = y1 + ua * (y2 - y1);
    return {
        x,
        y
    };
}
function rectEqual(r1, r2) {
    return r1.x === r2.x && r1.y === r2.y && r1.w === r2.w && r1.h === r2.h;
}
function rayRectIntersections(line, rect) {
    const rectLines = [
        {
            x1: rect.x,
            y1: rect.y,
            x2: rect.x + rect.w,
            y2: rect.y
        },
        {
            x1: rect.x + rect.w,
            y1: rect.y,
            x2: rect.x + rect.w,
            y2: rect.y + rect.h
        },
        {
            x1: rect.x + rect.w,
            y1: rect.y + rect.h,
            x2: rect.x,
            y2: rect.y + rect.h
        },
        {
            x1: rect.x,
            y1: rect.y + rect.h,
            x2: rect.x,
            y2: rect.y
        }
    ], intersections = [];
    for(let i = 0; i < rectLines.length; i++){
        const intersection = rayIntersect(line, rectLines[i]);
        if (intersection) {
            let isDuplicate = !1;
            for(let j = 0; j < intersections.length; j++)intersections[j].x === intersection.x && intersections[j].y === intersection.y && (isDuplicate = !0);
            isDuplicate || intersections.push(intersection);
        }
    }
    return intersections.length === 0 ? !1 : intersections.sort((a, b)=>pointDist(a, {
            x: line.x1,
            y: line.y1
        }) - pointDist(b, {
            x: line.x1,
            y: line.y1
        }));
}
function pointDist(p1, p2) {
    const a = p1.x - p2.x, b = p1.y - p2.y;
    return Math.sqrt(a * a + b * b);
}
function pointInBounds(point, bounds) {
    const withinX = point.x >= bounds.x && point.x <= bounds.x + bounds.w, withinY = point.y >= bounds.y && point.y <= bounds.y + bounds.h;
    return withinX && withinY;
}
function findClosestIntersection(ray, targets, flow) {
    const rayOrigin = {
        x: ray.x1,
        y: ray.y1
    };
    if (targets.some((t)=>pointInBounds(rayOrigin, offsetRect(t, Math.min(t.w, t.h) / 10, flow === "horizontal" ? "x" : "y")))) return null;
    let closestIntersection, closestRect;
    for (const target of targets){
        const intersections = rayRectIntersections(ray, offsetRect(target, Math.min(target.w, target.h) / 10, flow === "horizontal" ? "x" : "y"));
        if (intersections) {
            const firstIntersection = intersections[0];
            closestIntersection ? pointDist(rayOrigin, firstIntersection) < pointDist(rayOrigin, closestIntersection) && (closestIntersection = firstIntersection, closestRect = target) : (closestIntersection = firstIntersection, closestRect = target);
        }
    }
    return closestRect || null;
}
function scaleRect(rect, scale, origin) {
    const { x, y, w, h } = rect, { x: originX, y: originY } = origin, newX = originX + (x - originX) * scale, newY = originY + (y - originY) * scale, newWidth = w * scale, newHeight = h * scale;
    return {
        x: newX,
        y: newY,
        w: newWidth,
        h: newHeight
    };
}
function getRectGroupXExtent(rects) {
    const minGroupX = Math.max(0, Math.min(...rects.map((r)=>r.x))), maxGroupX = Math.min(document.body.offsetWidth, Math.max(...rects.map((r)=>r.x + r.w)));
    return {
        min: minGroupX,
        max: maxGroupX,
        width: maxGroupX - minGroupX
    };
}
function getRectGroupYExtent(rects) {
    const minGroupY = Math.max(0, Math.min(...rects.map((r)=>r.y))), maxGroupY = Math.min(document.body.scrollHeight, Math.max(...rects.map((r)=>r.y + r.h)));
    return {
        min: minGroupY,
        max: maxGroupY,
        height: maxGroupY - minGroupY
    };
}
function calcTargetFlow(targets) {
    return targets.some((t1)=>targets.filter((t2)=>!rectEqual(t1, t2)).some((t2)=>t1.y === t2.y)) ? "horizontal" : "vertical";
}
function calcInsertPosition(origin, targets, flow) {
    if (flow === "horizontal") {
        const rayLeft = {
            x1: origin.x,
            y1: origin.y,
            x2: origin.x - 1e8,
            y2: origin.y
        }, rayRight = {
            x1: origin.x,
            y1: origin.y,
            x2: origin.x + 1e8,
            y2: origin.y
        };
        return {
            left: findClosestIntersection(rayLeft, targets, flow),
            right: findClosestIntersection(rayRight, targets, flow)
        };
    } else {
        const rayTop = {
            x1: origin.x,
            y1: origin.y,
            x2: origin.x,
            y2: origin.y - 1e8
        }, rayBottom = {
            x1: origin.x,
            y1: origin.y,
            x2: origin.x,
            y2: origin.y + 1e8
        };
        return {
            top: findClosestIntersection(rayTop, targets, flow),
            bottom: findClosestIntersection(rayBottom, targets, flow)
        };
    }
}
function findRectSanityData(rect, overlayGroup) {
    return overlayGroup.find((e)=>rectEqual(getRect(e.elements.element), rect))?.sanity;
}
function resolveInsertPosition(overlayGroup, insertPosition, flow) {
    return Object.values(insertPosition).every((v)=>v === null) ? null : flow === "horizontal" ? {
        left: insertPosition.left ? {
            rect: insertPosition.left,
            sanity: findRectSanityData(insertPosition.left, overlayGroup)
        } : null,
        right: insertPosition.right ? {
            rect: insertPosition.right,
            sanity: findRectSanityData(insertPosition.right, overlayGroup)
        } : null
    } : {
        top: insertPosition.top ? {
            rect: insertPosition.top,
            sanity: findRectSanityData(insertPosition.top, overlayGroup)
        } : null,
        bottom: insertPosition.bottom ? {
            rect: insertPosition.bottom,
            sanity: findRectSanityData(insertPosition.bottom, overlayGroup)
        } : null
    };
}
function calcMousePos(e) {
    const bodyBounds = document.body.getBoundingClientRect();
    return {
        x: Math.max(bodyBounds.x, Math.min(e.clientX, bodyBounds.x + bodyBounds.width)),
        y: e.clientY + window.scrollY
    };
}
function calcMousePosInverseTransform(mousePos2) {
    const body = document.body, transform = window.getComputedStyle(body).transform;
    if (transform === "none") return {
        x: mousePos2.x,
        y: mousePos2.y
    };
    const inverseMatrix = new DOMMatrix(transform).inverse(), transformedPoint = new DOMPoint(mousePos2.x, mousePos2.y).matrixTransform(inverseMatrix);
    return {
        x: transformedPoint.x,
        y: transformedPoint.y
    };
}
function buildPreviewSkeleton(mousePos2, element, scaleFactor) {
    const bounds = getRect(element), children = [
        ...element.querySelectorAll(":where(h1, h2, h3, h4, p, a, img, span, button):not(:has(*))")
    ];
    mousePos2.x <= bounds.x && (mousePos2.x = bounds.x), mousePos2.x >= bounds.x + bounds.w && (mousePos2.x = bounds.x + bounds.w), mousePos2.y >= bounds.y + bounds.h && (mousePos2.y = bounds.y + bounds.h), mousePos2.y <= bounds.y && (mousePos2.y = bounds.y);
    const childRects = children.map((child)=>{
        const rect = scaleRect(getRect(child), scaleFactor, {
            x: bounds.x,
            y: bounds.y
        });
        return {
            x: rect.x - bounds.x,
            y: rect.y - bounds.y,
            w: rect.w,
            h: rect.h,
            tagName: child.tagName
        };
    });
    return {
        offsetX: (bounds.x - mousePos2.x) * scaleFactor,
        offsetY: (bounds.y - mousePos2.y) * scaleFactor,
        w: bounds.w * scaleFactor,
        h: bounds.h * scaleFactor,
        maxWidth: bounds.w * scaleFactor * 0.75,
        childRects
    };
}
const minDragDelta = 4;
async function applyMinimapWrapperTransform(target, scaleFactor, minYScaled, handler, rectUpdateFrequency) {
    return new Promise((resolve)=>{
        target.addEventListener("transitionend", ()=>{
            setTimeout(()=>{
                handler({
                    type: "overlay/dragEndMinimapTransition"
                });
            }, rectUpdateFrequency * 2), resolve();
        }, {
            once: !0
        }), handler({
            type: "overlay/dragStartMinimapTransition"
        }), handler({
            type: "overlay/dragToggleMinimap",
            display: !0
        }), document.body.style.overflow = "hidden", document.body.style.height = "100%", document.documentElement.style.overflow = "initial", document.documentElement.style.height = "100%", setTimeout(()=>{
            target.style.transformOrigin = "50% 0px", target.style.transition = "transform 150ms ease", target.style.transform = `translate3d(0px, ${-minYScaled + scrollY}px, 0px) scale(${scaleFactor})`;
        }, 25);
    });
}
function calcMinimapTransformValues(rects, groupHeightOverride) {
    let groupHeight = groupHeightOverride || getRectGroupYExtent(rects).height;
    const padding = 100;
    groupHeight += padding * 2;
    const scaleFactor = groupHeight > window.innerHeight ? window.innerHeight / groupHeight : 1, scaledRects = rects.map((r)=>scaleRect(r, scaleFactor, {
            x: window.innerWidth / 2,
            y: 0
        })), { min: minYScaled } = getRectGroupYExtent(scaledRects);
    return {
        scaleFactor,
        minYScaled: minYScaled - padding * scaleFactor
    };
}
function calcGroupBoundsPreview(rects) {
    const groupBoundsX = getRectGroupXExtent(rects), groupBoundsY = getRectGroupYExtent(rects), offsetDist = 8, canOffsetX = groupBoundsX.min > offsetDist && groupBoundsX.min + groupBoundsX.width <= window.innerWidth - offsetDist, canOffsetY = groupBoundsY.min > offsetDist && groupBoundsY.min + groupBoundsY.height <= document.body.scrollHeight - offsetDist, canOffset = canOffsetX && canOffsetY;
    return {
        x: canOffset ? groupBoundsX.min - offsetDist : groupBoundsX.min,
        y: canOffset ? groupBoundsY.min - offsetDist : groupBoundsY.min,
        w: canOffset ? groupBoundsX.width + offsetDist * 2 : groupBoundsX.width,
        h: canOffset ? groupBoundsY.height + offsetDist * 2 : groupBoundsY.height
    };
}
async function resetMinimapWrapperTransform(endYOrigin, target, prescaleHeight2, handler, rectUpdateFrequency, previousRootStyleValues2) {
    return new Promise((resolve)=>{
        const transform = window.getComputedStyle(target).transform;
        if (new DOMMatrix(transform).a === 1) return;
        const maxScroll = prescaleHeight2 - window.innerHeight, prevScrollY = scrollY;
        endYOrigin -= window.innerHeight / 2, endYOrigin < 0 && (endYOrigin = 0), target.addEventListener("transitionend", ()=>{
            target.style.transition = "none", target.style.transform = "none", scrollTo({
                top: endYOrigin,
                behavior: "instant"
            }), setTimeout(()=>{
                handler({
                    type: "overlay/dragEndMinimapTransition"
                }), handler({
                    type: "overlay/dragToggleMinimap",
                    display: !1
                });
            }, rectUpdateFrequency * 2), resolve();
        }, {
            once: !0
        }), handler({
            type: "overlay/dragStartMinimapTransition"
        }), target.style.transform = `translateY(${Math.max(prevScrollY - endYOrigin, -maxScroll + prevScrollY)}px) scale(1)`, previousRootStyleValues2 && (document.body.style.overflow = previousRootStyleValues2.body.overflow, document.body.style.height = previousRootStyleValues2.body.height, document.documentElement.style.overflow = previousRootStyleValues2.documentElement.overflow, document.documentElement.style.height = previousRootStyleValues2.documentElement.height);
    });
}
let minimapScaleApplied = !1, mousePosInverseTransform = {
    y: 0
}, mousePos = {
    x: 0,
    y: 0
}, prescaleHeight = typeof document > "u" ? 0 : document.documentElement.scrollHeight, previousRootStyleValues = null;
function handleOverlayDrag(opts) {
    const { mouseEvent, element, overlayGroup, handler, target, onSequenceStart, onSequenceEnd } = opts;
    if (mouseEvent.button !== 0) return;
    window.focus();
    const rectUpdateFrequency = 150;
    let rects = overlayGroup.map((e)=>getRect(e.elements.element));
    const flow = element.getAttribute("data-sanity-drag-flow") || calcTargetFlow(rects), dragGroup = element.getAttribute("data-sanity-drag-group"), disableMinimap = !!element.getAttribute("data-sanity-drag-minimap-disable"), preventInsertDefault = !!element.getAttribute("data-sanity-drag-prevent-default"), documentHeightOverride = element.getAttribute("data-unstable_sanity-drag-document-height"), groupHeightOverride = element.getAttribute("data-unstable_sanity-drag-group-height");
    let insertPosition = null;
    const initialMousePos = calcMousePos(mouseEvent), scaleTarget = document.body, { minYScaled, scaleFactor } = calcMinimapTransformValues(rects, groupHeightOverride ? ~~groupHeightOverride : null);
    let sequenceStarted = !1, minimapPromptShown = !1, mousedown = !0;
    minimapScaleApplied || (previousRootStyleValues = {
        body: {
            overflow: window.getComputedStyle(document.body).overflow,
            height: window.getComputedStyle(document.body).height
        },
        documentElement: {
            overflow: window.getComputedStyle(document.documentElement).overflow,
            height: window.getComputedStyle(document.documentElement).height
        }
    }, prescaleHeight = documentHeightOverride ? ~~documentHeightOverride : document.documentElement.scrollHeight);
    const rectsInterval = setInterval(()=>{
        rects = overlayGroup.map((e)=>getRect(e.elements.element));
    }, rectUpdateFrequency), applyMinimap = ()=>{
        if (scaleFactor >= 1) return;
        const skeleton = buildPreviewSkeleton(mousePos, element, scaleFactor);
        handler({
            type: "overlay/dragUpdateSkeleton",
            skeleton
        }), handler({
            type: "overlay/dragToggleMinimapPrompt",
            display: !1
        }), applyMinimapWrapperTransform(scaleTarget, scaleFactor, minYScaled, handler, rectUpdateFrequency).then(()=>{
            setTimeout(()=>{
                handler({
                    type: "overlay/dragUpdateGroupRect",
                    groupRect: calcGroupBoundsPreview(rects)
                });
            }, rectUpdateFrequency * 2);
        });
    }, handleScroll = (e)=>{
        Math.abs(e.deltaY) >= 10 && scaleFactor < 1 && !minimapScaleApplied && !minimapPromptShown && !disableMinimap && mousedown && (handler({
            type: "overlay/dragToggleMinimapPrompt",
            display: !0
        }), minimapPromptShown = !0), e.shiftKey && !minimapScaleApplied && !disableMinimap && (window.dispatchEvent(new CustomEvent("unstable_sanity/dragApplyMinimap")), minimapScaleApplied = !0, setTimeout(()=>{
            applyMinimap();
        }, 50));
    }, handleMouseMove = (e)=>{
        if (e.preventDefault(), mousePos = calcMousePos(e), mousePosInverseTransform = calcMousePosInverseTransform(mousePos), Math.abs(pointDist(mousePos, initialMousePos)) < minDragDelta) return;
        if (!sequenceStarted) {
            const groupRect = calcGroupBoundsPreview(rects), skeleton = buildPreviewSkeleton(mousePos, element, 1);
            handler({
                type: "overlay/dragStart",
                flow
            }), handler({
                type: "overlay/dragUpdateSkeleton",
                skeleton
            }), handler({
                type: "overlay/dragUpdateGroupRect",
                groupRect
            }), sequenceStarted = !0, onSequenceStart();
        }
        handler({
            type: "overlay/dragUpdateCursorPosition",
            x: mousePos.x,
            y: mousePos.y
        }), e.shiftKey && !minimapScaleApplied && !disableMinimap && (window.dispatchEvent(new CustomEvent("unstable_sanity/dragApplyMinimap")), minimapScaleApplied = !0, setTimeout(()=>{
            applyMinimap();
        }, 50));
        const newInsertPosition = calcInsertPosition(mousePos, rects, flow);
        JSON.stringify(insertPosition) !== JSON.stringify(newInsertPosition) && (insertPosition = newInsertPosition, handler({
            type: "overlay/dragUpdateInsertPosition",
            insertPosition: resolveInsertPosition(overlayGroup, insertPosition, flow)
        }));
    }, handleMouseUp = ()=>{
        mousedown = !1, handler({
            type: "overlay/dragEnd",
            target,
            insertPosition: insertPosition ? resolveInsertPosition(overlayGroup, insertPosition, flow) : null,
            dragGroup,
            flow,
            preventInsertDefault
        }), minimapPromptShown && handler({
            type: "overlay/dragToggleMinimapPrompt",
            display: !1
        }), minimapScaleApplied || (clearInterval(rectsInterval), onSequenceEnd(), removeFrameListeners(), removeKeyListeners()), removeMouseListeners();
    }, handleKeyup = (e)=>{
        if (e.key === "Shift" && minimapScaleApplied) {
            minimapScaleApplied = !1;
            const skeleton = buildPreviewSkeleton(mousePos, element, 1 / scaleFactor);
            handler({
                type: "overlay/dragUpdateSkeleton",
                skeleton
            }), window.dispatchEvent(new CustomEvent("unstable_sanity/dragResetMinimap")), setTimeout(()=>{
                resetMinimapWrapperTransform(mousePosInverseTransform.y, scaleTarget, prescaleHeight, handler, rectUpdateFrequency, previousRootStyleValues);
            }, 50), handler({
                type: "overlay/dragUpdateGroupRect",
                groupRect: null
            }), mousedown || (clearInterval(rectsInterval), removeMouseListeners(), removeFrameListeners(), removeKeyListeners(), onSequenceEnd());
        }
    }, handleBlur = ()=>{
        handler({
            type: "overlay/dragUpdateGroupRect",
            groupRect: null
        }), window.dispatchEvent(new CustomEvent("unstable_sanity/dragResetMinimap")), setTimeout(()=>{
            resetMinimapWrapperTransform(mousePosInverseTransform.y, scaleTarget, prescaleHeight, handler, rectUpdateFrequency, previousRootStyleValues).then(()=>{
                minimapScaleApplied = !1;
            });
        }, 50), clearInterval(rectsInterval), removeMouseListeners(), removeFrameListeners(), removeKeyListeners(), onSequenceEnd();
    }, removeMouseListeners = ()=>{
        window.removeEventListener("mousemove", handleMouseMove), window.removeEventListener("wheel", handleScroll), window.removeEventListener("mouseup", handleMouseUp);
    }, removeKeyListeners = ()=>{
        window.removeEventListener("keyup", handleKeyup);
    }, removeFrameListeners = ()=>{
        window.removeEventListener("blur", handleBlur);
    };
    window.addEventListener("blur", handleBlur), window.addEventListener("keyup", handleKeyup), window.addEventListener("wheel", handleScroll), window.addEventListener("mousemove", handleMouseMove), window.addEventListener("mouseup", handleMouseUp);
}
const isElementNode$1 = (target)=>target instanceof HTMLElement || target instanceof SVGElement;
function findNonInlineElement(element) {
    const { display } = window.getComputedStyle(element);
    if (display !== "inline") return element;
    const parent = element.parentElement;
    return parent ? findNonInlineElement(parent) : null;
}
const findOverlayElement = (el)=>!el || !isElementNode$1(el) ? null : el.dataset?.sanityOverlayElement ? el : findOverlayElement(el.parentElement);
function testVercelStegaRegex(input) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vercel$2f$stega$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["VERCEL_STEGA_REGEX"].lastIndex = 0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vercel$2f$stega$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["VERCEL_STEGA_REGEX"].test(input);
}
function decodeStega(str, isAltText = !1) {
    try {
        const decoded = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vercel$2f$stega$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["vercelStegaDecode"])(str);
        return !decoded || decoded.origin !== "sanity.io" ? null : (isAltText && (decoded.href = decoded.href?.replace(".alt", "")), decoded);
    } catch (err) {
        return console.error("Failed to decode stega for string: ", str, "with the original error: ", err), null;
    }
}
function testAndDecodeStega(str, isAltText = !1) {
    return testVercelStegaRegex(str) ? decodeStega(str, isAltText) : null;
}
const isElementNode = (node)=>node.nodeType === Node.ELEMENT_NODE, isImgElement = (el)=>el.tagName === "IMG", isTimeElement = (el)=>el.tagName === "TIME", isSvgRootElement = (el)=>el.tagName.toUpperCase() === "SVG";
function isSanityNode(node) {
    return "path" in node;
}
function findCommonPath(first, second) {
    let firstParts = first.split("."), secondParts = second.split(".");
    const maxLength = Math.min(firstParts.length, secondParts.length);
    return firstParts = firstParts.slice(0, maxLength).reverse(), secondParts = secondParts.slice(0, maxLength).reverse(), firstParts.reduce((parts, part, i)=>part === secondParts[i] ? [
            ...parts,
            part
        ] : [], []).reverse().join(".");
}
function findCommonSanityData(nodes) {
    if (!nodes.length || !nodes.map((n)=>isSanityNode(n)).every((n, _i, arr)=>n === arr[0])) return;
    if (!isSanityNode(nodes[0])) return nodes[0];
    const sanityNodes = nodes.filter(isSanityNode);
    let common = nodes[0];
    const consistentValueKeys = [
        "projectId",
        "dataset",
        "id",
        "baseUrl",
        "workspace",
        "tool"
    ];
    for(let i = 1; i < sanityNodes.length; i++){
        const node = sanityNodes[i];
        if (consistentValueKeys.some((key)=>node[key] !== common?.[key])) {
            common = void 0;
            break;
        }
        common.path = findCommonPath(common.path, node.path);
    }
    return common;
}
function findSanityNodes(el) {
    const elements = [];
    function addElement(element, data) {
        const sanity = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2d$csm$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decodeSanityNodeData"])(data);
        if (!sanity) return;
        const measureElement = findNonInlineElement(element);
        measureElement && elements.push({
            elements: {
                element,
                measureElement
            },
            sanity
        });
    }
    if (el) for (const node of el.childNodes){
        const { nodeType, parentElement, textContent } = node;
        if (isElementNode(node) && node.dataset?.sanityEditTarget !== void 0) {
            const nodesInTarget = findSanityNodes(node).map(({ sanity })=>sanity);
            if (!nodesInTarget.map((n)=>isSanityNode(n)).every((n, _i, arr)=>n === arr[0])) continue;
            const commonData = findCommonSanityData(nodesInTarget);
            commonData && elements.push({
                elements: {
                    element: node,
                    measureElement: node
                },
                sanity: commonData
            });
        } else if (nodeType === Node.TEXT_NODE && parentElement && textContent) {
            const data = testAndDecodeStega(textContent);
            if (!data) continue;
            addElement(parentElement, data);
        } else if (isElementNode(node)) {
            if (node.tagName === "SCRIPT" || node.tagName === "SANITY-VISUAL-EDITING") continue;
            if (node.dataset?.sanity) addElement(node, node.dataset.sanity);
            else if (node.dataset?.sanityEditInfo) addElement(node, node.dataset.sanityEditInfo);
            else if (isImgElement(node)) {
                const data = testAndDecodeStega(node.alt, !0);
                if (!data) continue;
                addElement(node, data);
                continue;
            } else if (isTimeElement(node)) {
                const data = testAndDecodeStega(node.dateTime, !0);
                if (!data) continue;
                addElement(node, data);
            } else if (isSvgRootElement(node)) {
                if (!node.ariaLabel) continue;
                const data = testAndDecodeStega(node.ariaLabel, !0);
                if (!data) continue;
                addElement(node, data);
            }
            elements.push(...findSanityNodes(node));
        }
    }
    return elements;
}
function isSanityArrayPath(path) {
    const lastDotIndex = path.lastIndexOf(".");
    return path.substring(lastDotIndex, path.length).includes("[");
}
function getSanityNodeArrayPath(path) {
    if (!isSanityArrayPath(path)) return null;
    const split = path.split(".");
    return split[split.length - 1] = split[split.length - 1].replace(/\[.*?\]/g, "[]"), split.join(".");
}
function sanityNodesExistInSameArray(sanityNode1, sanityNode2) {
    return !isSanityArrayPath(sanityNode1.path) || !isSanityArrayPath(sanityNode2.path) ? !1 : getSanityNodeArrayPath(sanityNode1.path) === getSanityNodeArrayPath(sanityNode2.path);
}
function resolveDragAndDropGroup(element, sanity, elementSet, elementsMap) {
    if (!element.getAttribute("data-sanity") || element.getAttribute("data-sanity-drag-disable") || !sanity || !isSanityNode(sanity) || !isSanityArrayPath(sanity.path)) return null;
    const targetDragGroup = element.getAttribute("data-sanity-drag-group"), group = [
        ...elementSet
    ].reduce((acc, el)=>{
        const elData = elementsMap.get(el), elDragDisabled = el.getAttribute("data-sanity-drag-disable"), elDragGroup = el.getAttribute("data-sanity-drag-group"), elHasSanityAttribution = el.getAttribute("data-sanity") !== null, sharedDragGroup = targetDragGroup !== null ? targetDragGroup === elDragGroup : !0;
        return elData && !elDragDisabled && isSanityNode(elData.sanity) && sanityNodesExistInSameArray(sanity, elData.sanity) && sharedDragGroup && elHasSanityAttribution && acc.push(elData), acc;
    }, []);
    return group.length <= 1 ? null : group;
}
function createOverlayController({ handler, overlayElement, inFrame, inPopUp, optimisticActorReady }) {
    let activated = !1;
    const elementIdMap = /* @__PURE__ */ new Map(), elementsMap = /* @__PURE__ */ new WeakMap(), elementSet = /* @__PURE__ */ new Set(), measureElements = /* @__PURE__ */ new WeakMap(), cursorMap = /* @__PURE__ */ new WeakMap();
    let ro, io, mo, activeDragSequence = !1, hoverStack = [];
    const getHoveredElement = ()=>hoverStack[hoverStack.length - 1];
    function addEventHandlers(el, handlers) {
        el.addEventListener("click", handlers.click, {
            capture: !0
        }), el.addEventListener("contextmenu", handlers.contextmenu, {
            capture: !0
        }), el.addEventListener("mousemove", handlers.mousemove, {
            once: !0,
            capture: !0
        }), el.addEventListener("mousedown", handlers.mousedown, {
            capture: !0
        });
    }
    function removeEventHandlers(el, handlers) {
        el.removeEventListener("click", handlers.click, {
            capture: !0
        }), el.removeEventListener("contextmenu", handlers.contextmenu, {
            capture: !0
        }), el.removeEventListener("mousemove", handlers.mousemove, {
            capture: !0
        }), el.removeEventListener("mousedown", handlers.mousedown, {
            capture: !0
        }), el.removeEventListener("mouseenter", handlers.mouseenter), el.removeEventListener("mouseleave", handlers.mouseleave);
    }
    function activateElement({ id, elements, handlers }) {
        const { element, measureElement } = elements;
        addEventHandlers(element, handlers), ro.observe(measureElement), handler({
            type: "element/activate",
            id
        });
    }
    function deactivateElement({ id, elements, handlers }) {
        const { element, measureElement } = elements;
        removeEventHandlers(element, handlers), ro.unobserve(measureElement), hoverStack = hoverStack.filter((el)=>el !== element), handler({
            type: "element/deactivate",
            id
        });
    }
    function setOverlayCursor(element) {
        if (!(!inFrame && !inPopUp || !optimisticActorReady)) for (const hoverstackElement of hoverStack){
            if (element === hoverstackElement) {
                const targetSanityData = elementsMap.get(element)?.sanity;
                if (!targetSanityData || !isSanityNode(targetSanityData)) return;
                if (resolveDragAndDropGroup(element, targetSanityData, elementSet, elementsMap)) {
                    const existingCursor = element.style.cursor;
                    existingCursor && cursorMap.set(element, existingCursor), handler({
                        type: "overlay/setCursor",
                        element,
                        cursor: "move"
                    });
                    continue;
                }
            }
            restoreOverlayCursor(hoverstackElement);
        }
    }
    function restoreOverlayCursor(element) {
        const previousCursor = cursorMap.get(element);
        handler({
            type: "overlay/setCursor",
            element,
            cursor: previousCursor
        });
    }
    function registerElement({ elements, sanity }) {
        const { element, measureElement } = elements, eventHandlers = {
            click (event) {
                const target = event.target;
                if (element === getHoveredElement() && element.contains(target)) {
                    inFrame && (event.preventDefault(), event.stopPropagation());
                    const sanity2 = elementsMap.get(element)?.sanity;
                    sanity2 && !activeDragSequence && handler({
                        type: "element/click",
                        id,
                        sanity: sanity2
                    });
                }
            },
            contextmenu (event) {
                if (!("path" in sanity) || !inFrame && !inPopUp || !optimisticActorReady || !sanity.path.split(".").pop()?.includes("[_key==")) return;
                const target = event.target;
                element === getHoveredElement() && element.contains(target) && ((inFrame || inPopUp) && (event.preventDefault(), event.stopPropagation()), handler({
                    type: "element/contextmenu",
                    id,
                    position: {
                        x: event.clientX,
                        y: event.clientY
                    },
                    sanity
                }));
            },
            mousedown (event) {
                if (event.preventDefault(), event.currentTarget !== hoverStack.at(-1) || element.getAttribute("data-sanity-drag-disable") || !inFrame && !inPopUp || !optimisticActorReady) return;
                const targetSanityData = elementsMap.get(element)?.sanity;
                if (!targetSanityData || !isSanityNode(targetSanityData) || !isSanityArrayPath(targetSanityData.path)) return;
                const dragGroup = resolveDragAndDropGroup(element, sanity, elementSet, elementsMap);
                dragGroup && handleOverlayDrag({
                    element,
                    handler,
                    mouseEvent: event,
                    overlayGroup: dragGroup,
                    target: targetSanityData,
                    onSequenceStart: ()=>{
                        activeDragSequence = !0;
                    },
                    onSequenceEnd: ()=>{
                        setTimeout(()=>{
                            activeDragSequence = !1;
                        }, 250);
                    }
                });
            },
            mousemove (event) {
                eventHandlers.mouseenter(event);
                const el = event.currentTarget;
                el && (el.addEventListener("mouseenter", eventHandlers.mouseenter), el.addEventListener("mouseleave", eventHandlers.mouseleave));
            },
            mouseenter () {
                document.querySelector("vercel-live-feedback") && element.closest("[data-vercel-edit-info]") || element.closest("[data-vercel-edit-target]") || (hoverStack.push(element), handler({
                    type: "element/mouseenter",
                    id,
                    rect: getRect(element)
                }), setOverlayCursor(element));
            },
            mouseleave (e) {
                function leave() {
                    hoverStack.pop();
                    const hoveredElement = getHoveredElement();
                    if (handler({
                        type: "element/mouseleave",
                        id
                    }), hoveredElement) {
                        setOverlayCursor(hoveredElement);
                        const overlayElement2 = elementsMap.get(hoveredElement);
                        overlayElement2 && handler({
                            type: "element/mouseenter",
                            id: overlayElement2.id,
                            rect: getRect(hoveredElement)
                        });
                    }
                    restoreOverlayCursor(element);
                }
                function addDeferredLeave(el) {
                    const deferredLeave = (e2)=>{
                        const { relatedTarget: relatedTarget2 } = e2;
                        findOverlayElement(relatedTarget2) ? relatedTarget2 && isElementNode$1(relatedTarget2) && (el.removeEventListener("mouseleave", deferredLeave), addDeferredLeave(relatedTarget2)) : (el.removeEventListener("mouseleave", deferredLeave), leave());
                    };
                    el.addEventListener("mouseleave", deferredLeave);
                }
                const { relatedTarget } = e, container = findOverlayElement(relatedTarget), isInteractiveOverlayElement = overlayElement.contains(container);
                if (isElementNode$1(container) && isInteractiveOverlayElement) return addDeferredLeave(container);
                leave();
            }
        }, id = v4(), sanityNode = {
            id,
            elements,
            sanity,
            handlers: eventHandlers
        };
        elementSet.add(element), measureElements.set(measureElement, element), elementIdMap.set(id, element), elementsMap.set(element, sanityNode), io?.observe(element), handler({
            type: "element/register",
            id,
            element,
            rect: getRect(element),
            sanity,
            dragDisabled: !!element.getAttribute("data-sanity-drag-disable")
        }), activated && activateElement(sanityNode);
    }
    function updateElement({ elements, sanity }) {
        const { element } = elements, overlayElement2 = elementsMap.get(element);
        overlayElement2 && (elementsMap.set(element, {
            ...overlayElement2,
            sanity
        }), handler({
            type: "element/update",
            id: overlayElement2.id,
            rect: getRect(element),
            sanity
        }));
    }
    function parseElements(node) {
        const sanityNodes = findSanityNodes(node);
        for (const sanityNode of sanityNodes){
            const { element } = sanityNode.elements;
            elementsMap.has(element) ? updateElement(sanityNode) : registerElement(sanityNode);
        }
    }
    function unregisterElement(element) {
        const overlayElement2 = elementsMap.get(element);
        if (overlayElement2) {
            const { id, handlers } = overlayElement2;
            removeEventHandlers(element, handlers), ro.unobserve(element), elementsMap.delete(element), elementSet.delete(element), elementIdMap.delete(id), handler({
                type: "element/unregister",
                id
            });
        }
    }
    function handleMutation(mutations) {
        let mutationWasInScope = !1;
        for (const mutation of mutations){
            const { target, type } = mutation, node = type === "characterData" ? target.parentElement : target;
            node === overlayElement || overlayElement.contains(node) || (mutationWasInScope = !0, isElementNode$1(node) && parseElements({
                childNodes: [
                    node
                ]
            }));
        }
        if (mutationWasInScope) for (const element of elementSet)element.isConnected || unregisterElement(element);
    }
    function updateRect(el) {
        const overlayElement2 = elementsMap.get(el);
        overlayElement2 && handler({
            type: "element/updateRect",
            id: overlayElement2.id,
            rect: getRect(el)
        });
    }
    function handleResize(entries) {
        for (const entry of entries){
            const target = entry.target;
            if (isElementNode$1(target)) {
                const element = measureElements.get(target);
                if (!element) return;
                updateRect(element);
            }
        }
    }
    function handleIntersection(entries) {
        if (activated) for (const entry of entries){
            const { target } = entry, match = isElementNode$1(target) && elementsMap.get(target);
            match && (entry.isIntersecting ? activateElement(match) : deactivateElement(match));
        }
    }
    function handleBlur(event) {
        const element = findOverlayElement(event.target);
        if (element) {
            element.dataset.sanityOverlayElement === "capture" && (event.preventDefault(), event.stopPropagation());
            return;
        }
        hoverStack = [], handler({
            type: "overlay/blur"
        });
    }
    function handleWindowResize() {
        for (const element of elementSet)updateRect(element);
    }
    function handleKeydown(event) {
        event.key === "Escape" && (hoverStack = [], handler({
            type: "overlay/blur"
        }));
    }
    function handleWindowScroll(event) {
        const { target } = event;
        if (!(target === window.document || !isElementNode$1(target))) for (const element of elementSet)target.contains(element) && updateRect(element);
    }
    function activate() {
        activated || (io = new IntersectionObserver(handleIntersection, {
            threshold: 0.3
        }), elementSet.forEach((element)=>io.observe(element)), handler({
            type: "overlay/activate"
        }), activated = !0);
    }
    function deactivate() {
        activated && (io?.disconnect(), elementSet.forEach((element)=>{
            const overlayElement2 = elementsMap.get(element);
            overlayElement2 && deactivateElement(overlayElement2);
        }), handler({
            type: "overlay/deactivate"
        }), activated = !1);
    }
    function destroy() {
        window.removeEventListener("click", handleBlur), window.removeEventListener("contextmenu", handleBlur), window.removeEventListener("keydown", handleKeydown), window.removeEventListener("resize", handleWindowResize), window.removeEventListener("scroll", handleWindowScroll), mo.disconnect(), ro.disconnect(), elementSet.forEach((element)=>{
            unregisterElement(element);
        }), elementIdMap.clear(), elementSet.clear(), hoverStack = [], deactivate();
    }
    function create() {
        window.addEventListener("click", handleBlur), window.addEventListener("contextmenu", handleBlur), window.addEventListener("keydown", handleKeydown), window.addEventListener("resize", handleWindowResize), window.addEventListener("scroll", handleWindowScroll, {
            capture: !0,
            passive: !0
        }), ro = new ResizeObserver(handleResize), mo = new MutationObserver(handleMutation), mo.observe(document.body, {
            attributes: !0,
            characterData: !0,
            childList: !0,
            subtree: !0
        }), parseElements(document.body), activate();
    }
    return window.document.fonts.ready.then(()=>{
        for (const element of elementSet)updateRect(element);
    }), create(), {
        activate,
        deactivate,
        destroy
    };
}
const SharedStateContext = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createContext"])(null);
;
 //# sourceMappingURL=SharedStateContext.js.map
}}),
"[project]/node_modules/swiper/shared/ssr-window.esm.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * SSR Window 5.0.0
 * Better handling for window object in SSR environment
 * https://github.com/nolimits4web/ssr-window
 *
 * Copyright 2025, Vladimir Kharlampidi
 *
 * Licensed under MIT
 *
 * Released on: February 12, 2025
 */ /* eslint-disable no-param-reassign */ __turbopack_context__.s({
    "a": (()=>getWindow),
    "g": (()=>getDocument)
});
function isObject(obj) {
    return obj !== null && typeof obj === 'object' && 'constructor' in obj && obj.constructor === Object;
}
function extend(target, src) {
    if (target === void 0) {
        target = {};
    }
    if (src === void 0) {
        src = {};
    }
    const noExtend = [
        '__proto__',
        'constructor',
        'prototype'
    ];
    Object.keys(src).filter((key)=>noExtend.indexOf(key) < 0).forEach((key)=>{
        if (typeof target[key] === 'undefined') target[key] = src[key];
        else if (isObject(src[key]) && isObject(target[key]) && Object.keys(src[key]).length > 0) {
            extend(target[key], src[key]);
        }
    });
}
const ssrDocument = {
    body: {},
    addEventListener () {},
    removeEventListener () {},
    activeElement: {
        blur () {},
        nodeName: ''
    },
    querySelector () {
        return null;
    },
    querySelectorAll () {
        return [];
    },
    getElementById () {
        return null;
    },
    createEvent () {
        return {
            initEvent () {}
        };
    },
    createElement () {
        return {
            children: [],
            childNodes: [],
            style: {},
            setAttribute () {},
            getElementsByTagName () {
                return [];
            }
        };
    },
    createElementNS () {
        return {};
    },
    importNode () {
        return null;
    },
    location: {
        hash: '',
        host: '',
        hostname: '',
        href: '',
        origin: '',
        pathname: '',
        protocol: '',
        search: ''
    }
};
function getDocument() {
    const doc = typeof document !== 'undefined' ? document : {};
    extend(doc, ssrDocument);
    return doc;
}
const ssrWindow = {
    document: ssrDocument,
    navigator: {
        userAgent: ''
    },
    location: {
        hash: '',
        host: '',
        hostname: '',
        href: '',
        origin: '',
        pathname: '',
        protocol: '',
        search: ''
    },
    history: {
        replaceState () {},
        pushState () {},
        go () {},
        back () {}
    },
    CustomEvent: function CustomEvent() {
        return this;
    },
    addEventListener () {},
    removeEventListener () {},
    getComputedStyle () {
        return {
            getPropertyValue () {
                return '';
            }
        };
    },
    Image () {},
    Date () {},
    screen: {},
    setTimeout () {},
    clearTimeout () {},
    matchMedia () {
        return {};
    },
    requestAnimationFrame (callback) {
        if (typeof setTimeout === 'undefined') {
            callback();
            return null;
        }
        return setTimeout(callback, 0);
    },
    cancelAnimationFrame (id) {
        if (typeof setTimeout === 'undefined') {
            return;
        }
        clearTimeout(id);
    }
};
function getWindow() {
    const win = typeof window !== 'undefined' ? window : {};
    extend(win, ssrWindow);
    return win;
}
;
}}),
"[project]/node_modules/swiper/shared/utils.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "a": (()=>elementParents),
    "b": (()=>elementOffset),
    "c": (()=>createElement),
    "d": (()=>now),
    "e": (()=>elementChildren),
    "f": (()=>elementOuterSize),
    "g": (()=>getSlideTransformEl),
    "h": (()=>elementIndex),
    "i": (()=>classesToTokens),
    "j": (()=>getTranslate),
    "k": (()=>elementTransitionEnd),
    "l": (()=>isObject),
    "m": (()=>makeElementsArray),
    "n": (()=>nextTick),
    "o": (()=>getRotateFix),
    "p": (()=>elementStyle),
    "q": (()=>elementNextAll),
    "r": (()=>elementPrevAll),
    "s": (()=>setCSSProperty),
    "t": (()=>animateCSSModeScroll),
    "u": (()=>showWarning),
    "v": (()=>elementIsChildOf),
    "w": (()=>extend),
    "x": (()=>deleteProps)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$ssr$2d$window$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/swiper/shared/ssr-window.esm.mjs [app-ssr] (ecmascript)");
;
function classesToTokens(classes) {
    if (classes === void 0) {
        classes = '';
    }
    return classes.trim().split(' ').filter((c)=>!!c.trim());
}
function deleteProps(obj) {
    const object = obj;
    Object.keys(object).forEach((key)=>{
        try {
            object[key] = null;
        } catch (e) {
        // no getter for object
        }
        try {
            delete object[key];
        } catch (e) {
        // something got wrong
        }
    });
}
function nextTick(callback, delay) {
    if (delay === void 0) {
        delay = 0;
    }
    return setTimeout(callback, delay);
}
function now() {
    return Date.now();
}
function getComputedStyle(el) {
    const window1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$ssr$2d$window$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"])();
    let style;
    if (window1.getComputedStyle) {
        style = window1.getComputedStyle(el, null);
    }
    if (!style && el.currentStyle) {
        style = el.currentStyle;
    }
    if (!style) {
        style = el.style;
    }
    return style;
}
function getTranslate(el, axis) {
    if (axis === void 0) {
        axis = 'x';
    }
    const window1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$ssr$2d$window$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"])();
    let matrix;
    let curTransform;
    let transformMatrix;
    const curStyle = getComputedStyle(el);
    if (window1.WebKitCSSMatrix) {
        curTransform = curStyle.transform || curStyle.webkitTransform;
        if (curTransform.split(',').length > 6) {
            curTransform = curTransform.split(', ').map((a)=>a.replace(',', '.')).join(', ');
        }
        // Some old versions of Webkit choke when 'none' is passed; pass
        // empty string instead in this case
        transformMatrix = new window1.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
    } else {
        transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
        matrix = transformMatrix.toString().split(',');
    }
    if (axis === 'x') {
        // Latest Chrome and webkits Fix
        if (window1.WebKitCSSMatrix) curTransform = transformMatrix.m41;
        else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);
        else curTransform = parseFloat(matrix[4]);
    }
    if (axis === 'y') {
        // Latest Chrome and webkits Fix
        if (window1.WebKitCSSMatrix) curTransform = transformMatrix.m42;
        else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);
        else curTransform = parseFloat(matrix[5]);
    }
    return curTransform || 0;
}
function isObject(o) {
    return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
}
function isNode(node) {
    // eslint-disable-next-line
    if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {
        return node instanceof HTMLElement;
    }
    return node && (node.nodeType === 1 || node.nodeType === 11);
}
function extend() {
    const to = Object(arguments.length <= 0 ? undefined : arguments[0]);
    const noExtend = [
        '__proto__',
        'constructor',
        'prototype'
    ];
    for(let i = 1; i < arguments.length; i += 1){
        const nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];
        if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {
            const keysArray = Object.keys(Object(nextSource)).filter((key)=>noExtend.indexOf(key) < 0);
            for(let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1){
                const nextKey = keysArray[nextIndex];
                const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                if (desc !== undefined && desc.enumerable) {
                    if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
                        if (nextSource[nextKey].__swiper__) {
                            to[nextKey] = nextSource[nextKey];
                        } else {
                            extend(to[nextKey], nextSource[nextKey]);
                        }
                    } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
                        to[nextKey] = {};
                        if (nextSource[nextKey].__swiper__) {
                            to[nextKey] = nextSource[nextKey];
                        } else {
                            extend(to[nextKey], nextSource[nextKey]);
                        }
                    } else {
                        to[nextKey] = nextSource[nextKey];
                    }
                }
            }
        }
    }
    return to;
}
function setCSSProperty(el, varName, varValue) {
    el.style.setProperty(varName, varValue);
}
function animateCSSModeScroll(_ref) {
    let { swiper, targetPosition, side } = _ref;
    const window1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$ssr$2d$window$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"])();
    const startPosition = -swiper.translate;
    let startTime = null;
    let time;
    const duration = swiper.params.speed;
    swiper.wrapperEl.style.scrollSnapType = 'none';
    window1.cancelAnimationFrame(swiper.cssModeFrameID);
    const dir = targetPosition > startPosition ? 'next' : 'prev';
    const isOutOfBound = (current, target)=>{
        return dir === 'next' && current >= target || dir === 'prev' && current <= target;
    };
    const animate = ()=>{
        time = new Date().getTime();
        if (startTime === null) {
            startTime = time;
        }
        const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
        const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
        let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
        if (isOutOfBound(currentPosition, targetPosition)) {
            currentPosition = targetPosition;
        }
        swiper.wrapperEl.scrollTo({
            [side]: currentPosition
        });
        if (isOutOfBound(currentPosition, targetPosition)) {
            swiper.wrapperEl.style.overflow = 'hidden';
            swiper.wrapperEl.style.scrollSnapType = '';
            setTimeout(()=>{
                swiper.wrapperEl.style.overflow = '';
                swiper.wrapperEl.scrollTo({
                    [side]: currentPosition
                });
            });
            window1.cancelAnimationFrame(swiper.cssModeFrameID);
            return;
        }
        swiper.cssModeFrameID = window1.requestAnimationFrame(animate);
    };
    animate();
}
function getSlideTransformEl(slideEl) {
    return slideEl.querySelector('.swiper-slide-transform') || slideEl.shadowRoot && slideEl.shadowRoot.querySelector('.swiper-slide-transform') || slideEl;
}
function elementChildren(element, selector) {
    if (selector === void 0) {
        selector = '';
    }
    const window1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$ssr$2d$window$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"])();
    const children = [
        ...element.children
    ];
    if (window1.HTMLSlotElement && element instanceof HTMLSlotElement) {
        children.push(...element.assignedElements());
    }
    if (!selector) {
        return children;
    }
    return children.filter((el)=>el.matches(selector));
}
function elementIsChildOfSlot(el, slot) {
    // Breadth-first search through all parent's children and assigned elements
    const elementsQueue = [
        slot
    ];
    while(elementsQueue.length > 0){
        const elementToCheck = elementsQueue.shift();
        if (el === elementToCheck) {
            return true;
        }
        elementsQueue.push(...elementToCheck.children, ...elementToCheck.shadowRoot ? elementToCheck.shadowRoot.children : [], ...elementToCheck.assignedElements ? elementToCheck.assignedElements() : []);
    }
}
function elementIsChildOf(el, parent) {
    const window1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$ssr$2d$window$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"])();
    let isChild = parent.contains(el);
    if (!isChild && window1.HTMLSlotElement && parent instanceof HTMLSlotElement) {
        const children = [
            ...parent.assignedElements()
        ];
        isChild = children.includes(el);
        if (!isChild) {
            isChild = elementIsChildOfSlot(el, parent);
        }
    }
    return isChild;
}
function showWarning(text) {
    try {
        console.warn(text);
        return;
    } catch (err) {
    // err
    }
}
function createElement(tag, classes) {
    if (classes === void 0) {
        classes = [];
    }
    const el = document.createElement(tag);
    el.classList.add(...Array.isArray(classes) ? classes : classesToTokens(classes));
    return el;
}
function elementOffset(el) {
    const window1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$ssr$2d$window$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"])();
    const document1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$ssr$2d$window$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["g"])();
    const box = el.getBoundingClientRect();
    const body = document1.body;
    const clientTop = el.clientTop || body.clientTop || 0;
    const clientLeft = el.clientLeft || body.clientLeft || 0;
    const scrollTop = el === window1 ? window1.scrollY : el.scrollTop;
    const scrollLeft = el === window1 ? window1.scrollX : el.scrollLeft;
    return {
        top: box.top + scrollTop - clientTop,
        left: box.left + scrollLeft - clientLeft
    };
}
function elementPrevAll(el, selector) {
    const prevEls = [];
    while(el.previousElementSibling){
        const prev = el.previousElementSibling; // eslint-disable-line
        if (selector) {
            if (prev.matches(selector)) prevEls.push(prev);
        } else prevEls.push(prev);
        el = prev;
    }
    return prevEls;
}
function elementNextAll(el, selector) {
    const nextEls = [];
    while(el.nextElementSibling){
        const next = el.nextElementSibling; // eslint-disable-line
        if (selector) {
            if (next.matches(selector)) nextEls.push(next);
        } else nextEls.push(next);
        el = next;
    }
    return nextEls;
}
function elementStyle(el, prop) {
    const window1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$ssr$2d$window$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"])();
    return window1.getComputedStyle(el, null).getPropertyValue(prop);
}
function elementIndex(el) {
    let child = el;
    let i;
    if (child) {
        i = 0;
        // eslint-disable-next-line
        while((child = child.previousSibling) !== null){
            if (child.nodeType === 1) i += 1;
        }
        return i;
    }
    return undefined;
}
function elementParents(el, selector) {
    const parents = []; // eslint-disable-line
    let parent = el.parentElement; // eslint-disable-line
    while(parent){
        if (selector) {
            if (parent.matches(selector)) parents.push(parent);
        } else {
            parents.push(parent);
        }
        parent = parent.parentElement;
    }
    return parents;
}
function elementTransitionEnd(el, callback) {
    function fireCallBack(e) {
        if (e.target !== el) return;
        callback.call(el, e);
        el.removeEventListener('transitionend', fireCallBack);
    }
    if (callback) {
        el.addEventListener('transitionend', fireCallBack);
    }
}
function elementOuterSize(el, size, includeMargins) {
    const window1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$ssr$2d$window$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"])();
    if (includeMargins) {
        return el[size === 'width' ? 'offsetWidth' : 'offsetHeight'] + parseFloat(window1.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-right' : 'margin-top')) + parseFloat(window1.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-left' : 'margin-bottom'));
    }
    return el.offsetWidth;
}
function makeElementsArray(el) {
    return (Array.isArray(el) ? el : [
        el
    ]).filter((e)=>!!e);
}
function getRotateFix(swiper) {
    return (v)=>{
        if (Math.abs(v) > 0 && swiper.browser && swiper.browser.need3dFix && Math.abs(v) % 90 === 0) {
            return v + 0.001;
        }
        return v;
    };
}
;
}}),
"[project]/node_modules/swiper/shared/swiper-core.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "S": (()=>Swiper),
    "d": (()=>defaults)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$ssr$2d$window$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/swiper/shared/ssr-window.esm.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/swiper/shared/utils.mjs [app-ssr] (ecmascript)");
;
;
let support;
function calcSupport() {
    const window1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$ssr$2d$window$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"])();
    const document1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$ssr$2d$window$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["g"])();
    return {
        smoothScroll: document1.documentElement && document1.documentElement.style && 'scrollBehavior' in document1.documentElement.style,
        touch: !!('ontouchstart' in window1 || window1.DocumentTouch && document1 instanceof window1.DocumentTouch)
    };
}
function getSupport() {
    if (!support) {
        support = calcSupport();
    }
    return support;
}
let deviceCached;
function calcDevice(_temp) {
    let { userAgent } = _temp === void 0 ? {} : _temp;
    const support = getSupport();
    const window1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$ssr$2d$window$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"])();
    const platform = window1.navigator.platform;
    const ua = userAgent || window1.navigator.userAgent;
    const device = {
        ios: false,
        android: false
    };
    const screenWidth = window1.screen.width;
    const screenHeight = window1.screen.height;
    const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line
    let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
    const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
    const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
    const windows = platform === 'Win32';
    let macos = platform === 'MacIntel';
    // iPadOs 13 fix
    const iPadScreens = [
        '1024x1366',
        '1366x1024',
        '834x1194',
        '1194x834',
        '834x1112',
        '1112x834',
        '768x1024',
        '1024x768',
        '820x1180',
        '1180x820',
        '810x1080',
        '1080x810'
    ];
    if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
        ipad = ua.match(/(Version)\/([\d.]+)/);
        if (!ipad) ipad = [
            0,
            1,
            '13_0_0'
        ];
        macos = false;
    }
    // Android
    if (android && !windows) {
        device.os = 'android';
        device.android = true;
    }
    if (ipad || iphone || ipod) {
        device.os = 'ios';
        device.ios = true;
    }
    // Export object
    return device;
}
function getDevice(overrides) {
    if (overrides === void 0) {
        overrides = {};
    }
    if (!deviceCached) {
        deviceCached = calcDevice(overrides);
    }
    return deviceCached;
}
let browser;
function calcBrowser() {
    const window1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$ssr$2d$window$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"])();
    const device = getDevice();
    let needPerspectiveFix = false;
    function isSafari() {
        const ua = window1.navigator.userAgent.toLowerCase();
        return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
    }
    if (isSafari()) {
        const ua = String(window1.navigator.userAgent);
        if (ua.includes('Version/')) {
            const [major, minor] = ua.split('Version/')[1].split(' ')[0].split('.').map((num)=>Number(num));
            needPerspectiveFix = major < 16 || major === 16 && minor < 2;
        }
    }
    const isWebView = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window1.navigator.userAgent);
    const isSafariBrowser = isSafari();
    const need3dFix = isSafariBrowser || isWebView && device.ios;
    return {
        isSafari: needPerspectiveFix || isSafariBrowser,
        needPerspectiveFix,
        need3dFix,
        isWebView
    };
}
function getBrowser() {
    if (!browser) {
        browser = calcBrowser();
    }
    return browser;
}
function Resize(_ref) {
    let { swiper, on, emit } = _ref;
    const window1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$ssr$2d$window$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"])();
    let observer = null;
    let animationFrame = null;
    const resizeHandler = ()=>{
        if (!swiper || swiper.destroyed || !swiper.initialized) return;
        emit('beforeResize');
        emit('resize');
    };
    const createObserver = ()=>{
        if (!swiper || swiper.destroyed || !swiper.initialized) return;
        observer = new ResizeObserver((entries)=>{
            animationFrame = window1.requestAnimationFrame(()=>{
                const { width, height } = swiper;
                let newWidth = width;
                let newHeight = height;
                entries.forEach((_ref2)=>{
                    let { contentBoxSize, contentRect, target } = _ref2;
                    if (target && target !== swiper.el) return;
                    newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
                    newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
                });
                if (newWidth !== width || newHeight !== height) {
                    resizeHandler();
                }
            });
        });
        observer.observe(swiper.el);
    };
    const removeObserver = ()=>{
        if (animationFrame) {
            window1.cancelAnimationFrame(animationFrame);
        }
        if (observer && observer.unobserve && swiper.el) {
            observer.unobserve(swiper.el);
            observer = null;
        }
    };
    const orientationChangeHandler = ()=>{
        if (!swiper || swiper.destroyed || !swiper.initialized) return;
        emit('orientationchange');
    };
    on('init', ()=>{
        if (swiper.params.resizeObserver && typeof window1.ResizeObserver !== 'undefined') {
            createObserver();
            return;
        }
        window1.addEventListener('resize', resizeHandler);
        window1.addEventListener('orientationchange', orientationChangeHandler);
    });
    on('destroy', ()=>{
        removeObserver();
        window1.removeEventListener('resize', resizeHandler);
        window1.removeEventListener('orientationchange', orientationChangeHandler);
    });
}
function Observer(_ref) {
    let { swiper, extendParams, on, emit } = _ref;
    const observers = [];
    const window1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$ssr$2d$window$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"])();
    const attach = function(target, options) {
        if (options === void 0) {
            options = {};
        }
        const ObserverFunc = window1.MutationObserver || window1.WebkitMutationObserver;
        const observer = new ObserverFunc((mutations)=>{
            // The observerUpdate event should only be triggered
            // once despite the number of mutations.  Additional
            // triggers are redundant and are very costly
            if (swiper.__preventObserver__) return;
            if (mutations.length === 1) {
                emit('observerUpdate', mutations[0]);
                return;
            }
            const observerUpdate = function observerUpdate() {
                emit('observerUpdate', mutations[0]);
            };
            if (window1.requestAnimationFrame) {
                window1.requestAnimationFrame(observerUpdate);
            } else {
                window1.setTimeout(observerUpdate, 0);
            }
        });
        observer.observe(target, {
            attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
            childList: swiper.isElement || (typeof options.childList === 'undefined' ? true : options).childList,
            characterData: typeof options.characterData === 'undefined' ? true : options.characterData
        });
        observers.push(observer);
    };
    const init = ()=>{
        if (!swiper.params.observer) return;
        if (swiper.params.observeParents) {
            const containerParents = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"])(swiper.hostEl);
            for(let i = 0; i < containerParents.length; i += 1){
                attach(containerParents[i]);
            }
        }
        // Observe container
        attach(swiper.hostEl, {
            childList: swiper.params.observeSlideChildren
        });
        // Observe wrapper
        attach(swiper.wrapperEl, {
            attributes: false
        });
    };
    const destroy = ()=>{
        observers.forEach((observer)=>{
            observer.disconnect();
        });
        observers.splice(0, observers.length);
    };
    extendParams({
        observer: false,
        observeParents: false,
        observeSlideChildren: false
    });
    on('init', init);
    on('destroy', destroy);
}
/* eslint-disable no-underscore-dangle */ var eventsEmitter = {
    on (events, handler, priority) {
        const self = this;
        if (!self.eventsListeners || self.destroyed) return self;
        if (typeof handler !== 'function') return self;
        const method = priority ? 'unshift' : 'push';
        events.split(' ').forEach((event)=>{
            if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
            self.eventsListeners[event][method](handler);
        });
        return self;
    },
    once (events, handler, priority) {
        const self = this;
        if (!self.eventsListeners || self.destroyed) return self;
        if (typeof handler !== 'function') return self;
        function onceHandler() {
            self.off(events, onceHandler);
            if (onceHandler.__emitterProxy) {
                delete onceHandler.__emitterProxy;
            }
            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                args[_key] = arguments[_key];
            }
            handler.apply(self, args);
        }
        onceHandler.__emitterProxy = handler;
        return self.on(events, onceHandler, priority);
    },
    onAny (handler, priority) {
        const self = this;
        if (!self.eventsListeners || self.destroyed) return self;
        if (typeof handler !== 'function') return self;
        const method = priority ? 'unshift' : 'push';
        if (self.eventsAnyListeners.indexOf(handler) < 0) {
            self.eventsAnyListeners[method](handler);
        }
        return self;
    },
    offAny (handler) {
        const self = this;
        if (!self.eventsListeners || self.destroyed) return self;
        if (!self.eventsAnyListeners) return self;
        const index = self.eventsAnyListeners.indexOf(handler);
        if (index >= 0) {
            self.eventsAnyListeners.splice(index, 1);
        }
        return self;
    },
    off (events, handler) {
        const self = this;
        if (!self.eventsListeners || self.destroyed) return self;
        if (!self.eventsListeners) return self;
        events.split(' ').forEach((event)=>{
            if (typeof handler === 'undefined') {
                self.eventsListeners[event] = [];
            } else if (self.eventsListeners[event]) {
                self.eventsListeners[event].forEach((eventHandler, index)=>{
                    if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
                        self.eventsListeners[event].splice(index, 1);
                    }
                });
            }
        });
        return self;
    },
    emit () {
        const self = this;
        if (!self.eventsListeners || self.destroyed) return self;
        if (!self.eventsListeners) return self;
        let events;
        let data;
        let context;
        for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){
            args[_key2] = arguments[_key2];
        }
        if (typeof args[0] === 'string' || Array.isArray(args[0])) {
            events = args[0];
            data = args.slice(1, args.length);
            context = self;
        } else {
            events = args[0].events;
            data = args[0].data;
            context = args[0].context || self;
        }
        data.unshift(context);
        const eventsArray = Array.isArray(events) ? events : events.split(' ');
        eventsArray.forEach((event)=>{
            if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
                self.eventsAnyListeners.forEach((eventHandler)=>{
                    eventHandler.apply(context, [
                        event,
                        ...data
                    ]);
                });
            }
            if (self.eventsListeners && self.eventsListeners[event]) {
                self.eventsListeners[event].forEach((eventHandler)=>{
                    eventHandler.apply(context, data);
                });
            }
        });
        return self;
    }
};
function updateSize() {
    const swiper = this;
    let width;
    let height;
    const el = swiper.el;
    if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {
        width = swiper.params.width;
    } else {
        width = el.clientWidth;
    }
    if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {
        height = swiper.params.height;
    } else {
        height = el.clientHeight;
    }
    if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
        return;
    }
    // Subtract paddings
    width = width - parseInt((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"])(el, 'padding-left') || 0, 10) - parseInt((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"])(el, 'padding-right') || 0, 10);
    height = height - parseInt((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"])(el, 'padding-top') || 0, 10) - parseInt((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"])(el, 'padding-bottom') || 0, 10);
    if (Number.isNaN(width)) width = 0;
    if (Number.isNaN(height)) height = 0;
    Object.assign(swiper, {
        width,
        height,
        size: swiper.isHorizontal() ? width : height
    });
}
function updateSlides() {
    const swiper = this;
    function getDirectionPropertyValue(node, label) {
        return parseFloat(node.getPropertyValue(swiper.getDirectionLabel(label)) || 0);
    }
    const params = swiper.params;
    const { wrapperEl, slidesEl, size: swiperSize, rtlTranslate: rtl, wrongRTL } = swiper;
    const isVirtual = swiper.virtual && params.virtual.enabled;
    const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
    const slides = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["e"])(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);
    const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
    let snapGrid = [];
    const slidesGrid = [];
    const slidesSizesGrid = [];
    let offsetBefore = params.slidesOffsetBefore;
    if (typeof offsetBefore === 'function') {
        offsetBefore = params.slidesOffsetBefore.call(swiper);
    }
    let offsetAfter = params.slidesOffsetAfter;
    if (typeof offsetAfter === 'function') {
        offsetAfter = params.slidesOffsetAfter.call(swiper);
    }
    const previousSnapGridLength = swiper.snapGrid.length;
    const previousSlidesGridLength = swiper.slidesGrid.length;
    let spaceBetween = params.spaceBetween;
    let slidePosition = -offsetBefore;
    let prevSlideSize = 0;
    let index = 0;
    if (typeof swiperSize === 'undefined') {
        return;
    }
    if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
        spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
    } else if (typeof spaceBetween === 'string') {
        spaceBetween = parseFloat(spaceBetween);
    }
    swiper.virtualSize = -spaceBetween;
    // reset margins
    slides.forEach((slideEl)=>{
        if (rtl) {
            slideEl.style.marginLeft = '';
        } else {
            slideEl.style.marginRight = '';
        }
        slideEl.style.marginBottom = '';
        slideEl.style.marginTop = '';
    });
    // reset cssMode offsets
    if (params.centeredSlides && params.cssMode) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["s"])(wrapperEl, '--swiper-centered-offset-before', '');
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["s"])(wrapperEl, '--swiper-centered-offset-after', '');
    }
    const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
    if (gridEnabled) {
        swiper.grid.initSlides(slides);
    } else if (swiper.grid) {
        swiper.grid.unsetSlides();
    }
    // Calc slides
    let slideSize;
    const shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter((key)=>{
        return typeof params.breakpoints[key].slidesPerView !== 'undefined';
    }).length > 0;
    for(let i = 0; i < slidesLength; i += 1){
        slideSize = 0;
        let slide;
        if (slides[i]) slide = slides[i];
        if (gridEnabled) {
            swiper.grid.updateSlide(i, slide, slides);
        }
        if (slides[i] && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"])(slide, 'display') === 'none') continue; // eslint-disable-line
        if (params.slidesPerView === 'auto') {
            if (shouldResetSlideSize) {
                slides[i].style[swiper.getDirectionLabel('width')] = ``;
            }
            const slideStyles = getComputedStyle(slide);
            const currentTransform = slide.style.transform;
            const currentWebKitTransform = slide.style.webkitTransform;
            if (currentTransform) {
                slide.style.transform = 'none';
            }
            if (currentWebKitTransform) {
                slide.style.webkitTransform = 'none';
            }
            if (params.roundLengths) {
                slideSize = swiper.isHorizontal() ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["f"])(slide, 'width', true) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["f"])(slide, 'height', true);
            } else {
                // eslint-disable-next-line
                const width = getDirectionPropertyValue(slideStyles, 'width');
                const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');
                const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');
                const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');
                const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');
                const boxSizing = slideStyles.getPropertyValue('box-sizing');
                if (boxSizing && boxSizing === 'border-box') {
                    slideSize = width + marginLeft + marginRight;
                } else {
                    const { clientWidth, offsetWidth } = slide;
                    slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
                }
            }
            if (currentTransform) {
                slide.style.transform = currentTransform;
            }
            if (currentWebKitTransform) {
                slide.style.webkitTransform = currentWebKitTransform;
            }
            if (params.roundLengths) slideSize = Math.floor(slideSize);
        } else {
            slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
            if (params.roundLengths) slideSize = Math.floor(slideSize);
            if (slides[i]) {
                slides[i].style[swiper.getDirectionLabel('width')] = `${slideSize}px`;
            }
        }
        if (slides[i]) {
            slides[i].swiperSlideSize = slideSize;
        }
        slidesSizesGrid.push(slideSize);
        if (params.centeredSlides) {
            slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
            if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
            if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
            if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
            if (params.roundLengths) slidePosition = Math.floor(slidePosition);
            if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
            slidesGrid.push(slidePosition);
        } else {
            if (params.roundLengths) slidePosition = Math.floor(slidePosition);
            if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
            slidesGrid.push(slidePosition);
            slidePosition = slidePosition + slideSize + spaceBetween;
        }
        swiper.virtualSize += slideSize + spaceBetween;
        prevSlideSize = slideSize;
        index += 1;
    }
    swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
    if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
        wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;
    }
    if (params.setWrapperSize) {
        wrapperEl.style[swiper.getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;
    }
    if (gridEnabled) {
        swiper.grid.updateWrapperSize(slideSize, snapGrid);
    }
    // Remove last grid elements depending on width
    if (!params.centeredSlides) {
        const newSlidesGrid = [];
        for(let i = 0; i < snapGrid.length; i += 1){
            let slidesGridItem = snapGrid[i];
            if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
            if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
                newSlidesGrid.push(slidesGridItem);
            }
        }
        snapGrid = newSlidesGrid;
        if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
            snapGrid.push(swiper.virtualSize - swiperSize);
        }
    }
    if (isVirtual && params.loop) {
        const size = slidesSizesGrid[0] + spaceBetween;
        if (params.slidesPerGroup > 1) {
            const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);
            const groupSize = size * params.slidesPerGroup;
            for(let i = 0; i < groups; i += 1){
                snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);
            }
        }
        for(let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1){
            if (params.slidesPerGroup === 1) {
                snapGrid.push(snapGrid[snapGrid.length - 1] + size);
            }
            slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);
            swiper.virtualSize += size;
        }
    }
    if (snapGrid.length === 0) snapGrid = [
        0
    ];
    if (spaceBetween !== 0) {
        const key = swiper.isHorizontal() && rtl ? 'marginLeft' : swiper.getDirectionLabel('marginRight');
        slides.filter((_, slideIndex)=>{
            if (!params.cssMode || params.loop) return true;
            if (slideIndex === slides.length - 1) {
                return false;
            }
            return true;
        }).forEach((slideEl)=>{
            slideEl.style[key] = `${spaceBetween}px`;
        });
    }
    if (params.centeredSlides && params.centeredSlidesBounds) {
        let allSlidesSize = 0;
        slidesSizesGrid.forEach((slideSizeValue)=>{
            allSlidesSize += slideSizeValue + (spaceBetween || 0);
        });
        allSlidesSize -= spaceBetween;
        const maxSnap = allSlidesSize > swiperSize ? allSlidesSize - swiperSize : 0;
        snapGrid = snapGrid.map((snap)=>{
            if (snap <= 0) return -offsetBefore;
            if (snap > maxSnap) return maxSnap + offsetAfter;
            return snap;
        });
    }
    if (params.centerInsufficientSlides) {
        let allSlidesSize = 0;
        slidesSizesGrid.forEach((slideSizeValue)=>{
            allSlidesSize += slideSizeValue + (spaceBetween || 0);
        });
        allSlidesSize -= spaceBetween;
        const offsetSize = (params.slidesOffsetBefore || 0) + (params.slidesOffsetAfter || 0);
        if (allSlidesSize + offsetSize < swiperSize) {
            const allSlidesOffset = (swiperSize - allSlidesSize - offsetSize) / 2;
            snapGrid.forEach((snap, snapIndex)=>{
                snapGrid[snapIndex] = snap - allSlidesOffset;
            });
            slidesGrid.forEach((snap, snapIndex)=>{
                slidesGrid[snapIndex] = snap + allSlidesOffset;
            });
        }
    }
    Object.assign(swiper, {
        slides,
        snapGrid,
        slidesGrid,
        slidesSizesGrid
    });
    if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["s"])(wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["s"])(wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
        const addToSnapGrid = -swiper.snapGrid[0];
        const addToSlidesGrid = -swiper.slidesGrid[0];
        swiper.snapGrid = swiper.snapGrid.map((v)=>v + addToSnapGrid);
        swiper.slidesGrid = swiper.slidesGrid.map((v)=>v + addToSlidesGrid);
    }
    if (slidesLength !== previousSlidesLength) {
        swiper.emit('slidesLengthChange');
    }
    if (snapGrid.length !== previousSnapGridLength) {
        if (swiper.params.watchOverflow) swiper.checkOverflow();
        swiper.emit('snapGridLengthChange');
    }
    if (slidesGrid.length !== previousSlidesGridLength) {
        swiper.emit('slidesGridLengthChange');
    }
    if (params.watchSlidesProgress) {
        swiper.updateSlidesOffset();
    }
    swiper.emit('slidesUpdated');
    if (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {
        const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
        const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);
        if (slidesLength <= params.maxBackfaceHiddenSlides) {
            if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);
        } else if (hasClassBackfaceClassAdded) {
            swiper.el.classList.remove(backFaceHiddenClass);
        }
    }
}
function updateAutoHeight(speed) {
    const swiper = this;
    const activeSlides = [];
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    let newHeight = 0;
    let i;
    if (typeof speed === 'number') {
        swiper.setTransition(speed);
    } else if (speed === true) {
        swiper.setTransition(swiper.params.speed);
    }
    const getSlideByIndex = (index)=>{
        if (isVirtual) {
            return swiper.slides[swiper.getSlideIndexByData(index)];
        }
        return swiper.slides[index];
    };
    // Find slides currently in view
    if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
        if (swiper.params.centeredSlides) {
            (swiper.visibleSlides || []).forEach((slide)=>{
                activeSlides.push(slide);
            });
        } else {
            for(i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1){
                const index = swiper.activeIndex + i;
                if (index > swiper.slides.length && !isVirtual) break;
                activeSlides.push(getSlideByIndex(index));
            }
        }
    } else {
        activeSlides.push(getSlideByIndex(swiper.activeIndex));
    }
    // Find new height from highest slide in view
    for(i = 0; i < activeSlides.length; i += 1){
        if (typeof activeSlides[i] !== 'undefined') {
            const height = activeSlides[i].offsetHeight;
            newHeight = height > newHeight ? height : newHeight;
        }
    }
    // Update Height
    if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;
}
function updateSlidesOffset() {
    const swiper = this;
    const slides = swiper.slides;
    // eslint-disable-next-line
    const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;
    for(let i = 0; i < slides.length; i += 1){
        slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();
    }
}
const toggleSlideClasses$1 = (slideEl, condition, className)=>{
    if (condition && !slideEl.classList.contains(className)) {
        slideEl.classList.add(className);
    } else if (!condition && slideEl.classList.contains(className)) {
        slideEl.classList.remove(className);
    }
};
function updateSlidesProgress(translate) {
    if (translate === void 0) {
        translate = this && this.translate || 0;
    }
    const swiper = this;
    const params = swiper.params;
    const { slides, rtlTranslate: rtl, snapGrid } = swiper;
    if (slides.length === 0) return;
    if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
    let offsetCenter = -translate;
    if (rtl) offsetCenter = translate;
    swiper.visibleSlidesIndexes = [];
    swiper.visibleSlides = [];
    let spaceBetween = params.spaceBetween;
    if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
        spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiper.size;
    } else if (typeof spaceBetween === 'string') {
        spaceBetween = parseFloat(spaceBetween);
    }
    for(let i = 0; i < slides.length; i += 1){
        const slide = slides[i];
        let slideOffset = slide.swiperSlideOffset;
        if (params.cssMode && params.centeredSlides) {
            slideOffset -= slides[0].swiperSlideOffset;
        }
        const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);
        const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);
        const slideBefore = -(offsetCenter - slideOffset);
        const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
        const isFullyVisible = slideBefore >= 0 && slideBefore <= swiper.size - swiper.slidesSizesGrid[i];
        const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
        if (isVisible) {
            swiper.visibleSlides.push(slide);
            swiper.visibleSlidesIndexes.push(i);
        }
        toggleSlideClasses$1(slide, isVisible, params.slideVisibleClass);
        toggleSlideClasses$1(slide, isFullyVisible, params.slideFullyVisibleClass);
        slide.progress = rtl ? -slideProgress : slideProgress;
        slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
    }
}
function updateProgress(translate) {
    const swiper = this;
    if (typeof translate === 'undefined') {
        const multiplier = swiper.rtlTranslate ? -1 : 1;
        // eslint-disable-next-line
        translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
    }
    const params = swiper.params;
    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    let { progress, isBeginning, isEnd, progressLoop } = swiper;
    const wasBeginning = isBeginning;
    const wasEnd = isEnd;
    if (translatesDiff === 0) {
        progress = 0;
        isBeginning = true;
        isEnd = true;
    } else {
        progress = (translate - swiper.minTranslate()) / translatesDiff;
        const isBeginningRounded = Math.abs(translate - swiper.minTranslate()) < 1;
        const isEndRounded = Math.abs(translate - swiper.maxTranslate()) < 1;
        isBeginning = isBeginningRounded || progress <= 0;
        isEnd = isEndRounded || progress >= 1;
        if (isBeginningRounded) progress = 0;
        if (isEndRounded) progress = 1;
    }
    if (params.loop) {
        const firstSlideIndex = swiper.getSlideIndexByData(0);
        const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);
        const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];
        const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];
        const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];
        const translateAbs = Math.abs(translate);
        if (translateAbs >= firstSlideTranslate) {
            progressLoop = (translateAbs - firstSlideTranslate) / translateMax;
        } else {
            progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;
        }
        if (progressLoop > 1) progressLoop -= 1;
    }
    Object.assign(swiper, {
        progress,
        progressLoop,
        isBeginning,
        isEnd
    });
    if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);
    if (isBeginning && !wasBeginning) {
        swiper.emit('reachBeginning toEdge');
    }
    if (isEnd && !wasEnd) {
        swiper.emit('reachEnd toEdge');
    }
    if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
        swiper.emit('fromEdge');
    }
    swiper.emit('progress', progress);
}
const toggleSlideClasses = (slideEl, condition, className)=>{
    if (condition && !slideEl.classList.contains(className)) {
        slideEl.classList.add(className);
    } else if (!condition && slideEl.classList.contains(className)) {
        slideEl.classList.remove(className);
    }
};
function updateSlidesClasses() {
    const swiper = this;
    const { slides, params, slidesEl, activeIndex } = swiper;
    const isVirtual = swiper.virtual && params.virtual.enabled;
    const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
    const getFilteredSlide = (selector)=>{
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["e"])(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];
    };
    let activeSlide;
    let prevSlide;
    let nextSlide;
    if (isVirtual) {
        if (params.loop) {
            let slideIndex = activeIndex - swiper.virtual.slidesBefore;
            if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;
            if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;
            activeSlide = getFilteredSlide(`[data-swiper-slide-index="${slideIndex}"]`);
        } else {
            activeSlide = getFilteredSlide(`[data-swiper-slide-index="${activeIndex}"]`);
        }
    } else {
        if (gridEnabled) {
            activeSlide = slides.find((slideEl)=>slideEl.column === activeIndex);
            nextSlide = slides.find((slideEl)=>slideEl.column === activeIndex + 1);
            prevSlide = slides.find((slideEl)=>slideEl.column === activeIndex - 1);
        } else {
            activeSlide = slides[activeIndex];
        }
    }
    if (activeSlide) {
        if (!gridEnabled) {
            // Next Slide
            nextSlide = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["q"])(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
            if (params.loop && !nextSlide) {
                nextSlide = slides[0];
            }
            // Prev Slide
            prevSlide = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["r"])(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
            if (params.loop && !prevSlide === 0) {
                prevSlide = slides[slides.length - 1];
            }
        }
    }
    slides.forEach((slideEl)=>{
        toggleSlideClasses(slideEl, slideEl === activeSlide, params.slideActiveClass);
        toggleSlideClasses(slideEl, slideEl === nextSlide, params.slideNextClass);
        toggleSlideClasses(slideEl, slideEl === prevSlide, params.slidePrevClass);
    });
    swiper.emitSlidesClasses();
}
const processLazyPreloader = (swiper, imageEl)=>{
    if (!swiper || swiper.destroyed || !swiper.params) return;
    const slideSelector = ()=>swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;
    const slideEl = imageEl.closest(slideSelector());
    if (slideEl) {
        let lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);
        if (!lazyEl && swiper.isElement) {
            if (slideEl.shadowRoot) {
                lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);
            } else {
                // init later
                requestAnimationFrame(()=>{
                    if (slideEl.shadowRoot) {
                        lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);
                        if (lazyEl) lazyEl.remove();
                    }
                });
            }
        }
        if (lazyEl) lazyEl.remove();
    }
};
const unlazy = (swiper, index)=>{
    if (!swiper.slides[index]) return;
    const imageEl = swiper.slides[index].querySelector('[loading="lazy"]');
    if (imageEl) imageEl.removeAttribute('loading');
};
const preload = (swiper)=>{
    if (!swiper || swiper.destroyed || !swiper.params) return;
    let amount = swiper.params.lazyPreloadPrevNext;
    const len = swiper.slides.length;
    if (!len || !amount || amount < 0) return;
    amount = Math.min(amount, len);
    const slidesPerView = swiper.params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);
    const activeIndex = swiper.activeIndex;
    if (swiper.params.grid && swiper.params.grid.rows > 1) {
        const activeColumn = activeIndex;
        const preloadColumns = [
            activeColumn - amount
        ];
        preloadColumns.push(...Array.from({
            length: amount
        }).map((_, i)=>{
            return activeColumn + slidesPerView + i;
        }));
        swiper.slides.forEach((slideEl, i)=>{
            if (preloadColumns.includes(slideEl.column)) unlazy(swiper, i);
        });
        return;
    }
    const slideIndexLastInView = activeIndex + slidesPerView - 1;
    if (swiper.params.rewind || swiper.params.loop) {
        for(let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1){
            const realIndex = (i % len + len) % len;
            if (realIndex < activeIndex || realIndex > slideIndexLastInView) unlazy(swiper, realIndex);
        }
    } else {
        for(let i = Math.max(activeIndex - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1){
            if (i !== activeIndex && (i > slideIndexLastInView || i < activeIndex)) {
                unlazy(swiper, i);
            }
        }
    }
};
function getActiveIndexByTranslate(swiper) {
    const { slidesGrid, params } = swiper;
    const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
    let activeIndex;
    for(let i = 0; i < slidesGrid.length; i += 1){
        if (typeof slidesGrid[i + 1] !== 'undefined') {
            if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
                activeIndex = i;
            } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
                activeIndex = i + 1;
            }
        } else if (translate >= slidesGrid[i]) {
            activeIndex = i;
        }
    }
    // Normalize slideIndex
    if (params.normalizeSlideIndex) {
        if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
    }
    return activeIndex;
}
function updateActiveIndex(newActiveIndex) {
    const swiper = this;
    const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
    const { snapGrid, params, activeIndex: previousIndex, realIndex: previousRealIndex, snapIndex: previousSnapIndex } = swiper;
    let activeIndex = newActiveIndex;
    let snapIndex;
    const getVirtualRealIndex = (aIndex)=>{
        let realIndex = aIndex - swiper.virtual.slidesBefore;
        if (realIndex < 0) {
            realIndex = swiper.virtual.slides.length + realIndex;
        }
        if (realIndex >= swiper.virtual.slides.length) {
            realIndex -= swiper.virtual.slides.length;
        }
        return realIndex;
    };
    if (typeof activeIndex === 'undefined') {
        activeIndex = getActiveIndexByTranslate(swiper);
    }
    if (snapGrid.indexOf(translate) >= 0) {
        snapIndex = snapGrid.indexOf(translate);
    } else {
        const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
        snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
    }
    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
    if (activeIndex === previousIndex && !swiper.params.loop) {
        if (snapIndex !== previousSnapIndex) {
            swiper.snapIndex = snapIndex;
            swiper.emit('snapIndexChange');
        }
        return;
    }
    if (activeIndex === previousIndex && swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
        swiper.realIndex = getVirtualRealIndex(activeIndex);
        return;
    }
    const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
    // Get real index
    let realIndex;
    if (swiper.virtual && params.virtual.enabled && params.loop) {
        realIndex = getVirtualRealIndex(activeIndex);
    } else if (gridEnabled) {
        const firstSlideInColumn = swiper.slides.find((slideEl)=>slideEl.column === activeIndex);
        let activeSlideIndex = parseInt(firstSlideInColumn.getAttribute('data-swiper-slide-index'), 10);
        if (Number.isNaN(activeSlideIndex)) {
            activeSlideIndex = Math.max(swiper.slides.indexOf(firstSlideInColumn), 0);
        }
        realIndex = Math.floor(activeSlideIndex / params.grid.rows);
    } else if (swiper.slides[activeIndex]) {
        const slideIndex = swiper.slides[activeIndex].getAttribute('data-swiper-slide-index');
        if (slideIndex) {
            realIndex = parseInt(slideIndex, 10);
        } else {
            realIndex = activeIndex;
        }
    } else {
        realIndex = activeIndex;
    }
    Object.assign(swiper, {
        previousSnapIndex,
        snapIndex,
        previousRealIndex,
        realIndex,
        previousIndex,
        activeIndex
    });
    if (swiper.initialized) {
        preload(swiper);
    }
    swiper.emit('activeIndexChange');
    swiper.emit('snapIndexChange');
    if (swiper.initialized || swiper.params.runCallbacksOnInit) {
        if (previousRealIndex !== realIndex) {
            swiper.emit('realIndexChange');
        }
        swiper.emit('slideChange');
    }
}
function updateClickedSlide(el, path) {
    const swiper = this;
    const params = swiper.params;
    let slide = el.closest(`.${params.slideClass}, swiper-slide`);
    if (!slide && swiper.isElement && path && path.length > 1 && path.includes(el)) {
        [
            ...path.slice(path.indexOf(el) + 1, path.length)
        ].forEach((pathEl)=>{
            if (!slide && pathEl.matches && pathEl.matches(`.${params.slideClass}, swiper-slide`)) {
                slide = pathEl;
            }
        });
    }
    let slideFound = false;
    let slideIndex;
    if (slide) {
        for(let i = 0; i < swiper.slides.length; i += 1){
            if (swiper.slides[i] === slide) {
                slideFound = true;
                slideIndex = i;
                break;
            }
        }
    }
    if (slide && slideFound) {
        swiper.clickedSlide = slide;
        if (swiper.virtual && swiper.params.virtual.enabled) {
            swiper.clickedIndex = parseInt(slide.getAttribute('data-swiper-slide-index'), 10);
        } else {
            swiper.clickedIndex = slideIndex;
        }
    } else {
        swiper.clickedSlide = undefined;
        swiper.clickedIndex = undefined;
        return;
    }
    if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
        swiper.slideToClickedSlide();
    }
}
var update = {
    updateSize,
    updateSlides,
    updateAutoHeight,
    updateSlidesOffset,
    updateSlidesProgress,
    updateProgress,
    updateSlidesClasses,
    updateActiveIndex,
    updateClickedSlide
};
function getSwiperTranslate(axis) {
    if (axis === void 0) {
        axis = this.isHorizontal() ? 'x' : 'y';
    }
    const swiper = this;
    const { params, rtlTranslate: rtl, translate, wrapperEl } = swiper;
    if (params.virtualTranslate) {
        return rtl ? -translate : translate;
    }
    if (params.cssMode) {
        return translate;
    }
    let currentTranslate = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["j"])(wrapperEl, axis);
    currentTranslate += swiper.cssOverflowAdjustment();
    if (rtl) currentTranslate = -currentTranslate;
    return currentTranslate || 0;
}
function setTranslate(translate, byController) {
    const swiper = this;
    const { rtlTranslate: rtl, params, wrapperEl, progress } = swiper;
    let x = 0;
    let y = 0;
    const z = 0;
    if (swiper.isHorizontal()) {
        x = rtl ? -translate : translate;
    } else {
        y = translate;
    }
    if (params.roundLengths) {
        x = Math.floor(x);
        y = Math.floor(y);
    }
    swiper.previousTranslate = swiper.translate;
    swiper.translate = swiper.isHorizontal() ? x : y;
    if (params.cssMode) {
        wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
    } else if (!params.virtualTranslate) {
        if (swiper.isHorizontal()) {
            x -= swiper.cssOverflowAdjustment();
        } else {
            y -= swiper.cssOverflowAdjustment();
        }
        wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;
    }
    // Check if we need to update progress
    let newProgress;
    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    if (translatesDiff === 0) {
        newProgress = 0;
    } else {
        newProgress = (translate - swiper.minTranslate()) / translatesDiff;
    }
    if (newProgress !== progress) {
        swiper.updateProgress(translate);
    }
    swiper.emit('setTranslate', swiper.translate, byController);
}
function minTranslate() {
    return -this.snapGrid[0];
}
function maxTranslate() {
    return -this.snapGrid[this.snapGrid.length - 1];
}
function translateTo(translate, speed, runCallbacks, translateBounds, internal) {
    if (translate === void 0) {
        translate = 0;
    }
    if (speed === void 0) {
        speed = this.params.speed;
    }
    if (runCallbacks === void 0) {
        runCallbacks = true;
    }
    if (translateBounds === void 0) {
        translateBounds = true;
    }
    const swiper = this;
    const { params, wrapperEl } = swiper;
    if (swiper.animating && params.preventInteractionOnTransition) {
        return false;
    }
    const minTranslate = swiper.minTranslate();
    const maxTranslate = swiper.maxTranslate();
    let newTranslate;
    if (translateBounds && translate > minTranslate) newTranslate = minTranslate;
    else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;
    else newTranslate = translate;
    // Update progress
    swiper.updateProgress(newTranslate);
    if (params.cssMode) {
        const isH = swiper.isHorizontal();
        if (speed === 0) {
            wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
        } else {
            if (!swiper.support.smoothScroll) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["t"])({
                    swiper,
                    targetPosition: -newTranslate,
                    side: isH ? 'left' : 'top'
                });
                return true;
            }
            wrapperEl.scrollTo({
                [isH ? 'left' : 'top']: -newTranslate,
                behavior: 'smooth'
            });
        }
        return true;
    }
    if (speed === 0) {
        swiper.setTransition(0);
        swiper.setTranslate(newTranslate);
        if (runCallbacks) {
            swiper.emit('beforeTransitionStart', speed, internal);
            swiper.emit('transitionEnd');
        }
    } else {
        swiper.setTransition(speed);
        swiper.setTranslate(newTranslate);
        if (runCallbacks) {
            swiper.emit('beforeTransitionStart', speed, internal);
            swiper.emit('transitionStart');
        }
        if (!swiper.animating) {
            swiper.animating = true;
            if (!swiper.onTranslateToWrapperTransitionEnd) {
                swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
                    if (!swiper || swiper.destroyed) return;
                    if (e.target !== this) return;
                    swiper.wrapperEl.removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
                    swiper.onTranslateToWrapperTransitionEnd = null;
                    delete swiper.onTranslateToWrapperTransitionEnd;
                    swiper.animating = false;
                    if (runCallbacks) {
                        swiper.emit('transitionEnd');
                    }
                };
            }
            swiper.wrapperEl.addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
        }
    }
    return true;
}
var translate = {
    getTranslate: getSwiperTranslate,
    setTranslate,
    minTranslate,
    maxTranslate,
    translateTo
};
function setTransition(duration, byController) {
    const swiper = this;
    if (!swiper.params.cssMode) {
        swiper.wrapperEl.style.transitionDuration = `${duration}ms`;
        swiper.wrapperEl.style.transitionDelay = duration === 0 ? `0ms` : '';
    }
    swiper.emit('setTransition', duration, byController);
}
function transitionEmit(_ref) {
    let { swiper, runCallbacks, direction, step } = _ref;
    const { activeIndex, previousIndex } = swiper;
    let dir = direction;
    if (!dir) {
        if (activeIndex > previousIndex) dir = 'next';
        else if (activeIndex < previousIndex) dir = 'prev';
        else dir = 'reset';
    }
    swiper.emit(`transition${step}`);
    if (runCallbacks && activeIndex !== previousIndex) {
        if (dir === 'reset') {
            swiper.emit(`slideResetTransition${step}`);
            return;
        }
        swiper.emit(`slideChangeTransition${step}`);
        if (dir === 'next') {
            swiper.emit(`slideNextTransition${step}`);
        } else {
            swiper.emit(`slidePrevTransition${step}`);
        }
    }
}
function transitionStart(runCallbacks, direction) {
    if (runCallbacks === void 0) {
        runCallbacks = true;
    }
    const swiper = this;
    const { params } = swiper;
    if (params.cssMode) return;
    if (params.autoHeight) {
        swiper.updateAutoHeight();
    }
    transitionEmit({
        swiper,
        runCallbacks,
        direction,
        step: 'Start'
    });
}
function transitionEnd(runCallbacks, direction) {
    if (runCallbacks === void 0) {
        runCallbacks = true;
    }
    const swiper = this;
    const { params } = swiper;
    swiper.animating = false;
    if (params.cssMode) return;
    swiper.setTransition(0);
    transitionEmit({
        swiper,
        runCallbacks,
        direction,
        step: 'End'
    });
}
var transition = {
    setTransition,
    transitionStart,
    transitionEnd
};
function slideTo(index, speed, runCallbacks, internal, initial) {
    if (index === void 0) {
        index = 0;
    }
    if (runCallbacks === void 0) {
        runCallbacks = true;
    }
    if (typeof index === 'string') {
        index = parseInt(index, 10);
    }
    const swiper = this;
    let slideIndex = index;
    if (slideIndex < 0) slideIndex = 0;
    const { params, snapGrid, slidesGrid, previousIndex, activeIndex, rtlTranslate: rtl, wrapperEl, enabled } = swiper;
    if (!enabled && !internal && !initial || swiper.destroyed || swiper.animating && params.preventInteractionOnTransition) {
        return false;
    }
    if (typeof speed === 'undefined') {
        speed = swiper.params.speed;
    }
    const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
    let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
    const translate = -snapGrid[snapIndex];
    // Normalize slideIndex
    if (params.normalizeSlideIndex) {
        for(let i = 0; i < slidesGrid.length; i += 1){
            const normalizedTranslate = -Math.floor(translate * 100);
            const normalizedGrid = Math.floor(slidesGrid[i] * 100);
            const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
            if (typeof slidesGrid[i + 1] !== 'undefined') {
                if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
                    slideIndex = i;
                } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
                    slideIndex = i + 1;
                }
            } else if (normalizedTranslate >= normalizedGrid) {
                slideIndex = i;
            }
        }
    }
    // Directions locks
    if (swiper.initialized && slideIndex !== activeIndex) {
        if (!swiper.allowSlideNext && (rtl ? translate > swiper.translate && translate > swiper.minTranslate() : translate < swiper.translate && translate < swiper.minTranslate())) {
            return false;
        }
        if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
            if ((activeIndex || 0) !== slideIndex) {
                return false;
            }
        }
    }
    if (slideIndex !== (previousIndex || 0) && runCallbacks) {
        swiper.emit('beforeSlideChangeStart');
    }
    // Update progress
    swiper.updateProgress(translate);
    let direction;
    if (slideIndex > activeIndex) direction = 'next';
    else if (slideIndex < activeIndex) direction = 'prev';
    else direction = 'reset';
    // initial virtual
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    const isInitialVirtual = isVirtual && initial;
    // Update Index
    if (!isInitialVirtual && (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate)) {
        swiper.updateActiveIndex(slideIndex);
        // Update Height
        if (params.autoHeight) {
            swiper.updateAutoHeight();
        }
        swiper.updateSlidesClasses();
        if (params.effect !== 'slide') {
            swiper.setTranslate(translate);
        }
        if (direction !== 'reset') {
            swiper.transitionStart(runCallbacks, direction);
            swiper.transitionEnd(runCallbacks, direction);
        }
        return false;
    }
    if (params.cssMode) {
        const isH = swiper.isHorizontal();
        const t = rtl ? translate : -translate;
        if (speed === 0) {
            if (isVirtual) {
                swiper.wrapperEl.style.scrollSnapType = 'none';
                swiper._immediateVirtual = true;
            }
            if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {
                swiper._cssModeVirtualInitialSet = true;
                requestAnimationFrame(()=>{
                    wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
                });
            } else {
                wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
            }
            if (isVirtual) {
                requestAnimationFrame(()=>{
                    swiper.wrapperEl.style.scrollSnapType = '';
                    swiper._immediateVirtual = false;
                });
            }
        } else {
            if (!swiper.support.smoothScroll) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["t"])({
                    swiper,
                    targetPosition: t,
                    side: isH ? 'left' : 'top'
                });
                return true;
            }
            wrapperEl.scrollTo({
                [isH ? 'left' : 'top']: t,
                behavior: 'smooth'
            });
        }
        return true;
    }
    const browser = getBrowser();
    const isSafari = browser.isSafari;
    if (isVirtual && !initial && isSafari && swiper.isElement) {
        swiper.virtual.update(false, false, slideIndex);
    }
    swiper.setTransition(speed);
    swiper.setTranslate(translate);
    swiper.updateActiveIndex(slideIndex);
    swiper.updateSlidesClasses();
    swiper.emit('beforeTransitionStart', speed, internal);
    swiper.transitionStart(runCallbacks, direction);
    if (speed === 0) {
        swiper.transitionEnd(runCallbacks, direction);
    } else if (!swiper.animating) {
        swiper.animating = true;
        if (!swiper.onSlideToWrapperTransitionEnd) {
            swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
                if (!swiper || swiper.destroyed) return;
                if (e.target !== this) return;
                swiper.wrapperEl.removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
                swiper.onSlideToWrapperTransitionEnd = null;
                delete swiper.onSlideToWrapperTransitionEnd;
                swiper.transitionEnd(runCallbacks, direction);
            };
        }
        swiper.wrapperEl.addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
    }
    return true;
}
function slideToLoop(index, speed, runCallbacks, internal) {
    if (index === void 0) {
        index = 0;
    }
    if (runCallbacks === void 0) {
        runCallbacks = true;
    }
    if (typeof index === 'string') {
        const indexAsNumber = parseInt(index, 10);
        index = indexAsNumber;
    }
    const swiper = this;
    if (swiper.destroyed) return;
    if (typeof speed === 'undefined') {
        speed = swiper.params.speed;
    }
    const gridEnabled = swiper.grid && swiper.params.grid && swiper.params.grid.rows > 1;
    let newIndex = index;
    if (swiper.params.loop) {
        if (swiper.virtual && swiper.params.virtual.enabled) {
            // eslint-disable-next-line
            newIndex = newIndex + swiper.virtual.slidesBefore;
        } else {
            let targetSlideIndex;
            if (gridEnabled) {
                const slideIndex = newIndex * swiper.params.grid.rows;
                targetSlideIndex = swiper.slides.find((slideEl)=>slideEl.getAttribute('data-swiper-slide-index') * 1 === slideIndex).column;
            } else {
                targetSlideIndex = swiper.getSlideIndexByData(newIndex);
            }
            const cols = gridEnabled ? Math.ceil(swiper.slides.length / swiper.params.grid.rows) : swiper.slides.length;
            const { centeredSlides } = swiper.params;
            let slidesPerView = swiper.params.slidesPerView;
            if (slidesPerView === 'auto') {
                slidesPerView = swiper.slidesPerViewDynamic();
            } else {
                slidesPerView = Math.ceil(parseFloat(swiper.params.slidesPerView, 10));
                if (centeredSlides && slidesPerView % 2 === 0) {
                    slidesPerView = slidesPerView + 1;
                }
            }
            let needLoopFix = cols - targetSlideIndex < slidesPerView;
            if (centeredSlides) {
                needLoopFix = needLoopFix || targetSlideIndex < Math.ceil(slidesPerView / 2);
            }
            if (internal && centeredSlides && swiper.params.slidesPerView !== 'auto' && !gridEnabled) {
                needLoopFix = false;
            }
            if (needLoopFix) {
                const direction = centeredSlides ? targetSlideIndex < swiper.activeIndex ? 'prev' : 'next' : targetSlideIndex - swiper.activeIndex - 1 < swiper.params.slidesPerView ? 'next' : 'prev';
                swiper.loopFix({
                    direction,
                    slideTo: true,
                    activeSlideIndex: direction === 'next' ? targetSlideIndex + 1 : targetSlideIndex - cols + 1,
                    slideRealIndex: direction === 'next' ? swiper.realIndex : undefined
                });
            }
            if (gridEnabled) {
                const slideIndex = newIndex * swiper.params.grid.rows;
                newIndex = swiper.slides.find((slideEl)=>slideEl.getAttribute('data-swiper-slide-index') * 1 === slideIndex).column;
            } else {
                newIndex = swiper.getSlideIndexByData(newIndex);
            }
        }
    }
    requestAnimationFrame(()=>{
        swiper.slideTo(newIndex, speed, runCallbacks, internal);
    });
    return swiper;
}
/* eslint no-unused-vars: "off" */ function slideNext(speed, runCallbacks, internal) {
    if (runCallbacks === void 0) {
        runCallbacks = true;
    }
    const swiper = this;
    const { enabled, params, animating } = swiper;
    if (!enabled || swiper.destroyed) return swiper;
    if (typeof speed === 'undefined') {
        speed = swiper.params.speed;
    }
    let perGroup = params.slidesPerGroup;
    if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
        perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);
    }
    const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
    const isVirtual = swiper.virtual && params.virtual.enabled;
    if (params.loop) {
        if (animating && !isVirtual && params.loopPreventsSliding) return false;
        swiper.loopFix({
            direction: 'next'
        });
        // eslint-disable-next-line
        swiper._clientLeft = swiper.wrapperEl.clientLeft;
        if (swiper.activeIndex === swiper.slides.length - 1 && params.cssMode) {
            requestAnimationFrame(()=>{
                swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
            });
            return true;
        }
    }
    if (params.rewind && swiper.isEnd) {
        return swiper.slideTo(0, speed, runCallbacks, internal);
    }
    return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
}
/* eslint no-unused-vars: "off" */ function slidePrev(speed, runCallbacks, internal) {
    if (runCallbacks === void 0) {
        runCallbacks = true;
    }
    const swiper = this;
    const { params, snapGrid, slidesGrid, rtlTranslate, enabled, animating } = swiper;
    if (!enabled || swiper.destroyed) return swiper;
    if (typeof speed === 'undefined') {
        speed = swiper.params.speed;
    }
    const isVirtual = swiper.virtual && params.virtual.enabled;
    if (params.loop) {
        if (animating && !isVirtual && params.loopPreventsSliding) return false;
        swiper.loopFix({
            direction: 'prev'
        });
        // eslint-disable-next-line
        swiper._clientLeft = swiper.wrapperEl.clientLeft;
    }
    const translate = rtlTranslate ? swiper.translate : -swiper.translate;
    function normalize(val) {
        if (val < 0) return -Math.floor(Math.abs(val));
        return Math.floor(val);
    }
    const normalizedTranslate = normalize(translate);
    const normalizedSnapGrid = snapGrid.map((val)=>normalize(val));
    const isFreeMode = params.freeMode && params.freeMode.enabled;
    let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
    if (typeof prevSnap === 'undefined' && (params.cssMode || isFreeMode)) {
        let prevSnapIndex;
        snapGrid.forEach((snap, snapIndex)=>{
            if (normalizedTranslate >= snap) {
                // prevSnap = snap;
                prevSnapIndex = snapIndex;
            }
        });
        if (typeof prevSnapIndex !== 'undefined') {
            prevSnap = isFreeMode ? snapGrid[prevSnapIndex] : snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
        }
    }
    let prevIndex = 0;
    if (typeof prevSnap !== 'undefined') {
        prevIndex = slidesGrid.indexOf(prevSnap);
        if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
        if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
            prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;
            prevIndex = Math.max(prevIndex, 0);
        }
    }
    if (params.rewind && swiper.isBeginning) {
        const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
        return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
    } else if (params.loop && swiper.activeIndex === 0 && params.cssMode) {
        requestAnimationFrame(()=>{
            swiper.slideTo(prevIndex, speed, runCallbacks, internal);
        });
        return true;
    }
    return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
}
/* eslint no-unused-vars: "off" */ function slideReset(speed, runCallbacks, internal) {
    if (runCallbacks === void 0) {
        runCallbacks = true;
    }
    const swiper = this;
    if (swiper.destroyed) return;
    if (typeof speed === 'undefined') {
        speed = swiper.params.speed;
    }
    return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
}
/* eslint no-unused-vars: "off" */ function slideToClosest(speed, runCallbacks, internal, threshold) {
    if (runCallbacks === void 0) {
        runCallbacks = true;
    }
    if (threshold === void 0) {
        threshold = 0.5;
    }
    const swiper = this;
    if (swiper.destroyed) return;
    if (typeof speed === 'undefined') {
        speed = swiper.params.speed;
    }
    let index = swiper.activeIndex;
    const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
    const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
    const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
    if (translate >= swiper.snapGrid[snapIndex]) {
        // The current translate is on or after the current snap index, so the choice
        // is between the current index and the one after it.
        const currentSnap = swiper.snapGrid[snapIndex];
        const nextSnap = swiper.snapGrid[snapIndex + 1];
        if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
            index += swiper.params.slidesPerGroup;
        }
    } else {
        // The current translate is before the current snap index, so the choice
        // is between the current index and the one before it.
        const prevSnap = swiper.snapGrid[snapIndex - 1];
        const currentSnap = swiper.snapGrid[snapIndex];
        if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {
            index -= swiper.params.slidesPerGroup;
        }
    }
    index = Math.max(index, 0);
    index = Math.min(index, swiper.slidesGrid.length - 1);
    return swiper.slideTo(index, speed, runCallbacks, internal);
}
function slideToClickedSlide() {
    const swiper = this;
    if (swiper.destroyed) return;
    const { params, slidesEl } = swiper;
    const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
    let slideToIndex = swiper.clickedIndex;
    let realIndex;
    const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;
    if (params.loop) {
        if (swiper.animating) return;
        realIndex = parseInt(swiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);
        if (params.centeredSlides) {
            if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
                swiper.loopFix();
                slideToIndex = swiper.getSlideIndex((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["e"])(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["n"])(()=>{
                    swiper.slideTo(slideToIndex);
                });
            } else {
                swiper.slideTo(slideToIndex);
            }
        } else if (slideToIndex > swiper.slides.length - slidesPerView) {
            swiper.loopFix();
            slideToIndex = swiper.getSlideIndex((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["e"])(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["n"])(()=>{
                swiper.slideTo(slideToIndex);
            });
        } else {
            swiper.slideTo(slideToIndex);
        }
    } else {
        swiper.slideTo(slideToIndex);
    }
}
var slide = {
    slideTo,
    slideToLoop,
    slideNext,
    slidePrev,
    slideReset,
    slideToClosest,
    slideToClickedSlide
};
function loopCreate(slideRealIndex, initial) {
    const swiper = this;
    const { params, slidesEl } = swiper;
    if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
    const initSlides = ()=>{
        const slides = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["e"])(slidesEl, `.${params.slideClass}, swiper-slide`);
        slides.forEach((el, index)=>{
            el.setAttribute('data-swiper-slide-index', index);
        });
    };
    const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
    const slidesPerGroup = params.slidesPerGroup * (gridEnabled ? params.grid.rows : 1);
    const shouldFillGroup = swiper.slides.length % slidesPerGroup !== 0;
    const shouldFillGrid = gridEnabled && swiper.slides.length % params.grid.rows !== 0;
    const addBlankSlides = (amountOfSlides)=>{
        for(let i = 0; i < amountOfSlides; i += 1){
            const slideEl = swiper.isElement ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])('swiper-slide', [
                params.slideBlankClass
            ]) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])('div', [
                params.slideClass,
                params.slideBlankClass
            ]);
            swiper.slidesEl.append(slideEl);
        }
    };
    if (shouldFillGroup) {
        if (params.loopAddBlankSlides) {
            const slidesToAdd = slidesPerGroup - swiper.slides.length % slidesPerGroup;
            addBlankSlides(slidesToAdd);
            swiper.recalcSlides();
            swiper.updateSlides();
        } else {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["u"])('Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)');
        }
        initSlides();
    } else if (shouldFillGrid) {
        if (params.loopAddBlankSlides) {
            const slidesToAdd = params.grid.rows - swiper.slides.length % params.grid.rows;
            addBlankSlides(slidesToAdd);
            swiper.recalcSlides();
            swiper.updateSlides();
        } else {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["u"])('Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)');
        }
        initSlides();
    } else {
        initSlides();
    }
    swiper.loopFix({
        slideRealIndex,
        direction: params.centeredSlides ? undefined : 'next',
        initial
    });
}
function loopFix(_temp) {
    let { slideRealIndex, slideTo = true, direction, setTranslate, activeSlideIndex, initial, byController, byMousewheel } = _temp === void 0 ? {} : _temp;
    const swiper = this;
    if (!swiper.params.loop) return;
    swiper.emit('beforeLoopFix');
    const { slides, allowSlidePrev, allowSlideNext, slidesEl, params } = swiper;
    const { centeredSlides, initialSlide } = params;
    swiper.allowSlidePrev = true;
    swiper.allowSlideNext = true;
    if (swiper.virtual && params.virtual.enabled) {
        if (slideTo) {
            if (!params.centeredSlides && swiper.snapIndex === 0) {
                swiper.slideTo(swiper.virtual.slides.length, 0, false, true);
            } else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) {
                swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);
            } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {
                swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);
            }
        }
        swiper.allowSlidePrev = allowSlidePrev;
        swiper.allowSlideNext = allowSlideNext;
        swiper.emit('loopFix');
        return;
    }
    let slidesPerView = params.slidesPerView;
    if (slidesPerView === 'auto') {
        slidesPerView = swiper.slidesPerViewDynamic();
    } else {
        slidesPerView = Math.ceil(parseFloat(params.slidesPerView, 10));
        if (centeredSlides && slidesPerView % 2 === 0) {
            slidesPerView = slidesPerView + 1;
        }
    }
    const slidesPerGroup = params.slidesPerGroupAuto ? slidesPerView : params.slidesPerGroup;
    let loopedSlides = slidesPerGroup;
    if (loopedSlides % slidesPerGroup !== 0) {
        loopedSlides += slidesPerGroup - loopedSlides % slidesPerGroup;
    }
    loopedSlides += params.loopAdditionalSlides;
    swiper.loopedSlides = loopedSlides;
    const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
    if (slides.length < slidesPerView + loopedSlides || swiper.params.effect === 'cards' && slides.length < slidesPerView + loopedSlides * 2) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["u"])('Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled or not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters');
    } else if (gridEnabled && params.grid.fill === 'row') {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["u"])('Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`');
    }
    const prependSlidesIndexes = [];
    const appendSlidesIndexes = [];
    const cols = gridEnabled ? Math.ceil(slides.length / params.grid.rows) : slides.length;
    const isInitialOverflow = initial && cols - initialSlide < slidesPerView && !centeredSlides;
    let activeIndex = isInitialOverflow ? initialSlide : swiper.activeIndex;
    if (typeof activeSlideIndex === 'undefined') {
        activeSlideIndex = swiper.getSlideIndex(slides.find((el)=>el.classList.contains(params.slideActiveClass)));
    } else {
        activeIndex = activeSlideIndex;
    }
    const isNext = direction === 'next' || !direction;
    const isPrev = direction === 'prev' || !direction;
    let slidesPrepended = 0;
    let slidesAppended = 0;
    const activeColIndex = gridEnabled ? slides[activeSlideIndex].column : activeSlideIndex;
    const activeColIndexWithShift = activeColIndex + (centeredSlides && typeof setTranslate === 'undefined' ? -slidesPerView / 2 + 0.5 : 0);
    // prepend last slides before start
    if (activeColIndexWithShift < loopedSlides) {
        slidesPrepended = Math.max(loopedSlides - activeColIndexWithShift, slidesPerGroup);
        for(let i = 0; i < loopedSlides - activeColIndexWithShift; i += 1){
            const index = i - Math.floor(i / cols) * cols;
            if (gridEnabled) {
                const colIndexToPrepend = cols - index - 1;
                for(let i = slides.length - 1; i >= 0; i -= 1){
                    if (slides[i].column === colIndexToPrepend) prependSlidesIndexes.push(i);
                }
            // slides.forEach((slide, slideIndex) => {
            //   if (slide.column === colIndexToPrepend) prependSlidesIndexes.push(slideIndex);
            // });
            } else {
                prependSlidesIndexes.push(cols - index - 1);
            }
        }
    } else if (activeColIndexWithShift + slidesPerView > cols - loopedSlides) {
        slidesAppended = Math.max(activeColIndexWithShift - (cols - loopedSlides * 2), slidesPerGroup);
        if (isInitialOverflow) {
            slidesAppended = Math.max(slidesAppended, slidesPerView - cols + initialSlide + 1);
        }
        for(let i = 0; i < slidesAppended; i += 1){
            const index = i - Math.floor(i / cols) * cols;
            if (gridEnabled) {
                slides.forEach((slide, slideIndex)=>{
                    if (slide.column === index) appendSlidesIndexes.push(slideIndex);
                });
            } else {
                appendSlidesIndexes.push(index);
            }
        }
    }
    swiper.__preventObserver__ = true;
    requestAnimationFrame(()=>{
        swiper.__preventObserver__ = false;
    });
    if (swiper.params.effect === 'cards' && slides.length < slidesPerView + loopedSlides * 2) {
        if (appendSlidesIndexes.includes(activeSlideIndex)) {
            appendSlidesIndexes.splice(appendSlidesIndexes.indexOf(activeSlideIndex), 1);
        }
        if (prependSlidesIndexes.includes(activeSlideIndex)) {
            prependSlidesIndexes.splice(prependSlidesIndexes.indexOf(activeSlideIndex), 1);
        }
    }
    if (isPrev) {
        prependSlidesIndexes.forEach((index)=>{
            slides[index].swiperLoopMoveDOM = true;
            slidesEl.prepend(slides[index]);
            slides[index].swiperLoopMoveDOM = false;
        });
    }
    if (isNext) {
        appendSlidesIndexes.forEach((index)=>{
            slides[index].swiperLoopMoveDOM = true;
            slidesEl.append(slides[index]);
            slides[index].swiperLoopMoveDOM = false;
        });
    }
    swiper.recalcSlides();
    if (params.slidesPerView === 'auto') {
        swiper.updateSlides();
    } else if (gridEnabled && (prependSlidesIndexes.length > 0 && isPrev || appendSlidesIndexes.length > 0 && isNext)) {
        swiper.slides.forEach((slide, slideIndex)=>{
            swiper.grid.updateSlide(slideIndex, slide, swiper.slides);
        });
    }
    if (params.watchSlidesProgress) {
        swiper.updateSlidesOffset();
    }
    if (slideTo) {
        if (prependSlidesIndexes.length > 0 && isPrev) {
            if (typeof slideRealIndex === 'undefined') {
                const currentSlideTranslate = swiper.slidesGrid[activeIndex];
                const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];
                const diff = newSlideTranslate - currentSlideTranslate;
                if (byMousewheel) {
                    swiper.setTranslate(swiper.translate - diff);
                } else {
                    swiper.slideTo(activeIndex + Math.ceil(slidesPrepended), 0, false, true);
                    if (setTranslate) {
                        swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
                        swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
                    }
                }
            } else {
                if (setTranslate) {
                    const shift = gridEnabled ? prependSlidesIndexes.length / params.grid.rows : prependSlidesIndexes.length;
                    swiper.slideTo(swiper.activeIndex + shift, 0, false, true);
                    swiper.touchEventsData.currentTranslate = swiper.translate;
                }
            }
        } else if (appendSlidesIndexes.length > 0 && isNext) {
            if (typeof slideRealIndex === 'undefined') {
                const currentSlideTranslate = swiper.slidesGrid[activeIndex];
                const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];
                const diff = newSlideTranslate - currentSlideTranslate;
                if (byMousewheel) {
                    swiper.setTranslate(swiper.translate - diff);
                } else {
                    swiper.slideTo(activeIndex - slidesAppended, 0, false, true);
                    if (setTranslate) {
                        swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
                        swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
                    }
                }
            } else {
                const shift = gridEnabled ? appendSlidesIndexes.length / params.grid.rows : appendSlidesIndexes.length;
                swiper.slideTo(swiper.activeIndex - shift, 0, false, true);
            }
        }
    }
    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;
    if (swiper.controller && swiper.controller.control && !byController) {
        const loopParams = {
            slideRealIndex,
            direction,
            setTranslate,
            activeSlideIndex,
            byController: true
        };
        if (Array.isArray(swiper.controller.control)) {
            swiper.controller.control.forEach((c)=>{
                if (!c.destroyed && c.params.loop) c.loopFix({
                    ...loopParams,
                    slideTo: c.params.slidesPerView === params.slidesPerView ? slideTo : false
                });
            });
        } else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {
            swiper.controller.control.loopFix({
                ...loopParams,
                slideTo: swiper.controller.control.params.slidesPerView === params.slidesPerView ? slideTo : false
            });
        }
    }
    swiper.emit('loopFix');
}
function loopDestroy() {
    const swiper = this;
    const { params, slidesEl } = swiper;
    if (!params.loop || !slidesEl || swiper.virtual && swiper.params.virtual.enabled) return;
    swiper.recalcSlides();
    const newSlidesOrder = [];
    swiper.slides.forEach((slideEl)=>{
        const index = typeof slideEl.swiperSlideIndex === 'undefined' ? slideEl.getAttribute('data-swiper-slide-index') * 1 : slideEl.swiperSlideIndex;
        newSlidesOrder[index] = slideEl;
    });
    swiper.slides.forEach((slideEl)=>{
        slideEl.removeAttribute('data-swiper-slide-index');
    });
    newSlidesOrder.forEach((slideEl)=>{
        slidesEl.append(slideEl);
    });
    swiper.recalcSlides();
    swiper.slideTo(swiper.realIndex, 0);
}
var loop = {
    loopCreate,
    loopFix,
    loopDestroy
};
function setGrabCursor(moving) {
    const swiper = this;
    if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
    const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;
    if (swiper.isElement) {
        swiper.__preventObserver__ = true;
    }
    el.style.cursor = 'move';
    el.style.cursor = moving ? 'grabbing' : 'grab';
    if (swiper.isElement) {
        requestAnimationFrame(()=>{
            swiper.__preventObserver__ = false;
        });
    }
}
function unsetGrabCursor() {
    const swiper = this;
    if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
        return;
    }
    if (swiper.isElement) {
        swiper.__preventObserver__ = true;
    }
    swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';
    if (swiper.isElement) {
        requestAnimationFrame(()=>{
            swiper.__preventObserver__ = false;
        });
    }
}
var grabCursor = {
    setGrabCursor,
    unsetGrabCursor
};
// Modified from https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd
function closestElement(selector, base) {
    if (base === void 0) {
        base = this;
    }
    function __closestFrom(el) {
        if (!el || el === (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$ssr$2d$window$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["g"])() || el === (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$ssr$2d$window$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"])()) return null;
        if (el.assignedSlot) el = el.assignedSlot;
        const found = el.closest(selector);
        if (!found && !el.getRootNode) {
            return null;
        }
        return found || __closestFrom(el.getRootNode().host);
    }
    return __closestFrom(base);
}
function preventEdgeSwipe(swiper, event, startX) {
    const window1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$ssr$2d$window$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"])();
    const { params } = swiper;
    const edgeSwipeDetection = params.edgeSwipeDetection;
    const edgeSwipeThreshold = params.edgeSwipeThreshold;
    if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window1.innerWidth - edgeSwipeThreshold)) {
        if (edgeSwipeDetection === 'prevent') {
            event.preventDefault();
            return true;
        }
        return false;
    }
    return true;
}
function onTouchStart(event) {
    const swiper = this;
    const document1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$ssr$2d$window$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["g"])();
    let e = event;
    if (e.originalEvent) e = e.originalEvent;
    const data = swiper.touchEventsData;
    if (e.type === 'pointerdown') {
        if (data.pointerId !== null && data.pointerId !== e.pointerId) {
            return;
        }
        data.pointerId = e.pointerId;
    } else if (e.type === 'touchstart' && e.targetTouches.length === 1) {
        data.touchId = e.targetTouches[0].identifier;
    }
    if (e.type === 'touchstart') {
        // don't proceed touch event
        preventEdgeSwipe(swiper, e, e.targetTouches[0].pageX);
        return;
    }
    const { params, touches, enabled } = swiper;
    if (!enabled) return;
    if (!params.simulateTouch && e.pointerType === 'mouse') return;
    if (swiper.animating && params.preventInteractionOnTransition) {
        return;
    }
    if (!swiper.animating && params.cssMode && params.loop) {
        swiper.loopFix();
    }
    let targetEl = e.target;
    if (params.touchEventsTarget === 'wrapper') {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v"])(targetEl, swiper.wrapperEl)) return;
    }
    if ('which' in e && e.which === 3) return;
    if ('button' in e && e.button > 0) return;
    if (data.isTouched && data.isMoved) return;
    // change target el for shadow root component
    const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';
    // eslint-disable-next-line
    const eventPath = e.composedPath ? e.composedPath() : e.path;
    if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {
        targetEl = eventPath[0];
    }
    const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
    const isTargetShadow = !!(e.target && e.target.shadowRoot);
    // use closestElement for shadow root element to get the actual closest for nested shadow root element
    if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {
        swiper.allowClick = true;
        return;
    }
    if (params.swipeHandler) {
        if (!targetEl.closest(params.swipeHandler)) return;
    }
    touches.currentX = e.pageX;
    touches.currentY = e.pageY;
    const startX = touches.currentX;
    const startY = touches.currentY;
    // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore
    if (!preventEdgeSwipe(swiper, e, startX)) {
        return;
    }
    Object.assign(data, {
        isTouched: true,
        isMoved: false,
        allowTouchCallbacks: true,
        isScrolling: undefined,
        startMoving: undefined
    });
    touches.startX = startX;
    touches.startY = startY;
    data.touchStartTime = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["d"])();
    swiper.allowClick = true;
    swiper.updateSize();
    swiper.swipeDirection = undefined;
    if (params.threshold > 0) data.allowThresholdMove = false;
    let preventDefault = true;
    if (targetEl.matches(data.focusableElements)) {
        preventDefault = false;
        if (targetEl.nodeName === 'SELECT') {
            data.isTouched = false;
        }
    }
    if (document1.activeElement && document1.activeElement.matches(data.focusableElements) && document1.activeElement !== targetEl && (e.pointerType === 'mouse' || e.pointerType !== 'mouse' && !targetEl.matches(data.focusableElements))) {
        document1.activeElement.blur();
    }
    const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
    if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {
        e.preventDefault();
    }
    if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {
        swiper.freeMode.onTouchStart();
    }
    swiper.emit('touchStart', e);
}
function onTouchMove(event) {
    const document1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$ssr$2d$window$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["g"])();
    const swiper = this;
    const data = swiper.touchEventsData;
    const { params, touches, rtlTranslate: rtl, enabled } = swiper;
    if (!enabled) return;
    if (!params.simulateTouch && event.pointerType === 'mouse') return;
    let e = event;
    if (e.originalEvent) e = e.originalEvent;
    if (e.type === 'pointermove') {
        if (data.touchId !== null) return; // return from pointer if we use touch
        const id = e.pointerId;
        if (id !== data.pointerId) return;
    }
    let targetTouch;
    if (e.type === 'touchmove') {
        targetTouch = [
            ...e.changedTouches
        ].find((t)=>t.identifier === data.touchId);
        if (!targetTouch || targetTouch.identifier !== data.touchId) return;
    } else {
        targetTouch = e;
    }
    if (!data.isTouched) {
        if (data.startMoving && data.isScrolling) {
            swiper.emit('touchMoveOpposite', e);
        }
        return;
    }
    const pageX = targetTouch.pageX;
    const pageY = targetTouch.pageY;
    if (e.preventedByNestedSwiper) {
        touches.startX = pageX;
        touches.startY = pageY;
        return;
    }
    if (!swiper.allowTouchMove) {
        if (!e.target.matches(data.focusableElements)) {
            swiper.allowClick = false;
        }
        if (data.isTouched) {
            Object.assign(touches, {
                startX: pageX,
                startY: pageY,
                currentX: pageX,
                currentY: pageY
            });
            data.touchStartTime = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["d"])();
        }
        return;
    }
    if (params.touchReleaseOnEdges && !params.loop) {
        if (swiper.isVertical()) {
            // Vertical
            if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
                data.isTouched = false;
                data.isMoved = false;
                return;
            }
        } else if (rtl && (pageX > touches.startX && -swiper.translate <= swiper.maxTranslate() || pageX < touches.startX && -swiper.translate >= swiper.minTranslate())) {
            return;
        } else if (!rtl && (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate())) {
            return;
        }
    }
    if (document1.activeElement && document1.activeElement.matches(data.focusableElements) && document1.activeElement !== e.target && e.pointerType !== 'mouse') {
        document1.activeElement.blur();
    }
    if (document1.activeElement) {
        if (e.target === document1.activeElement && e.target.matches(data.focusableElements)) {
            data.isMoved = true;
            swiper.allowClick = false;
            return;
        }
    }
    if (data.allowTouchCallbacks) {
        swiper.emit('touchMove', e);
    }
    touches.previousX = touches.currentX;
    touches.previousY = touches.currentY;
    touches.currentX = pageX;
    touches.currentY = pageY;
    const diffX = touches.currentX - touches.startX;
    const diffY = touches.currentY - touches.startY;
    if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;
    if (typeof data.isScrolling === 'undefined') {
        let touchAngle;
        if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
            data.isScrolling = false;
        } else {
            // eslint-disable-next-line
            if (diffX * diffX + diffY * diffY >= 25) {
                touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
                data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
            }
        }
    }
    if (data.isScrolling) {
        swiper.emit('touchMoveOpposite', e);
    }
    if (typeof data.startMoving === 'undefined') {
        if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
            data.startMoving = true;
        }
    }
    if (data.isScrolling || e.type === 'touchmove' && data.preventTouchMoveFromPointerMove) {
        data.isTouched = false;
        return;
    }
    if (!data.startMoving) {
        return;
    }
    swiper.allowClick = false;
    if (!params.cssMode && e.cancelable) {
        e.preventDefault();
    }
    if (params.touchMoveStopPropagation && !params.nested) {
        e.stopPropagation();
    }
    let diff = swiper.isHorizontal() ? diffX : diffY;
    let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;
    if (params.oneWayMovement) {
        diff = Math.abs(diff) * (rtl ? 1 : -1);
        touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);
    }
    touches.diff = diff;
    diff *= params.touchRatio;
    if (rtl) {
        diff = -diff;
        touchesDiff = -touchesDiff;
    }
    const prevTouchesDirection = swiper.touchesDirection;
    swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
    swiper.touchesDirection = touchesDiff > 0 ? 'prev' : 'next';
    const isLoop = swiper.params.loop && !params.cssMode;
    const allowLoopFix = swiper.touchesDirection === 'next' && swiper.allowSlideNext || swiper.touchesDirection === 'prev' && swiper.allowSlidePrev;
    if (!data.isMoved) {
        if (isLoop && allowLoopFix) {
            swiper.loopFix({
                direction: swiper.swipeDirection
            });
        }
        data.startTranslate = swiper.getTranslate();
        swiper.setTransition(0);
        if (swiper.animating) {
            const evt = new window.CustomEvent('transitionend', {
                bubbles: true,
                cancelable: true,
                detail: {
                    bySwiperTouchMove: true
                }
            });
            swiper.wrapperEl.dispatchEvent(evt);
        }
        data.allowMomentumBounce = false;
        // Grab Cursor
        if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
            swiper.setGrabCursor(true);
        }
        swiper.emit('sliderFirstMove', e);
    }
    let loopFixed;
    new Date().getTime();
    if (params._loopSwapReset !== false && data.isMoved && data.allowThresholdMove && prevTouchesDirection !== swiper.touchesDirection && isLoop && allowLoopFix && Math.abs(diff) >= 1) {
        Object.assign(touches, {
            startX: pageX,
            startY: pageY,
            currentX: pageX,
            currentY: pageY,
            startTranslate: data.currentTranslate
        });
        data.loopSwapReset = true;
        data.startTranslate = data.currentTranslate;
        return;
    }
    swiper.emit('sliderMove', e);
    data.isMoved = true;
    data.currentTranslate = diff + data.startTranslate;
    let disableParentSwiper = true;
    let resistanceRatio = params.resistanceRatio;
    if (params.touchReleaseOnEdges) {
        resistanceRatio = 0;
    }
    if (diff > 0) {
        if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.slidesSizesGrid[swiper.activeIndex + 1] - (params.slidesPerView !== 'auto' && swiper.slides.length - params.slidesPerView >= 2 ? swiper.slidesSizesGrid[swiper.activeIndex + 1] + swiper.params.spaceBetween : 0) - swiper.params.spaceBetween : swiper.minTranslate())) {
            swiper.loopFix({
                direction: 'prev',
                setTranslate: true,
                activeSlideIndex: 0
            });
        }
        if (data.currentTranslate > swiper.minTranslate()) {
            disableParentSwiper = false;
            if (params.resistance) {
                data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
            }
        }
    } else if (diff < 0) {
        if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] + swiper.params.spaceBetween + (params.slidesPerView !== 'auto' && swiper.slides.length - params.slidesPerView >= 2 ? swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] + swiper.params.spaceBetween : 0) : swiper.maxTranslate())) {
            swiper.loopFix({
                direction: 'next',
                setTranslate: true,
                activeSlideIndex: swiper.slides.length - (params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))
            });
        }
        if (data.currentTranslate < swiper.maxTranslate()) {
            disableParentSwiper = false;
            if (params.resistance) {
                data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
            }
        }
    }
    if (disableParentSwiper) {
        e.preventedByNestedSwiper = true;
    }
    // Directions locks
    if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
        data.currentTranslate = data.startTranslate;
    }
    if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
        data.currentTranslate = data.startTranslate;
    }
    if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
        data.currentTranslate = data.startTranslate;
    }
    // Threshold
    if (params.threshold > 0) {
        if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
            if (!data.allowThresholdMove) {
                data.allowThresholdMove = true;
                touches.startX = touches.currentX;
                touches.startY = touches.currentY;
                data.currentTranslate = data.startTranslate;
                touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
                return;
            }
        } else {
            data.currentTranslate = data.startTranslate;
            return;
        }
    }
    if (!params.followFinger || params.cssMode) return;
    // Update active index in free mode
    if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
    }
    if (params.freeMode && params.freeMode.enabled && swiper.freeMode) {
        swiper.freeMode.onTouchMove();
    }
    // Update progress
    swiper.updateProgress(data.currentTranslate);
    // Update translate
    swiper.setTranslate(data.currentTranslate);
}
function onTouchEnd(event) {
    const swiper = this;
    const data = swiper.touchEventsData;
    let e = event;
    if (e.originalEvent) e = e.originalEvent;
    let targetTouch;
    const isTouchEvent = e.type === 'touchend' || e.type === 'touchcancel';
    if (!isTouchEvent) {
        if (data.touchId !== null) return; // return from pointer if we use touch
        if (e.pointerId !== data.pointerId) return;
        targetTouch = e;
    } else {
        targetTouch = [
            ...e.changedTouches
        ].find((t)=>t.identifier === data.touchId);
        if (!targetTouch || targetTouch.identifier !== data.touchId) return;
    }
    if ([
        'pointercancel',
        'pointerout',
        'pointerleave',
        'contextmenu'
    ].includes(e.type)) {
        const proceed = [
            'pointercancel',
            'contextmenu'
        ].includes(e.type) && (swiper.browser.isSafari || swiper.browser.isWebView);
        if (!proceed) {
            return;
        }
    }
    data.pointerId = null;
    data.touchId = null;
    const { params, touches, rtlTranslate: rtl, slidesGrid, enabled } = swiper;
    if (!enabled) return;
    if (!params.simulateTouch && e.pointerType === 'mouse') return;
    if (data.allowTouchCallbacks) {
        swiper.emit('touchEnd', e);
    }
    data.allowTouchCallbacks = false;
    if (!data.isTouched) {
        if (data.isMoved && params.grabCursor) {
            swiper.setGrabCursor(false);
        }
        data.isMoved = false;
        data.startMoving = false;
        return;
    }
    // Return Grab Cursor
    if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
        swiper.setGrabCursor(false);
    }
    // Time diff
    const touchEndTime = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["d"])();
    const timeDiff = touchEndTime - data.touchStartTime;
    // Tap, doubleTap, Click
    if (swiper.allowClick) {
        const pathTree = e.path || e.composedPath && e.composedPath();
        swiper.updateClickedSlide(pathTree && pathTree[0] || e.target, pathTree);
        swiper.emit('tap click', e);
        if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
            swiper.emit('doubleTap doubleClick', e);
        }
    }
    data.lastClickTime = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["d"])();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["n"])(()=>{
        if (!swiper.destroyed) swiper.allowClick = true;
    });
    if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 && !data.loopSwapReset || data.currentTranslate === data.startTranslate && !data.loopSwapReset) {
        data.isTouched = false;
        data.isMoved = false;
        data.startMoving = false;
        return;
    }
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    let currentPos;
    if (params.followFinger) {
        currentPos = rtl ? swiper.translate : -swiper.translate;
    } else {
        currentPos = -data.currentTranslate;
    }
    if (params.cssMode) {
        return;
    }
    if (params.freeMode && params.freeMode.enabled) {
        swiper.freeMode.onTouchEnd({
            currentPos
        });
        return;
    }
    // Find current slide
    const swipeToLast = currentPos >= -swiper.maxTranslate() && !swiper.params.loop;
    let stopIndex = 0;
    let groupSize = swiper.slidesSizesGrid[0];
    for(let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup){
        const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
        if (typeof slidesGrid[i + increment] !== 'undefined') {
            if (swipeToLast || currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
                stopIndex = i;
                groupSize = slidesGrid[i + increment] - slidesGrid[i];
            }
        } else if (swipeToLast || currentPos >= slidesGrid[i]) {
            stopIndex = i;
            groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
        }
    }
    let rewindFirstIndex = null;
    let rewindLastIndex = null;
    if (params.rewind) {
        if (swiper.isBeginning) {
            rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
        } else if (swiper.isEnd) {
            rewindFirstIndex = 0;
        }
    }
    // Find current slide size
    const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
    const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
    if (timeDiff > params.longSwipesMs) {
        // Long touches
        if (!params.longSwipes) {
            swiper.slideTo(swiper.activeIndex);
            return;
        }
        if (swiper.swipeDirection === 'next') {
            if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);
            else swiper.slideTo(stopIndex);
        }
        if (swiper.swipeDirection === 'prev') {
            if (ratio > 1 - params.longSwipesRatio) {
                swiper.slideTo(stopIndex + increment);
            } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
                swiper.slideTo(rewindLastIndex);
            } else {
                swiper.slideTo(stopIndex);
            }
        }
    } else {
        // Short swipes
        if (!params.shortSwipes) {
            swiper.slideTo(swiper.activeIndex);
            return;
        }
        const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
        if (!isNavButtonTarget) {
            if (swiper.swipeDirection === 'next') {
                swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
            }
            if (swiper.swipeDirection === 'prev') {
                swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
            }
        } else if (e.target === swiper.navigation.nextEl) {
            swiper.slideTo(stopIndex + increment);
        } else {
            swiper.slideTo(stopIndex);
        }
    }
}
function onResize() {
    const swiper = this;
    const { params, el } = swiper;
    if (el && el.offsetWidth === 0) return;
    // Breakpoints
    if (params.breakpoints) {
        swiper.setBreakpoint();
    }
    // Save locks
    const { allowSlideNext, allowSlidePrev, snapGrid } = swiper;
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    // Disable locks on resize
    swiper.allowSlideNext = true;
    swiper.allowSlidePrev = true;
    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateSlidesClasses();
    const isVirtualLoop = isVirtual && params.loop;
    if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) {
        swiper.slideTo(swiper.slides.length - 1, 0, false, true);
    } else {
        if (swiper.params.loop && !isVirtual) {
            swiper.slideToLoop(swiper.realIndex, 0, false, true);
        } else {
            swiper.slideTo(swiper.activeIndex, 0, false, true);
        }
    }
    if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
        clearTimeout(swiper.autoplay.resizeTimeout);
        swiper.autoplay.resizeTimeout = setTimeout(()=>{
            if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
                swiper.autoplay.resume();
            }
        }, 500);
    }
    // Return locks after resize
    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;
    if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
        swiper.checkOverflow();
    }
}
function onClick(e) {
    const swiper = this;
    if (!swiper.enabled) return;
    if (!swiper.allowClick) {
        if (swiper.params.preventClicks) e.preventDefault();
        if (swiper.params.preventClicksPropagation && swiper.animating) {
            e.stopPropagation();
            e.stopImmediatePropagation();
        }
    }
}
function onScroll() {
    const swiper = this;
    const { wrapperEl, rtlTranslate, enabled } = swiper;
    if (!enabled) return;
    swiper.previousTranslate = swiper.translate;
    if (swiper.isHorizontal()) {
        swiper.translate = -wrapperEl.scrollLeft;
    } else {
        swiper.translate = -wrapperEl.scrollTop;
    }
    // eslint-disable-next-line
    if (swiper.translate === 0) swiper.translate = 0;
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
    let newProgress;
    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    if (translatesDiff === 0) {
        newProgress = 0;
    } else {
        newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
    }
    if (newProgress !== swiper.progress) {
        swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
    }
    swiper.emit('setTranslate', swiper.translate, false);
}
function onLoad(e) {
    const swiper = this;
    processLazyPreloader(swiper, e.target);
    if (swiper.params.cssMode || swiper.params.slidesPerView !== 'auto' && !swiper.params.autoHeight) {
        return;
    }
    swiper.update();
}
function onDocumentTouchStart() {
    const swiper = this;
    if (swiper.documentTouchHandlerProceeded) return;
    swiper.documentTouchHandlerProceeded = true;
    if (swiper.params.touchReleaseOnEdges) {
        swiper.el.style.touchAction = 'auto';
    }
}
const events = (swiper, method)=>{
    const document1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$ssr$2d$window$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["g"])();
    const { params, el, wrapperEl, device } = swiper;
    const capture = !!params.nested;
    const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
    const swiperMethod = method;
    if (!el || typeof el === 'string') return;
    // Touch Events
    document1[domMethod]('touchstart', swiper.onDocumentTouchStart, {
        passive: false,
        capture
    });
    el[domMethod]('touchstart', swiper.onTouchStart, {
        passive: false
    });
    el[domMethod]('pointerdown', swiper.onTouchStart, {
        passive: false
    });
    document1[domMethod]('touchmove', swiper.onTouchMove, {
        passive: false,
        capture
    });
    document1[domMethod]('pointermove', swiper.onTouchMove, {
        passive: false,
        capture
    });
    document1[domMethod]('touchend', swiper.onTouchEnd, {
        passive: true
    });
    document1[domMethod]('pointerup', swiper.onTouchEnd, {
        passive: true
    });
    document1[domMethod]('pointercancel', swiper.onTouchEnd, {
        passive: true
    });
    document1[domMethod]('touchcancel', swiper.onTouchEnd, {
        passive: true
    });
    document1[domMethod]('pointerout', swiper.onTouchEnd, {
        passive: true
    });
    document1[domMethod]('pointerleave', swiper.onTouchEnd, {
        passive: true
    });
    document1[domMethod]('contextmenu', swiper.onTouchEnd, {
        passive: true
    });
    // Prevent Links Clicks
    if (params.preventClicks || params.preventClicksPropagation) {
        el[domMethod]('click', swiper.onClick, true);
    }
    if (params.cssMode) {
        wrapperEl[domMethod]('scroll', swiper.onScroll);
    }
    // Resize handler
    if (params.updateOnWindowResize) {
        swiper[swiperMethod](device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);
    } else {
        swiper[swiperMethod]('observerUpdate', onResize, true);
    }
    // Images loader
    el[domMethod]('load', swiper.onLoad, {
        capture: true
    });
};
function attachEvents() {
    const swiper = this;
    const { params } = swiper;
    swiper.onTouchStart = onTouchStart.bind(swiper);
    swiper.onTouchMove = onTouchMove.bind(swiper);
    swiper.onTouchEnd = onTouchEnd.bind(swiper);
    swiper.onDocumentTouchStart = onDocumentTouchStart.bind(swiper);
    if (params.cssMode) {
        swiper.onScroll = onScroll.bind(swiper);
    }
    swiper.onClick = onClick.bind(swiper);
    swiper.onLoad = onLoad.bind(swiper);
    events(swiper, 'on');
}
function detachEvents() {
    const swiper = this;
    events(swiper, 'off');
}
var events$1 = {
    attachEvents,
    detachEvents
};
const isGridEnabled = (swiper, params)=>{
    return swiper.grid && params.grid && params.grid.rows > 1;
};
function setBreakpoint() {
    const swiper = this;
    const { realIndex, initialized, params, el } = swiper;
    const breakpoints = params.breakpoints;
    if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;
    const document1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$ssr$2d$window$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["g"])();
    // Get breakpoint for window/container width and update parameters
    const breakpointsBase = params.breakpointsBase === 'window' || !params.breakpointsBase ? params.breakpointsBase : 'container';
    const breakpointContainer = [
        'window',
        'container'
    ].includes(params.breakpointsBase) || !params.breakpointsBase ? swiper.el : document1.querySelector(params.breakpointsBase);
    const breakpoint = swiper.getBreakpoint(breakpoints, breakpointsBase, breakpointContainer);
    if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
    const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
    const breakpointParams = breakpointOnlyParams || swiper.originalParams;
    const wasMultiRow = isGridEnabled(swiper, params);
    const isMultiRow = isGridEnabled(swiper, breakpointParams);
    const wasGrabCursor = swiper.params.grabCursor;
    const isGrabCursor = breakpointParams.grabCursor;
    const wasEnabled = params.enabled;
    if (wasMultiRow && !isMultiRow) {
        el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);
        swiper.emitContainerClasses();
    } else if (!wasMultiRow && isMultiRow) {
        el.classList.add(`${params.containerModifierClass}grid`);
        if (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column' || !breakpointParams.grid.fill && params.grid.fill === 'column') {
            el.classList.add(`${params.containerModifierClass}grid-column`);
        }
        swiper.emitContainerClasses();
    }
    if (wasGrabCursor && !isGrabCursor) {
        swiper.unsetGrabCursor();
    } else if (!wasGrabCursor && isGrabCursor) {
        swiper.setGrabCursor();
    }
    // Toggle navigation, pagination, scrollbar
    [
        'navigation',
        'pagination',
        'scrollbar'
    ].forEach((prop)=>{
        if (typeof breakpointParams[prop] === 'undefined') return;
        const wasModuleEnabled = params[prop] && params[prop].enabled;
        const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
        if (wasModuleEnabled && !isModuleEnabled) {
            swiper[prop].disable();
        }
        if (!wasModuleEnabled && isModuleEnabled) {
            swiper[prop].enable();
        }
    });
    const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
    const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
    const wasLoop = params.loop;
    if (directionChanged && initialized) {
        swiper.changeDirection();
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["w"])(swiper.params, breakpointParams);
    const isEnabled = swiper.params.enabled;
    const hasLoop = swiper.params.loop;
    Object.assign(swiper, {
        allowTouchMove: swiper.params.allowTouchMove,
        allowSlideNext: swiper.params.allowSlideNext,
        allowSlidePrev: swiper.params.allowSlidePrev
    });
    if (wasEnabled && !isEnabled) {
        swiper.disable();
    } else if (!wasEnabled && isEnabled) {
        swiper.enable();
    }
    swiper.currentBreakpoint = breakpoint;
    swiper.emit('_beforeBreakpoint', breakpointParams);
    if (initialized) {
        if (needsReLoop) {
            swiper.loopDestroy();
            swiper.loopCreate(realIndex);
            swiper.updateSlides();
        } else if (!wasLoop && hasLoop) {
            swiper.loopCreate(realIndex);
            swiper.updateSlides();
        } else if (wasLoop && !hasLoop) {
            swiper.loopDestroy();
        }
    }
    swiper.emit('breakpoint', breakpointParams);
}
function getBreakpoint(breakpoints, base, containerEl) {
    if (base === void 0) {
        base = 'window';
    }
    if (!breakpoints || base === 'container' && !containerEl) return undefined;
    let breakpoint = false;
    const window1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$ssr$2d$window$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"])();
    const currentHeight = base === 'window' ? window1.innerHeight : containerEl.clientHeight;
    const points = Object.keys(breakpoints).map((point)=>{
        if (typeof point === 'string' && point.indexOf('@') === 0) {
            const minRatio = parseFloat(point.substr(1));
            const value = currentHeight * minRatio;
            return {
                value,
                point
            };
        }
        return {
            value: point,
            point
        };
    });
    points.sort((a, b)=>parseInt(a.value, 10) - parseInt(b.value, 10));
    for(let i = 0; i < points.length; i += 1){
        const { point, value } = points[i];
        if (base === 'window') {
            if (window1.matchMedia(`(min-width: ${value}px)`).matches) {
                breakpoint = point;
            }
        } else if (value <= containerEl.clientWidth) {
            breakpoint = point;
        }
    }
    return breakpoint || 'max';
}
var breakpoints = {
    setBreakpoint,
    getBreakpoint
};
function prepareClasses(entries, prefix) {
    const resultClasses = [];
    entries.forEach((item)=>{
        if (typeof item === 'object') {
            Object.keys(item).forEach((classNames)=>{
                if (item[classNames]) {
                    resultClasses.push(prefix + classNames);
                }
            });
        } else if (typeof item === 'string') {
            resultClasses.push(prefix + item);
        }
    });
    return resultClasses;
}
function addClasses() {
    const swiper = this;
    const { classNames, params, rtl, el, device } = swiper;
    // prettier-ignore
    const suffixes = prepareClasses([
        'initialized',
        params.direction,
        {
            'free-mode': swiper.params.freeMode && params.freeMode.enabled
        },
        {
            'autoheight': params.autoHeight
        },
        {
            'rtl': rtl
        },
        {
            'grid': params.grid && params.grid.rows > 1
        },
        {
            'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column'
        },
        {
            'android': device.android
        },
        {
            'ios': device.ios
        },
        {
            'css-mode': params.cssMode
        },
        {
            'centered': params.cssMode && params.centeredSlides
        },
        {
            'watch-progress': params.watchSlidesProgress
        }
    ], params.containerModifierClass);
    classNames.push(...suffixes);
    el.classList.add(...classNames);
    swiper.emitContainerClasses();
}
function removeClasses() {
    const swiper = this;
    const { el, classNames } = swiper;
    if (!el || typeof el === 'string') return;
    el.classList.remove(...classNames);
    swiper.emitContainerClasses();
}
var classes = {
    addClasses,
    removeClasses
};
function checkOverflow() {
    const swiper = this;
    const { isLocked: wasLocked, params } = swiper;
    const { slidesOffsetBefore } = params;
    if (slidesOffsetBefore) {
        const lastSlideIndex = swiper.slides.length - 1;
        const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
        swiper.isLocked = swiper.size > lastSlideRightEdge;
    } else {
        swiper.isLocked = swiper.snapGrid.length === 1;
    }
    if (params.allowSlideNext === true) {
        swiper.allowSlideNext = !swiper.isLocked;
    }
    if (params.allowSlidePrev === true) {
        swiper.allowSlidePrev = !swiper.isLocked;
    }
    if (wasLocked && wasLocked !== swiper.isLocked) {
        swiper.isEnd = false;
    }
    if (wasLocked !== swiper.isLocked) {
        swiper.emit(swiper.isLocked ? 'lock' : 'unlock');
    }
}
var checkOverflow$1 = {
    checkOverflow
};
var defaults = {
    init: true,
    direction: 'horizontal',
    oneWayMovement: false,
    swiperElementNodeName: 'SWIPER-CONTAINER',
    touchEventsTarget: 'wrapper',
    initialSlide: 0,
    speed: 300,
    cssMode: false,
    updateOnWindowResize: true,
    resizeObserver: true,
    nested: false,
    createElements: false,
    eventsPrefix: 'swiper',
    enabled: true,
    focusableElements: 'input, select, option, textarea, button, video, label',
    // Overrides
    width: null,
    height: null,
    //
    preventInteractionOnTransition: false,
    // ssr
    userAgent: null,
    url: null,
    // To support iOS's swipe-to-go-back gesture (when being used in-app).
    edgeSwipeDetection: false,
    edgeSwipeThreshold: 20,
    // Autoheight
    autoHeight: false,
    // Set wrapper width
    setWrapperSize: false,
    // Virtual Translate
    virtualTranslate: false,
    // Effects
    effect: 'slide',
    // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
    // Breakpoints
    breakpoints: undefined,
    breakpointsBase: 'window',
    // Slides grid
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerGroup: 1,
    slidesPerGroupSkip: 0,
    slidesPerGroupAuto: false,
    centeredSlides: false,
    centeredSlidesBounds: false,
    slidesOffsetBefore: 0,
    // in px
    slidesOffsetAfter: 0,
    // in px
    normalizeSlideIndex: true,
    centerInsufficientSlides: false,
    // Disable swiper and hide navigation when container not overflow
    watchOverflow: true,
    // Round length
    roundLengths: false,
    // Touches
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: true,
    shortSwipes: true,
    longSwipes: true,
    longSwipesRatio: 0.5,
    longSwipesMs: 300,
    followFinger: true,
    allowTouchMove: true,
    threshold: 5,
    touchMoveStopPropagation: false,
    touchStartPreventDefault: true,
    touchStartForcePreventDefault: false,
    touchReleaseOnEdges: false,
    // Unique Navigation Elements
    uniqueNavElements: true,
    // Resistance
    resistance: true,
    resistanceRatio: 0.85,
    // Progress
    watchSlidesProgress: false,
    // Cursor
    grabCursor: false,
    // Clicks
    preventClicks: true,
    preventClicksPropagation: true,
    slideToClickedSlide: false,
    // loop
    loop: false,
    loopAddBlankSlides: true,
    loopAdditionalSlides: 0,
    loopPreventsSliding: true,
    // rewind
    rewind: false,
    // Swiping/no swiping
    allowSlidePrev: true,
    allowSlideNext: true,
    swipeHandler: null,
    // '.swipe-handler',
    noSwiping: true,
    noSwipingClass: 'swiper-no-swiping',
    noSwipingSelector: null,
    // Passive Listeners
    passiveListeners: true,
    maxBackfaceHiddenSlides: 10,
    // NS
    containerModifierClass: 'swiper-',
    // NEW
    slideClass: 'swiper-slide',
    slideBlankClass: 'swiper-slide-blank',
    slideActiveClass: 'swiper-slide-active',
    slideVisibleClass: 'swiper-slide-visible',
    slideFullyVisibleClass: 'swiper-slide-fully-visible',
    slideNextClass: 'swiper-slide-next',
    slidePrevClass: 'swiper-slide-prev',
    wrapperClass: 'swiper-wrapper',
    lazyPreloaderClass: 'swiper-lazy-preloader',
    lazyPreloadPrevNext: 0,
    // Callbacks
    runCallbacksOnInit: true,
    // Internals
    _emitClasses: false
};
function moduleExtendParams(params, allModulesParams) {
    return function extendParams(obj) {
        if (obj === void 0) {
            obj = {};
        }
        const moduleParamName = Object.keys(obj)[0];
        const moduleParams = obj[moduleParamName];
        if (typeof moduleParams !== 'object' || moduleParams === null) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["w"])(allModulesParams, obj);
            return;
        }
        if (params[moduleParamName] === true) {
            params[moduleParamName] = {
                enabled: true
            };
        }
        if (moduleParamName === 'navigation' && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].prevEl && !params[moduleParamName].nextEl) {
            params[moduleParamName].auto = true;
        }
        if ([
            'pagination',
            'scrollbar'
        ].indexOf(moduleParamName) >= 0 && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].el) {
            params[moduleParamName].auto = true;
        }
        if (!(moduleParamName in params && 'enabled' in moduleParams)) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["w"])(allModulesParams, obj);
            return;
        }
        if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {
            params[moduleParamName].enabled = true;
        }
        if (!params[moduleParamName]) params[moduleParamName] = {
            enabled: false
        };
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["w"])(allModulesParams, obj);
    };
}
/* eslint no-param-reassign: "off" */ const prototypes = {
    eventsEmitter,
    update,
    translate,
    transition,
    slide,
    loop,
    grabCursor,
    events: events$1,
    breakpoints,
    checkOverflow: checkOverflow$1,
    classes
};
const extendedDefaults = {};
class Swiper {
    constructor(){
        let el;
        let params;
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {
            params = args[0];
        } else {
            [el, params] = args;
        }
        if (!params) params = {};
        params = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["w"])({}, params);
        if (el && !params.el) params.el = el;
        const document1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$ssr$2d$window$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["g"])();
        if (params.el && typeof params.el === 'string' && document1.querySelectorAll(params.el).length > 1) {
            const swipers = [];
            document1.querySelectorAll(params.el).forEach((containerEl)=>{
                const newParams = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["w"])({}, params, {
                    el: containerEl
                });
                swipers.push(new Swiper(newParams));
            });
            // eslint-disable-next-line no-constructor-return
            return swipers;
        }
        // Swiper Instance
        const swiper = this;
        swiper.__swiper__ = true;
        swiper.support = getSupport();
        swiper.device = getDevice({
            userAgent: params.userAgent
        });
        swiper.browser = getBrowser();
        swiper.eventsListeners = {};
        swiper.eventsAnyListeners = [];
        swiper.modules = [
            ...swiper.__modules__
        ];
        if (params.modules && Array.isArray(params.modules)) {
            swiper.modules.push(...params.modules);
        }
        const allModulesParams = {};
        swiper.modules.forEach((mod)=>{
            mod({
                params,
                swiper,
                extendParams: moduleExtendParams(params, allModulesParams),
                on: swiper.on.bind(swiper),
                once: swiper.once.bind(swiper),
                off: swiper.off.bind(swiper),
                emit: swiper.emit.bind(swiper)
            });
        });
        // Extend defaults with modules params
        const swiperParams = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["w"])({}, defaults, allModulesParams);
        // Extend defaults with passed params
        swiper.params = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["w"])({}, swiperParams, extendedDefaults, params);
        swiper.originalParams = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["w"])({}, swiper.params);
        swiper.passedParams = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["w"])({}, params);
        // add event listeners
        if (swiper.params && swiper.params.on) {
            Object.keys(swiper.params.on).forEach((eventName)=>{
                swiper.on(eventName, swiper.params.on[eventName]);
            });
        }
        if (swiper.params && swiper.params.onAny) {
            swiper.onAny(swiper.params.onAny);
        }
        // Extend Swiper
        Object.assign(swiper, {
            enabled: swiper.params.enabled,
            el,
            // Classes
            classNames: [],
            // Slides
            slides: [],
            slidesGrid: [],
            snapGrid: [],
            slidesSizesGrid: [],
            // isDirection
            isHorizontal () {
                return swiper.params.direction === 'horizontal';
            },
            isVertical () {
                return swiper.params.direction === 'vertical';
            },
            // Indexes
            activeIndex: 0,
            realIndex: 0,
            //
            isBeginning: true,
            isEnd: false,
            // Props
            translate: 0,
            previousTranslate: 0,
            progress: 0,
            velocity: 0,
            animating: false,
            cssOverflowAdjustment () {
                // Returns 0 unless `translate` is > 2**23
                // Should be subtracted from css values to prevent overflow
                return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
            },
            // Locks
            allowSlideNext: swiper.params.allowSlideNext,
            allowSlidePrev: swiper.params.allowSlidePrev,
            // Touch Events
            touchEventsData: {
                isTouched: undefined,
                isMoved: undefined,
                allowTouchCallbacks: undefined,
                touchStartTime: undefined,
                isScrolling: undefined,
                currentTranslate: undefined,
                startTranslate: undefined,
                allowThresholdMove: undefined,
                // Form elements to match
                focusableElements: swiper.params.focusableElements,
                // Last click time
                lastClickTime: 0,
                clickTimeout: undefined,
                // Velocities
                velocities: [],
                allowMomentumBounce: undefined,
                startMoving: undefined,
                pointerId: null,
                touchId: null
            },
            // Clicks
            allowClick: true,
            // Touches
            allowTouchMove: swiper.params.allowTouchMove,
            touches: {
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0,
                diff: 0
            },
            // Images
            imagesToLoad: [],
            imagesLoaded: 0
        });
        swiper.emit('_swiper');
        // Init
        if (swiper.params.init) {
            swiper.init();
        }
        // Return app instance
        // eslint-disable-next-line no-constructor-return
        return swiper;
    }
    getDirectionLabel(property) {
        if (this.isHorizontal()) {
            return property;
        }
        // prettier-ignore
        return ({
            'width': 'height',
            'margin-top': 'margin-left',
            'margin-bottom ': 'margin-right',
            'margin-left': 'margin-top',
            'margin-right': 'margin-bottom',
            'padding-left': 'padding-top',
            'padding-right': 'padding-bottom',
            'marginRight': 'marginBottom'
        })[property];
    }
    getSlideIndex(slideEl) {
        const { slidesEl, params } = this;
        const slides = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["e"])(slidesEl, `.${params.slideClass}, swiper-slide`);
        const firstSlideIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["h"])(slides[0]);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["h"])(slideEl) - firstSlideIndex;
    }
    getSlideIndexByData(index) {
        return this.getSlideIndex(this.slides.find((slideEl)=>slideEl.getAttribute('data-swiper-slide-index') * 1 === index));
    }
    recalcSlides() {
        const swiper = this;
        const { slidesEl, params } = swiper;
        swiper.slides = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["e"])(slidesEl, `.${params.slideClass}, swiper-slide`);
    }
    enable() {
        const swiper = this;
        if (swiper.enabled) return;
        swiper.enabled = true;
        if (swiper.params.grabCursor) {
            swiper.setGrabCursor();
        }
        swiper.emit('enable');
    }
    disable() {
        const swiper = this;
        if (!swiper.enabled) return;
        swiper.enabled = false;
        if (swiper.params.grabCursor) {
            swiper.unsetGrabCursor();
        }
        swiper.emit('disable');
    }
    setProgress(progress, speed) {
        const swiper = this;
        progress = Math.min(Math.max(progress, 0), 1);
        const min = swiper.minTranslate();
        const max = swiper.maxTranslate();
        const current = (max - min) * progress + min;
        swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
    }
    emitContainerClasses() {
        const swiper = this;
        if (!swiper.params._emitClasses || !swiper.el) return;
        const cls = swiper.el.className.split(' ').filter((className)=>{
            return className.indexOf('swiper') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
        });
        swiper.emit('_containerClasses', cls.join(' '));
    }
    getSlideClasses(slideEl) {
        const swiper = this;
        if (swiper.destroyed) return '';
        return slideEl.className.split(' ').filter((className)=>{
            return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;
        }).join(' ');
    }
    emitSlidesClasses() {
        const swiper = this;
        if (!swiper.params._emitClasses || !swiper.el) return;
        const updates = [];
        swiper.slides.forEach((slideEl)=>{
            const classNames = swiper.getSlideClasses(slideEl);
            updates.push({
                slideEl,
                classNames
            });
            swiper.emit('_slideClass', slideEl, classNames);
        });
        swiper.emit('_slideClasses', updates);
    }
    slidesPerViewDynamic(view, exact) {
        if (view === void 0) {
            view = 'current';
        }
        if (exact === void 0) {
            exact = false;
        }
        const swiper = this;
        const { params, slides, slidesGrid, slidesSizesGrid, size: swiperSize, activeIndex } = swiper;
        let spv = 1;
        if (typeof params.slidesPerView === 'number') return params.slidesPerView;
        if (params.centeredSlides) {
            let slideSize = slides[activeIndex] ? Math.ceil(slides[activeIndex].swiperSlideSize) : 0;
            let breakLoop;
            for(let i = activeIndex + 1; i < slides.length; i += 1){
                if (slides[i] && !breakLoop) {
                    slideSize += Math.ceil(slides[i].swiperSlideSize);
                    spv += 1;
                    if (slideSize > swiperSize) breakLoop = true;
                }
            }
            for(let i = activeIndex - 1; i >= 0; i -= 1){
                if (slides[i] && !breakLoop) {
                    slideSize += slides[i].swiperSlideSize;
                    spv += 1;
                    if (slideSize > swiperSize) breakLoop = true;
                }
            }
        } else {
            // eslint-disable-next-line
            if (view === 'current') {
                for(let i = activeIndex + 1; i < slides.length; i += 1){
                    const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
                    if (slideInView) {
                        spv += 1;
                    }
                }
            } else {
                // previous
                for(let i = activeIndex - 1; i >= 0; i -= 1){
                    const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
                    if (slideInView) {
                        spv += 1;
                    }
                }
            }
        }
        return spv;
    }
    update() {
        const swiper = this;
        if (!swiper || swiper.destroyed) return;
        const { snapGrid, params } = swiper;
        // Breakpoints
        if (params.breakpoints) {
            swiper.setBreakpoint();
        }
        [
            ...swiper.el.querySelectorAll('[loading="lazy"]')
        ].forEach((imageEl)=>{
            if (imageEl.complete) {
                processLazyPreloader(swiper, imageEl);
            }
        });
        swiper.updateSize();
        swiper.updateSlides();
        swiper.updateProgress();
        swiper.updateSlidesClasses();
        function setTranslate() {
            const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
            const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
            swiper.setTranslate(newTranslate);
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
        }
        let translated;
        if (params.freeMode && params.freeMode.enabled && !params.cssMode) {
            setTranslate();
            if (params.autoHeight) {
                swiper.updateAutoHeight();
            }
        } else {
            if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {
                const slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;
                translated = swiper.slideTo(slides.length - 1, 0, false, true);
            } else {
                translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
            }
            if (!translated) {
                setTranslate();
            }
        }
        if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
            swiper.checkOverflow();
        }
        swiper.emit('update');
    }
    changeDirection(newDirection, needUpdate) {
        if (needUpdate === void 0) {
            needUpdate = true;
        }
        const swiper = this;
        const currentDirection = swiper.params.direction;
        if (!newDirection) {
            // eslint-disable-next-line
            newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
        }
        if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {
            return swiper;
        }
        swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);
        swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);
        swiper.emitContainerClasses();
        swiper.params.direction = newDirection;
        swiper.slides.forEach((slideEl)=>{
            if (newDirection === 'vertical') {
                slideEl.style.width = '';
            } else {
                slideEl.style.height = '';
            }
        });
        swiper.emit('changeDirection');
        if (needUpdate) swiper.update();
        return swiper;
    }
    changeLanguageDirection(direction) {
        const swiper = this;
        if (swiper.rtl && direction === 'rtl' || !swiper.rtl && direction === 'ltr') return;
        swiper.rtl = direction === 'rtl';
        swiper.rtlTranslate = swiper.params.direction === 'horizontal' && swiper.rtl;
        if (swiper.rtl) {
            swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);
            swiper.el.dir = 'rtl';
        } else {
            swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);
            swiper.el.dir = 'ltr';
        }
        swiper.update();
    }
    mount(element) {
        const swiper = this;
        if (swiper.mounted) return true;
        // Find el
        let el = element || swiper.params.el;
        if (typeof el === 'string') {
            el = document.querySelector(el);
        }
        if (!el) {
            return false;
        }
        el.swiper = swiper;
        if (el.parentNode && el.parentNode.host && el.parentNode.host.nodeName === swiper.params.swiperElementNodeName.toUpperCase()) {
            swiper.isElement = true;
        }
        const getWrapperSelector = ()=>{
            return `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;
        };
        const getWrapper = ()=>{
            if (el && el.shadowRoot && el.shadowRoot.querySelector) {
                const res = el.shadowRoot.querySelector(getWrapperSelector());
                // Children needs to return slot items
                return res;
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["e"])(el, getWrapperSelector())[0];
        };
        // Find Wrapper
        let wrapperEl = getWrapper();
        if (!wrapperEl && swiper.params.createElements) {
            wrapperEl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])('div', swiper.params.wrapperClass);
            el.append(wrapperEl);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["e"])(el, `.${swiper.params.slideClass}`).forEach((slideEl)=>{
                wrapperEl.append(slideEl);
            });
        }
        Object.assign(swiper, {
            el,
            wrapperEl,
            slidesEl: swiper.isElement && !el.parentNode.host.slideSlots ? el.parentNode.host : wrapperEl,
            hostEl: swiper.isElement ? el.parentNode.host : el,
            mounted: true,
            // RTL
            rtl: el.dir.toLowerCase() === 'rtl' || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"])(el, 'direction') === 'rtl',
            rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"])(el, 'direction') === 'rtl'),
            wrongRTL: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"])(wrapperEl, 'display') === '-webkit-box'
        });
        return true;
    }
    init(el) {
        const swiper = this;
        if (swiper.initialized) return swiper;
        const mounted = swiper.mount(el);
        if (mounted === false) return swiper;
        swiper.emit('beforeInit');
        // Set breakpoint
        if (swiper.params.breakpoints) {
            swiper.setBreakpoint();
        }
        // Add Classes
        swiper.addClasses();
        // Update size
        swiper.updateSize();
        // Update slides
        swiper.updateSlides();
        if (swiper.params.watchOverflow) {
            swiper.checkOverflow();
        }
        // Set Grab Cursor
        if (swiper.params.grabCursor && swiper.enabled) {
            swiper.setGrabCursor();
        }
        // Slide To Initial Slide
        if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
            swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);
        } else {
            swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
        }
        // Create loop
        if (swiper.params.loop) {
            swiper.loopCreate(undefined, true);
        }
        // Attach events
        swiper.attachEvents();
        const lazyElements = [
            ...swiper.el.querySelectorAll('[loading="lazy"]')
        ];
        if (swiper.isElement) {
            lazyElements.push(...swiper.hostEl.querySelectorAll('[loading="lazy"]'));
        }
        lazyElements.forEach((imageEl)=>{
            if (imageEl.complete) {
                processLazyPreloader(swiper, imageEl);
            } else {
                imageEl.addEventListener('load', (e)=>{
                    processLazyPreloader(swiper, e.target);
                });
            }
        });
        preload(swiper);
        // Init Flag
        swiper.initialized = true;
        preload(swiper);
        // Emit
        swiper.emit('init');
        swiper.emit('afterInit');
        return swiper;
    }
    destroy(deleteInstance, cleanStyles) {
        if (deleteInstance === void 0) {
            deleteInstance = true;
        }
        if (cleanStyles === void 0) {
            cleanStyles = true;
        }
        const swiper = this;
        const { params, el, wrapperEl, slides } = swiper;
        if (typeof swiper.params === 'undefined' || swiper.destroyed) {
            return null;
        }
        swiper.emit('beforeDestroy');
        // Init Flag
        swiper.initialized = false;
        // Detach events
        swiper.detachEvents();
        // Destroy loop
        if (params.loop) {
            swiper.loopDestroy();
        }
        // Cleanup styles
        if (cleanStyles) {
            swiper.removeClasses();
            if (el && typeof el !== 'string') {
                el.removeAttribute('style');
            }
            if (wrapperEl) {
                wrapperEl.removeAttribute('style');
            }
            if (slides && slides.length) {
                slides.forEach((slideEl)=>{
                    slideEl.classList.remove(params.slideVisibleClass, params.slideFullyVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
                    slideEl.removeAttribute('style');
                    slideEl.removeAttribute('data-swiper-slide-index');
                });
            }
        }
        swiper.emit('destroy');
        // Detach emitter events
        Object.keys(swiper.eventsListeners).forEach((eventName)=>{
            swiper.off(eventName);
        });
        if (deleteInstance !== false) {
            if (swiper.el && typeof swiper.el !== 'string') {
                swiper.el.swiper = null;
            }
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["x"])(swiper);
        }
        swiper.destroyed = true;
        return null;
    }
    static extendDefaults(newDefaults) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["w"])(extendedDefaults, newDefaults);
    }
    static get extendedDefaults() {
        return extendedDefaults;
    }
    static get defaults() {
        return defaults;
    }
    static installModule(mod) {
        if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];
        const modules = Swiper.prototype.__modules__;
        if (typeof mod === 'function' && modules.indexOf(mod) < 0) {
            modules.push(mod);
        }
    }
    static use(module) {
        if (Array.isArray(module)) {
            module.forEach((m)=>Swiper.installModule(m));
            return Swiper;
        }
        Swiper.installModule(module);
        return Swiper;
    }
}
Object.keys(prototypes).forEach((prototypeGroup)=>{
    Object.keys(prototypes[prototypeGroup]).forEach((protoMethod)=>{
        Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
    });
});
Swiper.use([
    Resize,
    Observer
]);
;
}}),
"[project]/node_modules/swiper/shared/update-swiper.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* underscore in name -> watch for changes */ __turbopack_context__.s({
    "a": (()=>needsPagination),
    "b": (()=>needsScrollbar),
    "c": (()=>attrToProp),
    "d": (()=>uniqueClasses),
    "e": (()=>extend),
    "i": (()=>isObject),
    "n": (()=>needsNavigation),
    "p": (()=>paramsList),
    "u": (()=>updateSwiper),
    "w": (()=>wrapperClass)
});
const paramsList = [
    'eventsPrefix',
    'injectStyles',
    'injectStylesUrls',
    'modules',
    'init',
    '_direction',
    'oneWayMovement',
    'swiperElementNodeName',
    'touchEventsTarget',
    'initialSlide',
    '_speed',
    'cssMode',
    'updateOnWindowResize',
    'resizeObserver',
    'nested',
    'focusableElements',
    '_enabled',
    '_width',
    '_height',
    'preventInteractionOnTransition',
    'userAgent',
    'url',
    '_edgeSwipeDetection',
    '_edgeSwipeThreshold',
    '_freeMode',
    '_autoHeight',
    'setWrapperSize',
    'virtualTranslate',
    '_effect',
    'breakpoints',
    'breakpointsBase',
    '_spaceBetween',
    '_slidesPerView',
    'maxBackfaceHiddenSlides',
    '_grid',
    '_slidesPerGroup',
    '_slidesPerGroupSkip',
    '_slidesPerGroupAuto',
    '_centeredSlides',
    '_centeredSlidesBounds',
    '_slidesOffsetBefore',
    '_slidesOffsetAfter',
    'normalizeSlideIndex',
    '_centerInsufficientSlides',
    '_watchOverflow',
    'roundLengths',
    'touchRatio',
    'touchAngle',
    'simulateTouch',
    '_shortSwipes',
    '_longSwipes',
    'longSwipesRatio',
    'longSwipesMs',
    '_followFinger',
    'allowTouchMove',
    '_threshold',
    'touchMoveStopPropagation',
    'touchStartPreventDefault',
    'touchStartForcePreventDefault',
    'touchReleaseOnEdges',
    'uniqueNavElements',
    '_resistance',
    '_resistanceRatio',
    '_watchSlidesProgress',
    '_grabCursor',
    'preventClicks',
    'preventClicksPropagation',
    '_slideToClickedSlide',
    '_loop',
    'loopAdditionalSlides',
    'loopAddBlankSlides',
    'loopPreventsSliding',
    '_rewind',
    '_allowSlidePrev',
    '_allowSlideNext',
    '_swipeHandler',
    '_noSwiping',
    'noSwipingClass',
    'noSwipingSelector',
    'passiveListeners',
    'containerModifierClass',
    'slideClass',
    'slideActiveClass',
    'slideVisibleClass',
    'slideFullyVisibleClass',
    'slideNextClass',
    'slidePrevClass',
    'slideBlankClass',
    'wrapperClass',
    'lazyPreloaderClass',
    'lazyPreloadPrevNext',
    'runCallbacksOnInit',
    'observer',
    'observeParents',
    'observeSlideChildren',
    // modules
    'a11y',
    '_autoplay',
    '_controller',
    'coverflowEffect',
    'cubeEffect',
    'fadeEffect',
    'flipEffect',
    'creativeEffect',
    'cardsEffect',
    'hashNavigation',
    'history',
    'keyboard',
    'mousewheel',
    '_navigation',
    '_pagination',
    'parallax',
    '_scrollbar',
    '_thumbs',
    'virtual',
    'zoom',
    'control'
];
function isObject(o) {
    return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object' && !o.__swiper__;
}
function extend(target, src) {
    const noExtend = [
        '__proto__',
        'constructor',
        'prototype'
    ];
    Object.keys(src).filter((key)=>noExtend.indexOf(key) < 0).forEach((key)=>{
        if (typeof target[key] === 'undefined') target[key] = src[key];
        else if (isObject(src[key]) && isObject(target[key]) && Object.keys(src[key]).length > 0) {
            if (src[key].__swiper__) target[key] = src[key];
            else extend(target[key], src[key]);
        } else {
            target[key] = src[key];
        }
    });
}
function needsNavigation(params) {
    if (params === void 0) {
        params = {};
    }
    return params.navigation && typeof params.navigation.nextEl === 'undefined' && typeof params.navigation.prevEl === 'undefined';
}
function needsPagination(params) {
    if (params === void 0) {
        params = {};
    }
    return params.pagination && typeof params.pagination.el === 'undefined';
}
function needsScrollbar(params) {
    if (params === void 0) {
        params = {};
    }
    return params.scrollbar && typeof params.scrollbar.el === 'undefined';
}
function uniqueClasses(classNames) {
    if (classNames === void 0) {
        classNames = '';
    }
    const classes = classNames.split(' ').map((c)=>c.trim()).filter((c)=>!!c);
    const unique = [];
    classes.forEach((c)=>{
        if (unique.indexOf(c) < 0) unique.push(c);
    });
    return unique.join(' ');
}
function attrToProp(attrName) {
    if (attrName === void 0) {
        attrName = '';
    }
    return attrName.replace(/-[a-z]/g, (l)=>l.toUpperCase().replace('-', ''));
}
function wrapperClass(className) {
    if (className === void 0) {
        className = '';
    }
    if (!className) return 'swiper-wrapper';
    if (!className.includes('swiper-wrapper')) return `swiper-wrapper ${className}`;
    return className;
}
function updateSwiper(_ref) {
    let { swiper, slides, passedParams, changedParams, nextEl, prevEl, scrollbarEl, paginationEl } = _ref;
    const updateParams = changedParams.filter((key)=>key !== 'children' && key !== 'direction' && key !== 'wrapperClass');
    const { params: currentParams, pagination, navigation, scrollbar, virtual, thumbs } = swiper;
    let needThumbsInit;
    let needControllerInit;
    let needPaginationInit;
    let needScrollbarInit;
    let needNavigationInit;
    let loopNeedDestroy;
    let loopNeedEnable;
    let loopNeedReloop;
    if (changedParams.includes('thumbs') && passedParams.thumbs && passedParams.thumbs.swiper && !passedParams.thumbs.swiper.destroyed && currentParams.thumbs && (!currentParams.thumbs.swiper || currentParams.thumbs.swiper.destroyed)) {
        needThumbsInit = true;
    }
    if (changedParams.includes('controller') && passedParams.controller && passedParams.controller.control && currentParams.controller && !currentParams.controller.control) {
        needControllerInit = true;
    }
    if (changedParams.includes('pagination') && passedParams.pagination && (passedParams.pagination.el || paginationEl) && (currentParams.pagination || currentParams.pagination === false) && pagination && !pagination.el) {
        needPaginationInit = true;
    }
    if (changedParams.includes('scrollbar') && passedParams.scrollbar && (passedParams.scrollbar.el || scrollbarEl) && (currentParams.scrollbar || currentParams.scrollbar === false) && scrollbar && !scrollbar.el) {
        needScrollbarInit = true;
    }
    if (changedParams.includes('navigation') && passedParams.navigation && (passedParams.navigation.prevEl || prevEl) && (passedParams.navigation.nextEl || nextEl) && (currentParams.navigation || currentParams.navigation === false) && navigation && !navigation.prevEl && !navigation.nextEl) {
        needNavigationInit = true;
    }
    const destroyModule = (mod)=>{
        if (!swiper[mod]) return;
        swiper[mod].destroy();
        if (mod === 'navigation') {
            if (swiper.isElement) {
                swiper[mod].prevEl.remove();
                swiper[mod].nextEl.remove();
            }
            currentParams[mod].prevEl = undefined;
            currentParams[mod].nextEl = undefined;
            swiper[mod].prevEl = undefined;
            swiper[mod].nextEl = undefined;
        } else {
            if (swiper.isElement) {
                swiper[mod].el.remove();
            }
            currentParams[mod].el = undefined;
            swiper[mod].el = undefined;
        }
    };
    if (changedParams.includes('loop') && swiper.isElement) {
        if (currentParams.loop && !passedParams.loop) {
            loopNeedDestroy = true;
        } else if (!currentParams.loop && passedParams.loop) {
            loopNeedEnable = true;
        } else {
            loopNeedReloop = true;
        }
    }
    updateParams.forEach((key)=>{
        if (isObject(currentParams[key]) && isObject(passedParams[key])) {
            Object.assign(currentParams[key], passedParams[key]);
            if ((key === 'navigation' || key === 'pagination' || key === 'scrollbar') && 'enabled' in passedParams[key] && !passedParams[key].enabled) {
                destroyModule(key);
            }
        } else {
            const newValue = passedParams[key];
            if ((newValue === true || newValue === false) && (key === 'navigation' || key === 'pagination' || key === 'scrollbar')) {
                if (newValue === false) {
                    destroyModule(key);
                }
            } else {
                currentParams[key] = passedParams[key];
            }
        }
    });
    if (updateParams.includes('controller') && !needControllerInit && swiper.controller && swiper.controller.control && currentParams.controller && currentParams.controller.control) {
        swiper.controller.control = currentParams.controller.control;
    }
    if (changedParams.includes('children') && slides && virtual && currentParams.virtual.enabled) {
        virtual.slides = slides;
        virtual.update(true);
    } else if (changedParams.includes('virtual') && virtual && currentParams.virtual.enabled) {
        if (slides) virtual.slides = slides;
        virtual.update(true);
    }
    if (changedParams.includes('children') && slides && currentParams.loop) {
        loopNeedReloop = true;
    }
    if (needThumbsInit) {
        const initialized = thumbs.init();
        if (initialized) thumbs.update(true);
    }
    if (needControllerInit) {
        swiper.controller.control = currentParams.controller.control;
    }
    if (needPaginationInit) {
        if (swiper.isElement && (!paginationEl || typeof paginationEl === 'string')) {
            paginationEl = document.createElement('div');
            paginationEl.classList.add('swiper-pagination');
            paginationEl.part.add('pagination');
            swiper.el.appendChild(paginationEl);
        }
        if (paginationEl) currentParams.pagination.el = paginationEl;
        pagination.init();
        pagination.render();
        pagination.update();
    }
    if (needScrollbarInit) {
        if (swiper.isElement && (!scrollbarEl || typeof scrollbarEl === 'string')) {
            scrollbarEl = document.createElement('div');
            scrollbarEl.classList.add('swiper-scrollbar');
            scrollbarEl.part.add('scrollbar');
            swiper.el.appendChild(scrollbarEl);
        }
        if (scrollbarEl) currentParams.scrollbar.el = scrollbarEl;
        scrollbar.init();
        scrollbar.updateSize();
        scrollbar.setTranslate();
    }
    if (needNavigationInit) {
        if (swiper.isElement) {
            if (!nextEl || typeof nextEl === 'string') {
                nextEl = document.createElement('div');
                nextEl.classList.add('swiper-button-next');
                nextEl.innerHTML = swiper.hostEl.constructor.nextButtonSvg;
                nextEl.part.add('button-next');
                swiper.el.appendChild(nextEl);
            }
            if (!prevEl || typeof prevEl === 'string') {
                prevEl = document.createElement('div');
                prevEl.classList.add('swiper-button-prev');
                prevEl.innerHTML = swiper.hostEl.constructor.prevButtonSvg;
                prevEl.part.add('button-prev');
                swiper.el.appendChild(prevEl);
            }
        }
        if (nextEl) currentParams.navigation.nextEl = nextEl;
        if (prevEl) currentParams.navigation.prevEl = prevEl;
        navigation.init();
        navigation.update();
    }
    if (changedParams.includes('allowSlideNext')) {
        swiper.allowSlideNext = passedParams.allowSlideNext;
    }
    if (changedParams.includes('allowSlidePrev')) {
        swiper.allowSlidePrev = passedParams.allowSlidePrev;
    }
    if (changedParams.includes('direction')) {
        swiper.changeDirection(passedParams.direction, false);
    }
    if (loopNeedDestroy || loopNeedReloop) {
        swiper.loopDestroy();
    }
    if (loopNeedEnable || loopNeedReloop) {
        swiper.loopCreate();
    }
    swiper.update();
}
;
}}),
"[project]/node_modules/swiper/shared/update-on-virtual-data.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "a": (()=>getChangedParams),
    "g": (()=>getParams),
    "m": (()=>mountSwiper),
    "u": (()=>updateOnVirtualData)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$update$2d$swiper$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/swiper/shared/update-swiper.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$swiper$2d$core$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/swiper/shared/swiper-core.mjs [app-ssr] (ecmascript)");
;
;
function getParams(obj, splitEvents) {
    if (obj === void 0) {
        obj = {};
    }
    if (splitEvents === void 0) {
        splitEvents = true;
    }
    const params = {
        on: {}
    };
    const events = {};
    const passedParams = {};
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$update$2d$swiper$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["e"])(params, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$swiper$2d$core$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["d"]);
    params._emitClasses = true;
    params.init = false;
    const rest = {};
    const allowedParams = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$update$2d$swiper$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"].map((key)=>key.replace(/_/, ''));
    const plainObj = Object.assign({}, obj);
    Object.keys(plainObj).forEach((key)=>{
        if (typeof obj[key] === 'undefined') return;
        if (allowedParams.indexOf(key) >= 0) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$update$2d$swiper$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["i"])(obj[key])) {
                params[key] = {};
                passedParams[key] = {};
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$update$2d$swiper$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["e"])(params[key], obj[key]);
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$update$2d$swiper$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["e"])(passedParams[key], obj[key]);
            } else {
                params[key] = obj[key];
                passedParams[key] = obj[key];
            }
        } else if (key.search(/on[A-Z]/) === 0 && typeof obj[key] === 'function') {
            if (splitEvents) {
                events[`${key[2].toLowerCase()}${key.substr(3)}`] = obj[key];
            } else {
                params.on[`${key[2].toLowerCase()}${key.substr(3)}`] = obj[key];
            }
        } else {
            rest[key] = obj[key];
        }
    });
    [
        'navigation',
        'pagination',
        'scrollbar'
    ].forEach((key)=>{
        if (params[key] === true) params[key] = {};
        if (params[key] === false) delete params[key];
    });
    return {
        params,
        passedParams,
        rest,
        events
    };
}
function mountSwiper(_ref, swiperParams) {
    let { el, nextEl, prevEl, paginationEl, scrollbarEl, swiper } = _ref;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$update$2d$swiper$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["n"])(swiperParams) && nextEl && prevEl) {
        swiper.params.navigation.nextEl = nextEl;
        swiper.originalParams.navigation.nextEl = nextEl;
        swiper.params.navigation.prevEl = prevEl;
        swiper.originalParams.navigation.prevEl = prevEl;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$update$2d$swiper$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"])(swiperParams) && paginationEl) {
        swiper.params.pagination.el = paginationEl;
        swiper.originalParams.pagination.el = paginationEl;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$update$2d$swiper$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["b"])(swiperParams) && scrollbarEl) {
        swiper.params.scrollbar.el = scrollbarEl;
        swiper.originalParams.scrollbar.el = scrollbarEl;
    }
    swiper.init(el);
}
function getChangedParams(swiperParams, oldParams, children, oldChildren, getKey) {
    const keys = [];
    if (!oldParams) return keys;
    const addKey = (key)=>{
        if (keys.indexOf(key) < 0) keys.push(key);
    };
    if (children && oldChildren) {
        const oldChildrenKeys = oldChildren.map(getKey);
        const childrenKeys = children.map(getKey);
        if (oldChildrenKeys.join('') !== childrenKeys.join('')) addKey('children');
        if (oldChildren.length !== children.length) addKey('children');
    }
    const watchParams = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$update$2d$swiper$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"].filter((key)=>key[0] === '_').map((key)=>key.replace(/_/, ''));
    watchParams.forEach((key)=>{
        if (key in swiperParams && key in oldParams) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$update$2d$swiper$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["i"])(swiperParams[key]) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$update$2d$swiper$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["i"])(oldParams[key])) {
                const newKeys = Object.keys(swiperParams[key]);
                const oldKeys = Object.keys(oldParams[key]);
                if (newKeys.length !== oldKeys.length) {
                    addKey(key);
                } else {
                    newKeys.forEach((newKey)=>{
                        if (swiperParams[key][newKey] !== oldParams[key][newKey]) {
                            addKey(key);
                        }
                    });
                    oldKeys.forEach((oldKey)=>{
                        if (swiperParams[key][oldKey] !== oldParams[key][oldKey]) addKey(key);
                    });
                }
            } else if (swiperParams[key] !== oldParams[key]) {
                addKey(key);
            }
        }
    });
    return keys;
}
const updateOnVirtualData = (swiper)=>{
    if (!swiper || swiper.destroyed || !swiper.params.virtual || swiper.params.virtual && !swiper.params.virtual.enabled) return;
    swiper.updateSlides();
    swiper.updateProgress();
    swiper.updateSlidesClasses();
    if (swiper.parallax && swiper.params.parallax && swiper.params.parallax.enabled) {
        swiper.parallax.setTranslate();
    }
};
;
}}),
"[project]/node_modules/swiper/swiper-react.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Swiper React 11.2.6
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * https://swiperjs.com
 *
 * Copyright 2014-2025 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: March 19, 2025
 */ __turbopack_context__.s({
    "Swiper": (()=>Swiper),
    "SwiperSlide": (()=>SwiperSlide),
    "useSwiper": (()=>useSwiper),
    "useSwiperSlide": (()=>useSwiperSlide)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$swiper$2d$core$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/swiper/shared/swiper-core.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$update$2d$on$2d$virtual$2d$data$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/swiper/shared/update-on-virtual-data.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$update$2d$swiper$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/swiper/shared/update-swiper.mjs [app-ssr] (ecmascript)");
;
;
;
;
function _extends() {
    _extends = ("TURBOPACK compile-time truthy", 1) ? Object.assign.bind() : ("TURBOPACK unreachable", undefined);
    return _extends.apply(this, arguments);
}
function isChildSwiperSlide(child) {
    return child.type && child.type.displayName && child.type.displayName.includes('SwiperSlide');
}
function processChildren(c) {
    const slides = [];
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].Children.toArray(c).forEach((child)=>{
        if (isChildSwiperSlide(child)) {
            slides.push(child);
        } else if (child.props && child.props.children) {
            processChildren(child.props.children).forEach((slide)=>slides.push(slide));
        }
    });
    return slides;
}
function getChildren(c) {
    const slides = [];
    const slots = {
        'container-start': [],
        'container-end': [],
        'wrapper-start': [],
        'wrapper-end': []
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].Children.toArray(c).forEach((child)=>{
        if (isChildSwiperSlide(child)) {
            slides.push(child);
        } else if (child.props && child.props.slot && slots[child.props.slot]) {
            slots[child.props.slot].push(child);
        } else if (child.props && child.props.children) {
            const foundSlides = processChildren(child.props.children);
            if (foundSlides.length > 0) {
                foundSlides.forEach((slide)=>slides.push(slide));
            } else {
                slots['container-end'].push(child);
            }
        } else {
            slots['container-end'].push(child);
        }
    });
    return {
        slides,
        slots
    };
}
function renderVirtual(swiper, slides, virtualData) {
    if (!virtualData) return null;
    const getSlideIndex = (index)=>{
        let slideIndex = index;
        if (index < 0) {
            slideIndex = slides.length + index;
        } else if (slideIndex >= slides.length) {
            // eslint-disable-next-line
            slideIndex = slideIndex - slides.length;
        }
        return slideIndex;
    };
    const style = swiper.isHorizontal() ? {
        [swiper.rtlTranslate ? 'right' : 'left']: `${virtualData.offset}px`
    } : {
        top: `${virtualData.offset}px`
    };
    const { from, to } = virtualData;
    const loopFrom = swiper.params.loop ? -slides.length : 0;
    const loopTo = swiper.params.loop ? slides.length * 2 : slides.length;
    const slidesToRender = [];
    for(let i = loopFrom; i < loopTo; i += 1){
        if (i >= from && i <= to) {
            slidesToRender.push(slides[getSlideIndex(i)]);
        }
    }
    return slidesToRender.map((child, index)=>{
        return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].cloneElement(child, {
            swiper,
            style,
            key: child.props.virtualIndex || child.key || `slide-${index}`
        });
    });
}
function useIsomorphicLayoutEffect(callback, deps) {
    // eslint-disable-next-line
    if (typeof window === 'undefined') return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useEffect"])(callback, deps);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useLayoutEffect"])(callback, deps);
}
const SwiperSlideContext = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createContext"])(null);
const useSwiperSlide = ()=>{
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useContext"])(SwiperSlideContext);
};
const SwiperContext = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createContext"])(null);
const useSwiper = ()=>{
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useContext"])(SwiperContext);
};
const Swiper = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["forwardRef"])(function(_temp, externalElRef) {
    let { className, tag: Tag = 'div', wrapperTag: WrapperTag = 'div', children, onSwiper, ...rest } = _temp === void 0 ? {} : _temp;
    let eventsAssigned = false;
    const [containerClasses, setContainerClasses] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useState"])('swiper');
    const [virtualData, setVirtualData] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useState"])(null);
    const [breakpointChanged, setBreakpointChanged] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useState"])(false);
    const initializedRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useRef"])(false);
    const swiperElRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useRef"])(null);
    const swiperRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useRef"])(null);
    const oldPassedParamsRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useRef"])(null);
    const oldSlides = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useRef"])(null);
    const nextElRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useRef"])(null);
    const prevElRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useRef"])(null);
    const paginationElRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useRef"])(null);
    const scrollbarElRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useRef"])(null);
    const { params: swiperParams, passedParams, rest: restProps, events } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$update$2d$on$2d$virtual$2d$data$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["g"])(rest);
    const { slides, slots } = getChildren(children);
    const onBeforeBreakpoint = ()=>{
        setBreakpointChanged(!breakpointChanged);
    };
    Object.assign(swiperParams.on, {
        _containerClasses (swiper, classes) {
            setContainerClasses(classes);
        }
    });
    const initSwiper = ()=>{
        // init swiper
        Object.assign(swiperParams.on, events);
        eventsAssigned = true;
        const passParams = {
            ...swiperParams
        };
        delete passParams.wrapperClass;
        swiperRef.current = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$swiper$2d$core$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["S"](passParams);
        if (swiperRef.current.virtual && swiperRef.current.params.virtual.enabled) {
            swiperRef.current.virtual.slides = slides;
            const extendWith = {
                cache: false,
                slides,
                renderExternal: setVirtualData,
                renderExternalUpdate: false
            };
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$update$2d$swiper$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["e"])(swiperRef.current.params.virtual, extendWith);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$update$2d$swiper$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["e"])(swiperRef.current.originalParams.virtual, extendWith);
        }
    };
    if (!swiperElRef.current) {
        initSwiper();
    }
    // Listen for breakpoints change
    if (swiperRef.current) {
        swiperRef.current.on('_beforeBreakpoint', onBeforeBreakpoint);
    }
    const attachEvents = ()=>{
        if (eventsAssigned || !events || !swiperRef.current) return;
        Object.keys(events).forEach((eventName)=>{
            swiperRef.current.on(eventName, events[eventName]);
        });
    };
    const detachEvents = ()=>{
        if (!events || !swiperRef.current) return;
        Object.keys(events).forEach((eventName)=>{
            swiperRef.current.off(eventName, events[eventName]);
        });
    };
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        return ()=>{
            if (swiperRef.current) swiperRef.current.off('_beforeBreakpoint', onBeforeBreakpoint);
        };
    });
    // set initialized flag
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        if (!initializedRef.current && swiperRef.current) {
            swiperRef.current.emitSlidesClasses();
            initializedRef.current = true;
        }
    });
    // mount swiper
    useIsomorphicLayoutEffect(()=>{
        if (externalElRef) {
            externalElRef.current = swiperElRef.current;
        }
        if (!swiperElRef.current) return;
        if (swiperRef.current.destroyed) {
            initSwiper();
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$update$2d$on$2d$virtual$2d$data$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["m"])({
            el: swiperElRef.current,
            nextEl: nextElRef.current,
            prevEl: prevElRef.current,
            paginationEl: paginationElRef.current,
            scrollbarEl: scrollbarElRef.current,
            swiper: swiperRef.current
        }, swiperParams);
        if (onSwiper && !swiperRef.current.destroyed) onSwiper(swiperRef.current);
        // eslint-disable-next-line
        return ()=>{
            if (swiperRef.current && !swiperRef.current.destroyed) {
                swiperRef.current.destroy(true, false);
            }
        };
    }, []);
    // watch for params change
    useIsomorphicLayoutEffect(()=>{
        attachEvents();
        const changedParams = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$update$2d$on$2d$virtual$2d$data$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"])(passedParams, oldPassedParamsRef.current, slides, oldSlides.current, (c)=>c.key);
        oldPassedParamsRef.current = passedParams;
        oldSlides.current = slides;
        if (changedParams.length && swiperRef.current && !swiperRef.current.destroyed) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$update$2d$swiper$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["u"])({
                swiper: swiperRef.current,
                slides,
                passedParams,
                changedParams,
                nextEl: nextElRef.current,
                prevEl: prevElRef.current,
                scrollbarEl: scrollbarElRef.current,
                paginationEl: paginationElRef.current
            });
        }
        return ()=>{
            detachEvents();
        };
    });
    // update on virtual update
    useIsomorphicLayoutEffect(()=>{
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$update$2d$on$2d$virtual$2d$data$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["u"])(swiperRef.current);
    }, [
        virtualData
    ]);
    // bypass swiper instance to slides
    function renderSlides() {
        if (swiperParams.virtual) {
            return renderVirtual(swiperRef.current, slides, virtualData);
        }
        return slides.map((child, index)=>{
            return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].cloneElement(child, {
                swiper: swiperRef.current,
                swiperSlideIndex: index
            });
        });
    }
    return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].createElement(Tag, _extends({
        ref: swiperElRef,
        className: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$update$2d$swiper$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["d"])(`${containerClasses}${className ? ` ${className}` : ''}`)
    }, restProps), /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].createElement(SwiperContext.Provider, {
        value: swiperRef.current
    }, slots['container-start'], /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].createElement(WrapperTag, {
        className: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$update$2d$swiper$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["w"])(swiperParams.wrapperClass)
    }, slots['wrapper-start'], renderSlides(), slots['wrapper-end']), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$update$2d$swiper$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["n"])(swiperParams) && /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].createElement(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].Fragment, null, /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].createElement("div", {
        ref: prevElRef,
        className: "swiper-button-prev"
    }), /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].createElement("div", {
        ref: nextElRef,
        className: "swiper-button-next"
    })), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$update$2d$swiper$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["b"])(swiperParams) && /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].createElement("div", {
        ref: scrollbarElRef,
        className: "swiper-scrollbar"
    }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$update$2d$swiper$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"])(swiperParams) && /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].createElement("div", {
        ref: paginationElRef,
        className: "swiper-pagination"
    }), slots['container-end']));
});
Swiper.displayName = 'Swiper';
const SwiperSlide = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["forwardRef"])(function(_temp, externalRef) {
    let { tag: Tag = 'div', children, className = '', swiper, zoom, lazy, virtualIndex, swiperSlideIndex, ...rest } = _temp === void 0 ? {} : _temp;
    const slideElRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useRef"])(null);
    const [slideClasses, setSlideClasses] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useState"])('swiper-slide');
    const [lazyLoaded, setLazyLoaded] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useState"])(false);
    function updateClasses(_s, el, classNames) {
        if (el === slideElRef.current) {
            setSlideClasses(classNames);
        }
    }
    useIsomorphicLayoutEffect(()=>{
        if (typeof swiperSlideIndex !== 'undefined') {
            slideElRef.current.swiperSlideIndex = swiperSlideIndex;
        }
        if (externalRef) {
            externalRef.current = slideElRef.current;
        }
        if (!slideElRef.current || !swiper) {
            return;
        }
        if (swiper.destroyed) {
            if (slideClasses !== 'swiper-slide') {
                setSlideClasses('swiper-slide');
            }
            return;
        }
        swiper.on('_slideClass', updateClasses);
        // eslint-disable-next-line
        return ()=>{
            if (!swiper) return;
            swiper.off('_slideClass', updateClasses);
        };
    });
    useIsomorphicLayoutEffect(()=>{
        if (swiper && slideElRef.current && !swiper.destroyed) {
            setSlideClasses(swiper.getSlideClasses(slideElRef.current));
        }
    }, [
        swiper
    ]);
    const slideData = {
        isActive: slideClasses.indexOf('swiper-slide-active') >= 0,
        isVisible: slideClasses.indexOf('swiper-slide-visible') >= 0,
        isPrev: slideClasses.indexOf('swiper-slide-prev') >= 0,
        isNext: slideClasses.indexOf('swiper-slide-next') >= 0
    };
    const renderChildren = ()=>{
        return typeof children === 'function' ? children(slideData) : children;
    };
    const onLoad = ()=>{
        setLazyLoaded(true);
    };
    return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].createElement(Tag, _extends({
        ref: slideElRef,
        className: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$swiper$2f$shared$2f$update$2d$swiper$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["d"])(`${slideClasses}${className ? ` ${className}` : ''}`),
        "data-swiper-slide-index": virtualIndex,
        onLoad: onLoad
    }, rest), zoom && /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].createElement(SwiperSlideContext.Provider, {
        value: slideData
    }, /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].createElement("div", {
        className: "swiper-zoom-container",
        "data-swiper-zoom": typeof zoom === 'number' ? zoom : undefined
    }, renderChildren(), lazy && !lazyLoaded && /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].createElement("div", {
        className: "swiper-lazy-preloader"
    }))), !zoom && /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].createElement(SwiperSlideContext.Provider, {
        value: slideData
    }, renderChildren(), lazy && !lazyLoaded && /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].createElement("div", {
        className: "swiper-lazy-preloader"
    })));
});
SwiperSlide.displayName = 'SwiperSlide';
;
}}),

};

//# sourceMappingURL=node_modules_e2c94d9f._.js.map